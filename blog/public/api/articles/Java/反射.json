{"title":"Java反射学习笔记","uid":"4f643f8888ac5de96f9123ba132fb3d8","slug":"Java/反射","date":"2023-02-08T12:33:12.000Z","updated":"2023-02-12T04:00:11.065Z","comments":true,"path":"api/articles/Java/反射.json","keywords":null,"cover":"https://yimoorua-img.oss-cn-chengdu.aliyuncs.com/images/AgAAC6u-TVO-6GCp-41Pb5VAdprXFwlM.png","content":"<h1 id=\"Java反射机制\"><a href=\"#Java反射机制\" class=\"headerlink\" title=\"Java反射机制\"></a>Java反射机制</h1><h2 id=\"1、Java反射机制概述\"><a href=\"#1、Java反射机制概述\" class=\"headerlink\" title=\"1、Java反射机制概述\"></a>1、Java反射机制概述</h2><h3 id=\"1-1-Java反射（Java-Reflection）\"><a href=\"#1-1-Java反射（Java-Reflection）\" class=\"headerlink\" title=\"1.1 Java反射（Java Reflection）\"></a>1.1 Java反射（Java Reflection）</h3><ul>\n<li><p>Reflection (反射)是被视为<span style=\"color:red\">动态语言</span>的关键，反射机制允许程序在执行期 借助于Reflection API取得任何类的内部信息，并能直接操作任意对象的内 部属性及方法。</p>\n</li>\n<li><p>加载完类之后，在堆内存的方法区中就产生了一个Class类型的对象 (一个 类只有一个Class对象) ，这个对象就包含了完整的类的结构信息。我们可 以通过这个对象看到类的结构。<span style=\"color:red\">这个对象就像一面镜子，透过这个镜子看 到类的结构，所以，我们形象的称之为： </span><b style=\"color:red\">反射</b>。</p>\n<p>  正常方式： 引入需要的”包类”名称 <b style=\"color:red\">→</b>  通过new实例化 <b style=\"color:red\">→</b>  取得实例化对象<br>  反射方式：  实例化对象 <b style=\"color:red\">→</b>  getClass()方法 <b style=\"color:red\">→</b>  得到完整的“包类”名称</p>\n</li>\n</ul>\n<h3 id=\"1-2-补充：动态语言-vs-静态语言\"><a href=\"#1-2-补充：动态语言-vs-静态语言\" class=\"headerlink\" title=\"1.2 补充：动态语言 vs 静态语言\"></a>1.2 补充：动态语言 vs 静态语言</h3><p><strong>1、动态语言</strong><br>是一类在运行时可以改变其结构的语言：例如新的函数、对象、甚至代码可以被引进，已有的函数可以被删除或是其他结构上的变化。通俗点说就是<b style=\"color:red\">在运行时代码可以根据某些条件改变自身结构。</b><br>主要动态语言： <span style=\"color:blue\">Object-C、C#、JavaScript、PHP、Python、Erlang</span>。</p>\n<p><strong>2、静态语言</strong></p>\n<p>与动态语言相对应的， <span style=\"color:blue\">运行时结构不可变的语言就是静态语言。如Java、C、 C++</span>。</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>Java不是动态语言，但Java可以称之为<b style=\"color:red\">“准动态语言” </b>。即Java有一定的动态性，我们可以利用反射机制、字节码操作获得类似动态语言的特性。<br>Java的动态性让编程的时候更加灵活！</p></blockquote>\n<h3 id=\"1-3-Java反射机制研究及应用\"><a href=\"#1-3-Java反射机制研究及应用\" class=\"headerlink\" title=\"1.3 Java反射机制研究及应用\"></a>1.3 Java反射机制研究及应用</h3><p>Java反射机制提供的功能</p>\n<ul>\n<li>在运行时判断任意一个对象所属的类<ul>\n<li>在运行时构造任意一个类的对象</li>\n<li>在运行时判断任意一个类所具有的成员变量和方法</li>\n<li>在运行时获取泛型信息</li>\n<li>在运行时调用任意一个对象的成员变量和方法</li>\n<li>在运行时处理注解</li>\n<li>生成动态代理</li>\n</ul>\n</li>\n</ul>\n<p>反射相关的主要API</p>\n<ul>\n<li>java.lang.Class:代表一个类</li>\n<li>java.lang.reflect.Method:代表类的方法</li>\n<li>java.lang.reflect.Field:代表类的成员变量</li>\n<li>java.lang.reflect.Constructor:代表类的构造器</li>\n<li>… …</li>\n</ul>\n<h2 id=\"2、理解Class类并获取Class实例\"><a href=\"#2、理解Class类并获取Class实例\" class=\"headerlink\" title=\"2、理解Class类并获取Class实例\"></a>2、理解Class类并获取Class实例</h2><h3 id=\"2-1-Class-类\"><a href=\"#2-1-Class-类\" class=\"headerlink\" title=\"2.1 Class 类\"></a>2.1 Class 类</h3><p>在Object类中定义了以下的方法，此方法将被所有子类继承：</p>\n<p><b style=\"color:red\">public final Class getClass()</b></p>\n<p>以上的方法返回值的类型是一个Class类，此类是Java反射的源头，实际上所谓反射<br>从程序的运行结果来看也很好理解，即：<br>可以通过对象反射求出类的名称。</p>\n<p><img src=\"https://yimoorua-img.oss-cn-chengdu.aliyuncs.com/md-imgs/image-20230208093038117-20230208201701119.png\" alt=\"image-20230208093038117\"> </p>\n<ul>\n<li>对象照镜子后可以得到的信息：某个类的属性、方法和构造器、某个类到底实现了哪些接口。对于每个类而言， JRE 都为其保留一个不变的 Class 类型的对象。一个 Class 对象包含了特定某个结构<code>(class/interface/enum/annotation/primitive type/void/[])</code>的有关信息。<ul>\n<li>Class本身也是一个类</li>\n<li>Class 对象只能由系统建立对象</li>\n<li>一个加载的类在 JVM 中只会有一个Class实例</li>\n<li>一个Class对象对应的是一个加载到JVM中的一个.class文件</li>\n<li>每个类的实例都会记得自己是由哪个 Class 实例所生成</li>\n<li>通过Class可以完整地得到一个类中的所有被加载的结构</li>\n<li>Class类是Reflection的根源，针对任何你想动态加载、运行的类，唯有先获得相应的Class对象</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"2-2-Class类的常用方法\"><a href=\"#2-2-Class类的常用方法\" class=\"headerlink\" title=\"2.2 Class类的常用方法\"></a>2.2 Class类的常用方法</h3><table>\n<thead>\n<tr>\n<th>方法名</th>\n<th>功能说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>static Class forName(String name)</td>\n<td>返回指定类名 name 的 Class 对象</td>\n</tr>\n<tr>\n<td>Object newInstance()</td>\n<td>调用缺省构造函数，返回该Class对象的一个实例</td>\n</tr>\n<tr>\n<td>getName()</td>\n<td>返回此Class对象所表示的实体(类、接口、数组类、基本类型 或void)名称</td>\n</tr>\n<tr>\n<td>Class getSuperClass()</td>\n<td>返回当前Class对象的父类的Class对象</td>\n</tr>\n<tr>\n<td>Class [] getInterfaces()</td>\n<td>获取当前Class对象的接口</td>\n</tr>\n<tr>\n<td>ClassLoader getClassLoader()</td>\n<td>返回该类的类加载器</td>\n</tr>\n<tr>\n<td>Class getSuperclass()</td>\n<td>返回表示此Class所表示的实体的超类的Class</td>\n</tr>\n<tr>\n<td>Constructor[] getConstructors()</td>\n<td>返回一个包含某些Constructor对象的数组</td>\n</tr>\n<tr>\n<td>Field[] getDeclaredFields()</td>\n<td>返回Field对象的一个数组</td>\n</tr>\n<tr>\n<td>Method getMethod(String</td>\n<td>返回一个Method对象， 此对象的形参类型为paramType</td>\n</tr>\n</tbody></table>\n<h3 id=\"2-3-反射的应用举例\"><a href=\"#2-3-反射的应用举例\" class=\"headerlink\" title=\"2.3 反射的应用举例\"></a>2.3 反射的应用举例</h3><pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token class-name\">String</span> str <span class=\"token operator\">=</span> <span class=\"token string\">\"test4.Person\"</span><span class=\"token punctuation\">;</span>\n<span class=\"token class-name\">Class</span> clazz <span class=\"token operator\">=</span> <span class=\"token class-name\">Class</span><span class=\"token punctuation\">.</span><span class=\"token function\">forName</span><span class=\"token punctuation\">(</span>str<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token class-name\">Object</span> obj <span class=\"token operator\">=</span> clazz<span class=\"token punctuation\">.</span><span class=\"token function\">newInstance</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token class-name\">Field</span> field <span class=\"token operator\">=</span> clazz<span class=\"token punctuation\">.</span><span class=\"token function\">getField</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"name\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nfield<span class=\"token punctuation\">.</span><span class=\"token function\">set</span><span class=\"token punctuation\">(</span>obj<span class=\"token punctuation\">,</span> <span class=\"token string\">\"Peter\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token class-name\">Object</span> name <span class=\"token operator\">=</span> field<span class=\"token punctuation\">.</span><span class=\"token function\">get</span><span class=\"token punctuation\">(</span>obj<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span>name<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>注：test4.Person是test4包下的Person类</p>\n<h3 id=\"2-4-获取Class类的实例（四种方法）\"><a href=\"#2-4-获取Class类的实例（四种方法）\" class=\"headerlink\" title=\"2.4 获取Class类的实例（四种方法）\"></a>2.4 获取Class类的实例（四种方法）</h3><ol>\n<li>前提： 若已知具体的类，通过类的class属性获取， 该方法最为安全可靠， 程序性能最高<br>实例：<b style=\"color:green\">Class clazz = String.class;</b></li>\n<li>前提： 已知某个类的实例，调用该实例的getClass()方法获取Class对象<br>实例：<b style=\"color:green\">Class clazz = “<a href=\"http://www.yimoorua.top“/\">www.yimoorua.top“</a> .getClass();</b></li>\n<li>前提： 已知一个类的全类名，且该类在类路径下， 可通过Class类的静态方 法forName()获取，可能抛出ClassNotFoundException<br>实例：<strong>Class clazz = Class.forName(“java.lang.String”);</strong></li>\n<li>其他方式(不做要求)<br><b style=\"color:brown\">ClassLoader cl = this.getClass().getClassLoader();</b><br><b style=\"color:brown\">Class clazz4 = cl.loadClass(“类的全类名”);</b></li>\n</ol>\n<h3 id=\"2-5-哪些类型可以有Class对象？\"><a href=\"#2-5-哪些类型可以有Class对象？\" class=\"headerlink\" title=\"2.5 哪些类型可以有Class对象？\"></a>2.5 哪些类型可以有Class对象？</h3><ol>\n<li>class：外部类，成员(成员内部类，静态内部类) ，局部内部类，匿名内部类</li>\n<li>interface ：接口</li>\n<li>[]：数组</li>\n<li>enum：枚举</li>\n<li>annotation：注解@interface</li>\n<li>primitive type：基本数据类型</li>\n<li>void</li>\n</ol>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token class-name\">Class</span> c1 <span class=\"token operator\">=</span> <span class=\"token class-name\">Object</span><span class=\"token punctuation\">.</span><span class=\"token keyword\">class</span><span class=\"token punctuation\">;</span>\n<span class=\"token class-name\">Class</span> c2 <span class=\"token operator\">=</span> <span class=\"token class-name\">Comparable</span><span class=\"token punctuation\">.</span><span class=\"token keyword\">class</span><span class=\"token punctuation\">;</span>\n<span class=\"token class-name\">Class</span> c3 <span class=\"token operator\">=</span> <span class=\"token class-name\">String</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">.</span><span class=\"token keyword\">class</span><span class=\"token punctuation\">;</span>\n<span class=\"token class-name\">Class</span> c4 <span class=\"token operator\">=</span> <span class=\"token keyword\">int</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">.</span><span class=\"token keyword\">class</span><span class=\"token punctuation\">;</span>\n<span class=\"token class-name\">Class</span> c5 <span class=\"token operator\">=</span> <span class=\"token class-name\">ElementType</span><span class=\"token punctuation\">.</span><span class=\"token keyword\">class</span><span class=\"token punctuation\">;</span>\n<span class=\"token class-name\">Class</span> c6 <span class=\"token operator\">=</span> <span class=\"token class-name\">Override</span><span class=\"token punctuation\">.</span><span class=\"token keyword\">class</span><span class=\"token punctuation\">;</span>\n<span class=\"token class-name\">Class</span> c7 <span class=\"token operator\">=</span> <span class=\"token keyword\">int</span><span class=\"token punctuation\">.</span><span class=\"token keyword\">class</span><span class=\"token punctuation\">;</span>\n<span class=\"token class-name\">Class</span> c8 <span class=\"token operator\">=</span> <span class=\"token keyword\">void</span><span class=\"token punctuation\">.</span><span class=\"token keyword\">class</span><span class=\"token punctuation\">;</span>\n<span class=\"token class-name\">Class</span> c9 <span class=\"token operator\">=</span> <span class=\"token class-name\">Class</span><span class=\"token punctuation\">.</span><span class=\"token keyword\">class</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">int</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> a <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token keyword\">int</span><span class=\"token punctuation\">[</span><span class=\"token number\">10</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">int</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> b <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token keyword\">int</span><span class=\"token punctuation\">[</span><span class=\"token number\">100</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n<span class=\"token class-name\">Class</span> c10 <span class=\"token operator\">=</span> a<span class=\"token punctuation\">.</span><span class=\"token function\">getClass</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token class-name\">Class</span> c11 <span class=\"token operator\">=</span> b<span class=\"token punctuation\">.</span><span class=\"token function\">getClass</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token comment\">// 只要元素类型与维度一样，就是同一个Class</span>\n<span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span>c10 <span class=\"token operator\">==</span> c11<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h2 id=\"3、类的加载与ClassLoader的理解\"><a href=\"#3、类的加载与ClassLoader的理解\" class=\"headerlink\" title=\"3、类的加载与ClassLoader的理解\"></a>3、类的加载与ClassLoader的理解</h2><h3 id=\"3-1-了解：类的加载过程\"><a href=\"#3-1-了解：类的加载过程\" class=\"headerlink\" title=\"3.1 了解：类的加载过程\"></a>3.1 了解：类的加载过程</h3><p>当程序主动使用某个类时，如果该类还未被加载到内存中，则系统会通过 如下三个步骤来对该类进行初始化。</p>\n<p><img src=\"https://yimoorua-img.oss-cn-chengdu.aliyuncs.com/md-imgs/image-20230208142534991.png\" alt=\"image-20230208142534991\"></p>\n<ul>\n<li>加载：将class文件字节码内容加载到内存中，并将这些静态数据转换成方法区的运行时 数据结构，然后生成一个代表这个类的java.lang.Class对象，作为方法区中类数据的访问 入口(即引用地址)。所有需要访问和使用类数据只能通过这个Class对象。这个加载的 过程需要类加载器参与。</li>\n<li>链接：将Java类的二进制代码合并到JVM的运行状态之中的过程。<ul>\n<li>验证：确保加载的类信息符合JVM规范，例如：以cafe开头，没有安全方面的问题</li>\n<li>准备：正式为类变量(static)分配内存并&lt;b style=”color:blue&gt;”设置类变量默认初始值</b>的阶段，这些内存都将在方法区中进行分配。</li>\n<li>解析：虚拟机常量池内的符号引用(常量名)替换为直接引用(地址)的过程。</li>\n</ul>\n</li>\n<li>初始化：<ul>\n<li>执行<span style=\"color:blue\">类构造器<clinit>()方法的过程。 类构造器<clinit>()方法是由编译期自动收集类中 所有类变量的赋值动作和静态代码块中的语句合并产生的。</span>  (类构造器是构造类信 息的，不是构造该类对象的构造器) 。</li>\n<li>当初始化一个类的时候， 如果发现其父类还没有进行初始化，则需要先触发其父类 的初始化。</li>\n<li>虚拟机会保证一个类的<clinit>()方法在多线程环境中被正确加锁和同步</li>\n</ul>\n</li>\n</ul>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">ClassLoadingTest</span> <span class=\"token punctuation\">&#123;</span>\n         <span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">void</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">String</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> args<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n              <span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">A</span><span class=\"token punctuation\">.</span>m<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n         <span class=\"token punctuation\">&#125;</span>\n    <span class=\"token punctuation\">&#125;</span>\n\n<span class=\"token keyword\">class</span> <span class=\"token class-name\">A</span> <span class=\"token punctuation\">&#123;</span>\n       <span class=\"token keyword\">static</span> <span class=\"token punctuation\">&#123;</span>\n        m <span class=\"token operator\">=</span> <span class=\"token number\">300</span><span class=\"token punctuation\">;</span>\n      <span class=\"token punctuation\">&#125;</span> \n    <span class=\"token keyword\">static</span> <span class=\"token keyword\">int</span> m <span class=\"token operator\">=</span> <span class=\"token number\">100</span><span class=\"token punctuation\">;</span>\n   <span class=\"token punctuation\">&#125;</span>\n<span class=\"token comment\">//第二步：链接结束后m=0</span>\n<span class=\"token comment\">//第三步：初始化后， m的值由&lt;clinit>()方法执行决定</span>\n<span class=\"token comment\">//       这个A的类构造器&lt;clinit>()方法由类变量的赋值和静态代码块中的语句按照顺序合并 产生，类似于</span>\n<span class=\"token comment\">//     &lt;clinit>()&#123;</span>\n<span class=\"token comment\">//         m = 300;</span>\n<span class=\"token comment\">//         m = 100;</span>\n<span class=\"token comment\">//     &#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h3 id=\"3-2-了解：-什么时候会发生类初始化？\"><a href=\"#3-2-了解：-什么时候会发生类初始化？\" class=\"headerlink\" title=\"3.2 了解： 什么时候会发生类初始化？\"></a>3.2 了解： 什么时候会发生类初始化？</h3><ul>\n<li><strong>类的主动引用 (一定会发生类的初始化)</strong><ul>\n<li>当虚拟机启动，先初始化main方法所在的类</li>\n<li>new一个类的对象</li>\n<li>调用类的静态成员 (除了final常量) 和静态方法</li>\n<li>使用java.lang.reflect包的方法对类进行反射调用</li>\n<li>当初始化一个类，如果其父类没有被初始化，则先会初始化它的父类  </li>\n</ul>\n</li>\n<li><strong>类的被动引用 (不会发生类的初始化)</strong><ul>\n<li>当访问一个静态域时，只有真正声明这个域的类才会被初始化<ul>\n<li>当通过子类引用父类的静态变量，不会导致子类初始化  </li>\n</ul>\n</li>\n<li>通过数组定义类引用，不会触发此类的初始化</li>\n<li>引用常量不会触发此类的初始化 (常量在链接阶段就存入调用类的常量池中了)</li>\n</ul>\n</li>\n</ul>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">ClassLoadingTest</span> <span class=\"token punctuation\">&#123;</span>\n      <span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">void</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">String</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> args<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n         <span class=\"token comment\">// 主动引用：一定会导致A和Father的初始化 </span>\n         <span class=\"token comment\">// A a = new A();</span>\n         <span class=\"token comment\">// System.out.println(A.m);</span>\n         <span class=\"token comment\">// Class.forName(\"com.yimoorua.java2.A\");</span>\n         <span class=\"token comment\">// 被动引用</span>\n         <span class=\"token class-name\">A</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> array <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">A</span><span class=\"token punctuation\">[</span><span class=\"token number\">5</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span><span class=\"token comment\">//不会导致A和Father的 初始化</span>\n         <span class=\"token comment\">// System.out.println(A.b);//只会初始化 Father</span>\n         <span class=\"token comment\">// System.out.println(A.M);//不会导致A和 Father的初始化</span>\n<span class=\"token punctuation\">&#125;</span>\n        <span class=\"token keyword\">static</span> <span class=\"token punctuation\">&#123;</span>\n            <span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"main所在的类\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> \n     <span class=\"token punctuation\">&#125;</span>\n<span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token keyword\">class</span> <span class=\"token class-name\">Father</span> <span class=\"token punctuation\">&#123;</span>\n     <span class=\"token keyword\">static</span> <span class=\"token keyword\">int</span> b <span class=\"token operator\">=</span> <span class=\"token number\">2</span><span class=\"token punctuation\">;</span>\n     <span class=\"token keyword\">static</span> <span class=\"token punctuation\">&#123;</span>\n        <span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"父类被加载\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token punctuation\">&#125;</span>\n    <span class=\"token punctuation\">&#125;</span>\n<span class=\"token punctuation\">&#125;</span>\n\n<span class=\"token keyword\">class</span> <span class=\"token class-name\">A</span> <span class=\"token keyword\">extends</span> <span class=\"token class-name\">Father</span> <span class=\"token punctuation\">&#123;</span>\n      <span class=\"token keyword\">static</span> <span class=\"token punctuation\">&#123;</span>\n         <span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"子类被加载\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> \n         m <span class=\"token operator\">=</span> <span class=\"token number\">300</span><span class=\"token punctuation\">;</span>\n      <span class=\"token punctuation\">&#125;</span>\n    <span class=\"token keyword\">static</span> <span class=\"token keyword\">int</span> m <span class=\"token operator\">=</span> <span class=\"token number\">100</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">static</span> <span class=\"token keyword\">final</span> <span class=\"token keyword\">int</span> <span class=\"token class-name\">M</span> <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h3 id=\"3-3-类加载器的作用\"><a href=\"#3-3-类加载器的作用\" class=\"headerlink\" title=\"3.3 类加载器的作用\"></a>3.3 类加载器的作用</h3><p><img src=\"https://yimoorua-img.oss-cn-chengdu.aliyuncs.com/md-imgs/image-20230208144013812.png\" alt=\"image-20230208144013812\"></p>\n<ul>\n<li><b>类加载的作用：</b><br> 将class文件字节码内容加载到内存中，并将这些静态数据<span style=\"color:blue\">转换成方法区的运行时数据结构</span>，然后在堆中生成一个代表这个类的java.lang.Class对象，作为方法区中类数据的访问入口。</li>\n<li><b>类缓存：</b><br> 标准的JavaSE类加载器可以按要求查找类，但一旦某个类被加载到类加载器中，它将维持加载 (缓存) 一段时间。不过JVM垃圾回收机制可以回收这些Class对象。</li>\n</ul>\n<h3 id=\"3-4-了解：-ClassLoader\"><a href=\"#3-4-了解：-ClassLoader\" class=\"headerlink\" title=\"3.4 了解： ClassLoader\"></a>3.4 了解： ClassLoader</h3><p><span style=\"color:blue\">类加载器作用是用来把类(class)装载进内存的。</span> JVM 规范定义了如下类型的类的加载器。</p>\n<p><img src=\"https://yimoorua-img.oss-cn-chengdu.aliyuncs.com/md-imgs/image-20230208144348765.png\" alt=\"image-20230208144348765\"> </p>\n<ul>\n<li><b style=\"color:yellow\">引导类加载器(Bootstap)：</b>用C++编写的，是JVM自带的类加载器， 负责Java平台核心库，用来装载核心类库。该加载器无法直接获取</li>\n<li><b style=\"color:yellow\">扩展类加载器(Extension)：</b>负责jre/lib/ext目录下的jar包或 – D java.ext.dirs 指定目录下的jar包装入工作库</li>\n<li><b style=\"color:yellow\">系统类加载器(System)：</b>负责java –classpath 或 – D java.class.path所指的目录下的类与jar包装入工作 ，是最常用的加载器</li>\n</ul>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token comment\">//1.获取一个系统类加载器</span>\n<span class=\"token class-name\">ClassLoader</span> classloader <span class=\"token operator\">=</span> <span class=\"token class-name\">ClassLoader</span><span class=\"token punctuation\">.</span><span class=\"token function\">getSystemClassLoader</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span>classloader<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token comment\">//2.获取系统类加载器的父类加载器，即扩展类加载器</span>\nclassloader <span class=\"token operator\">=</span> classloader<span class=\"token punctuation\">.</span><span class=\"token function\">getParent</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span>classloader<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token comment\">//3.获取扩展类加载器的父类加载器，即引导类加载器</span>\nclassloader <span class=\"token operator\">=</span> classloader<span class=\"token punctuation\">.</span><span class=\"token function\">getParent</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span>classloader<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token comment\">//4.测试当前类由哪个类加载器进行加载</span>\nclassloader <span class=\"token operator\">=</span> <span class=\"token class-name\">Class</span><span class=\"token punctuation\">.</span><span class=\"token function\">forName</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"exer2.ClassloaderDemo\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">getClassLoader</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span>classloader<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token comment\">//5.测试JDK提供的Object类由哪个类加载器加载</span>\nclassloader <span class=\"token operator\">=</span>\n<span class=\"token class-name\">Class</span><span class=\"token punctuation\">.</span><span class=\"token function\">forName</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"java.lang.Object\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">getClassLoader</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span>classloader<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token comment\">//*6.关于类加载器的一个主要方法： getResourceAsStream(String str):获取类路 径下的指定文件的输入流</span>\n<span class=\"token class-name\">InputStream</span> in <span class=\"token operator\">=</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">;</span>\nin <span class=\"token operator\">=</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span><span class=\"token function\">getClass</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">getClassLoader</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">getResourceAsStream</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"exer2\\\\test.properties\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span>in<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h2 id=\"4、创建运行时类的对象\"><a href=\"#4、创建运行时类的对象\" class=\"headerlink\" title=\"4、创建运行时类的对象\"></a>4、创建运行时类的对象</h2><p><b style=\"color:blue;font-size:20px\">有了Class对象，能做什么？</b><br><b style=\"color:red\">创建类的对象：</b> 调用Class对象的newInstance()方法<br>要 求：<br>      1) 类必须有一个无参数的构造器。<br>      2) 类的构造器的访问权限需要足够。</p>\n<p><b style=\"color:red\">难道没有无参的构造器就不能创建对象了吗？</b><br>不是！只要在操作的时候明确的调用类中的构造器， 并将参数传递进去之后，才可以实例化操作。 </p>\n<p>步骤如下：</p>\n<ol>\n<li>通过Class类的<span style=\"color:red\">getDeclaredConstructor(Class … parameterTypes)</span>取得本类的指定形参类型的构造器</li>\n<li>向构造器的形参中传递一个对象数组进去，里面包含了构造器中所需的各个参数。         </li>\n<li>通过Constructor实例化对象。</li>\n</ol>\n<p><img src=\"https://yimoorua-img.oss-cn-chengdu.aliyuncs.com/md-imgs/image-20230208145212348.png\" alt=\"image-20230208145212348\"> </p>\n<p><span style=\"color:green\">以上是反射机制应用最多的地方。</span> </p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token comment\">//1.根据全类名获取对应的Class对象</span>\n<span class=\"token class-name\">String</span> name <span class=\"token operator\">=</span> “<span class=\"token class-name\"><span class=\"token namespace\">yimoorua<span class=\"token punctuation\">.</span>java<span class=\"token punctuation\">.</span></span>Person</span>\"<span class=\"token punctuation\">;</span>\n<span class=\"token class-name\">Class</span> clazz <span class=\"token operator\">=</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">;</span>\nclazz <span class=\"token operator\">=</span> <span class=\"token class-name\">Class</span><span class=\"token punctuation\">.</span><span class=\"token function\">forName</span><span class=\"token punctuation\">(</span>name<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token comment\">//2.调用指定参数结构的构造器，生成Constructor的实例</span>\n<span class=\"token class-name\">Constructor</span> con <span class=\"token operator\">=</span> clazz<span class=\"token punctuation\">.</span><span class=\"token function\">getConstructor</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">String</span><span class=\"token punctuation\">.</span><span class=\"token keyword\">class</span><span class=\"token punctuation\">,</span><span class=\"token class-name\">Integer</span><span class=\"token punctuation\">.</span><span class=\"token keyword\">class</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token comment\">//3.通过Constructor的实例创建对应类的对象，并初始化类属性</span>\n<span class=\"token class-name\">Person</span> p2 <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token class-name\">Person</span><span class=\"token punctuation\">)</span> con<span class=\"token punctuation\">.</span><span class=\"token function\">newInstance</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Peter\"</span><span class=\"token punctuation\">,</span><span class=\"token number\">20</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span>p2<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h2 id=\"5、获取运行时类的完整结构\"><a href=\"#5、获取运行时类的完整结构\" class=\"headerlink\" title=\"5、获取运行时类的完整结构\"></a>5、获取运行时类的完整结构</h2><p><b style=\"font-size:20px\">通过反射获取运行时类的完整结构</b></p>\n<p><b style=\"color:blue\">Field、Method 、Constructor、Superclass、Interface 、Annotation</b></p>\n<ul>\n<li>实现的全部接口</li>\n<li>所继承的父类</li>\n<li>全部的构造器</li>\n<li>全部的方法</li>\n<li>全部的Field</li>\n</ul>\n<p><b style=\"font-size:20px\">使用反射可以取得：</b><br><b style=\"color:green\">1. 实现的全部接口</b><br> public Class&lt;?&gt;[] getInterfaces()<br> 确定此对象所表示的类或接口实现的接口。</p>\n<p><b style=\"color:green\">2. 所继承的父类</b><br> public Class&lt;? Super T&gt; getSuperclass()<br>返回表示此 Class 所表示的实体(类、接口、基本类型)的父类的 Class。</p>\n<p><b style=\"color:green\">3. 全部的构造器</b><br>public Constructor<T>[] getConstructors()<br>返回此 Class 对象所表示的类的所有public构造方法。<br>public Constructor<T>[] getDeclaredConstructors()<br>返回此 Class 对象表示的类声明的所有构造方法。</p>\n<p>Constructor类中：</p>\n<ul>\n<li>取得修饰符: public int getModifiers();</li>\n<li>取得方法名称: public String getName();</li>\n<li>取得参数的类型： public Class&lt;?&gt;[] getParameterTypes();</li>\n</ul>\n<p><b style=\"color:green\">4. 全部的方法</b><br> <span style=\"color:green\">public Method[] getDeclaredMethods()</span><br>返回此Class对象所表示的类或接口的全部方法<br> <span style=\"color:green\">public Method[] getMethods()</span><br>返回此Class对象所表示的类或接口的public的方法</p>\n<p> Method类中：<br> <span style=\"color:green\">public Class<?> getReturnType()</span>取得全部的返回值\n <span style=\"color:green\">public Class<?>[] getParameterTypes()</span>取得全部的参数<br> <span style=\"color:green\">public int getModifiers()</span>取得修饰符<br> <span style=\"color:green\">public Class&lt;?&gt;[] getExceptionTypes()</span>取得异常信息</p>\n<p><b style=\"color:green\">5. 全部的Field</b><br> <span style=\"color:green\">public Field[] getFields()</span><br>返回此Class对象所表示的类或接口的public的Field。<br> <span style=\"color:green\">public Field[] getDeclaredFields()</span><br>返回此Class对象所表示的类或接口的全部Field。</p>\n<p> Field方法中：<br> <span style=\"color:green\">public int getModifiers()  </span>以整数形式返回此Field的修饰符<br> <span style=\"color:green\">public Class&lt;?&gt; getType()  </span>得到Field的属性类型<br> <span style=\"color:green\">public String getName()  </span>返回Field的名称。</p>\n<p><b style=\"color:green\">6. Annotation相关</b><br>  <span style=\"color:green\">get Annotation(Class<T> annotationClass)</span><br>  <span style=\"color:green\">getDeclaredAnnotations()</span></p>\n<p><b style=\"color:green\">7. 泛型相关</b><br>获取父类泛型类型： <span style=\"color:green\">Type getGenericSuperclass()</span><br>泛型类型： <span style=\"color:green\">ParameterizedType</span><br>获取实际的泛型类型参数数组： <span style=\"color:green\">getActualTypeArguments()</span></p>\n<p><b style=\"color:green\">8. 类所在的包  Package getPackage()</b></p>\n<p><strong>小 结：</strong><br>1.在实际的操作中，取得类的信息的操作代码，并不会经常开发。<br>2.一定要熟悉java.lang.reflect包的作用，反射机制。<br>3.如何取得属性、方法、构造器的名称，修饰符等。</p>\n<h2 id=\"6、调用运行时类的指定结构\"><a href=\"#6、调用运行时类的指定结构\" class=\"headerlink\" title=\"6、调用运行时类的指定结构\"></a>6、调用运行时类的指定结构</h2><h3 id=\"6-1-调用指定方法\"><a href=\"#6-1-调用指定方法\" class=\"headerlink\" title=\"6.1 调用指定方法\"></a>6.1 调用指定方法</h3><p>通过反射，调用类中的方法，通过Method类完成。步骤：                  </p>\n<ol>\n<li>通过Class类的<span style=\"color:green\">getMethod(String name,Class…parameterTypes)</span>方法取得 一个Method对象，并设置此方法操作时所需要的参数类型。                </li>\n<li>之后使用<span style=\"color:green\">Object invoke(Object obj, Object[] args)</span>进行调用，并向方法中传递要设置的obj对象的参数信息。</li>\n</ol>\n<p><img src=\"https://yimoorua-img.oss-cn-chengdu.aliyuncs.com/md-imgs/image-20230208152228557.png\" alt=\"image-20230208152228557\"> </p>\n<p><b style=\"color:green\">Object invoke (Object obj ,Object…args)</b></p>\n<p>说明：</p>\n<ol>\n<li>Object 对应原方法的返回值，若原方法无返回值，此时返回null </li>\n<li>若原方法若为静态方法，此时形参Object obj可为null         </li>\n<li>若原方法形参列表为空，则Object[] args为null</li>\n<li>若原方法声明为private,则需要在调用此invoke()方法前，显式调用 方法对象的setAccessible(true)方法，将可访问private的方法。</li>\n</ol>\n<h3 id=\"6-2-调用指定属性\"><a href=\"#6-2-调用指定属性\" class=\"headerlink\" title=\"6.2 调用指定属性\"></a>6.2 调用指定属性</h3><p>在反射机制中，可以直接通过Field类操作类中的属性，通过Field类提供的set()和 get()方法就可以完成设置和取得属性内容的操作。</p>\n<ul>\n<li><span style=\"color:green\">public Field getField(String name) </span>返回此Class对象表示的类或接口的指定的 public的Field。</li>\n<li><span style=\"color:green\">public Field getDeclaredField(String name)</span>返回此Class对象表示的类或接口的 指定的Field。</li>\n</ul>\n<p><strong>在Field中：</strong></p>\n<ul>\n<li><span style=\"color:green\">public Object get(Object obj)</span> 取得指定对象obj上此Field的属性内容</li>\n<li><span style=\"color:green\">public void set(Object obj,Object value) </span>设置指定对象obj上此Field的属性内容</li>\n</ul>\n<h3 id=\"6-3-关于setAccessible方法的使用\"><a href=\"#6-3-关于setAccessible方法的使用\" class=\"headerlink\" title=\"6.3 关于setAccessible方法的使用\"></a>6.3 关于setAccessible方法的使用</h3><ul>\n<li>Method和Field 、Constructor对象都有setAccessible()方法。</li>\n<li>setAccessible启动和禁用访问安全检查的开关。</li>\n<li>参数值为true则指示反射的对象在使用时应该取消Java语言访问检查。   <ul>\n<li>提高反射的效率。如果代码中必须用反射，而该句代码需要频繁的被调用，那么请设置为true。</li>\n<li>使得原本无法访问的私有成员也可以访问</li>\n</ul>\n</li>\n<li>参数值为false则指示反射的对象应该实施Java语言访问检查。</li>\n</ul>\n<h2 id=\"7、反射的应用：动态代理\"><a href=\"#7、反射的应用：动态代理\" class=\"headerlink\" title=\"7、反射的应用：动态代理\"></a>7、反射的应用：动态代理</h2><h3 id=\"7-1-代理设计模式的原理\"><a href=\"#7-1-代理设计模式的原理\" class=\"headerlink\" title=\"7.1 代理设计模式的原理:\"></a>7.1 代理设计模式的原理:</h3><p>使用一个代理将对象包装起来, 然后用该代理对象取代原始对象。任何对原 始对象的调用都要通过代理。代理对象决定是否以及何时将方法调用转到原 始对象上。</p>\n<ul>\n<li>之前为大家讲解过代理机制的操作，属于静态代理，特征是代理类和目标 对象的类都是在编译期间确定下来，不利于程序的扩展。同时，每一个代 理类只能为一个接口服务，这样一来程序开发中必然产生过多的代理。 <b style=\"color:blue\">最好可以通过一个代理类完成全部的代理功能。</b></li>\n<li>动态代理是指客户通过代理类来调用其它对象的方法，并且是在程序运行时根据需要动态创建目标类的代理对象。</li>\n<li>动态代理使用场合:<ul>\n<li>调试</li>\n<li>远程方法调用</li>\n</ul>\n</li>\n<li><b>动态代理相比于静态代理的优点：</b><br>抽象角色中(接口)声明的所有方法都被转移到调用处理器一个集中的方法中 处理，这样，我们可以更加灵活和统一的处理众多的方法。</li>\n</ul>\n<h3 id=\"7-2-Java动态代理相关API\"><a href=\"#7-2-Java动态代理相关API\" class=\"headerlink\" title=\"7.2 Java动态代理相关API\"></a>7.2 Java动态代理相关API</h3><ul>\n<li><b style=\"color:green\">Proxy </b>：专门完成代理的操作类，是所有动态代理类的父类。通过此类为一 个或多个接口动态地生成实现类。</li>\n<li>提供用于创建动态代理类和动态代理对象的静态方法<ul>\n<li><span style=\"color:green\">static Class<?> getProxyClass(ClassLoader loader, Class<?>… interfaces)  </span>创建一个动态代理类所对应的Class对象</li>\n<li><span style=\"color:green\">static Object   newProxyInstance(ClassLoader loader, Class&lt;?&gt;[] interfaces, InvocationHandler h)  </span>直接创建一个动态代理对象</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"7-3-动态代理步骤\"><a href=\"#7-3-动态代理步骤\" class=\"headerlink\" title=\"7.3 动态代理步骤\"></a>7.3 动态代理步骤</h3><ol>\n<li>创建一个实现接口InvocationHandler的类，它必须实现invoke方法，以完成代理的具体操作。<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token class-name\">Object</span> <span class=\"token function\">invoke</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">Object</span> theProxy #代理类的对象<span class=\"token punctuation\">,</span> <span class=\"token class-name\">Method</span> method #要调用的方法<span class=\"token punctuation\">,</span> <span class=\"token class-name\">Object</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> params #方法调用时所需要的参数<span class=\"token punctuation\">)</span> <span class=\"token keyword\">throws</span> <span class=\"token class-name\">Throwable</span><span class=\"token punctuation\">&#123;</span>\n      <span class=\"token keyword\">try</span><span class=\"token punctuation\">&#123;</span>\n          <span class=\"token class-name\">Object</span> retval <span class=\"token operator\">=</span> method<span class=\"token punctuation\">.</span><span class=\"token function\">invoke</span><span class=\"token punctuation\">(</span>targetObj<span class=\"token punctuation\">,</span> params<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n          <span class=\"token comment\">// Print out the result</span>\n          <span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span>retval<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n          <span class=\"token keyword\">return</span> retval<span class=\"token punctuation\">;</span> \n        <span class=\"token punctuation\">&#125;</span><span class=\"token keyword\">catch</span> <span class=\"token punctuation\">(</span><span class=\"token class-name\">Exception</span> exc<span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span><span class=\"token punctuation\">&#125;</span>\n     <span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>\n<li>创建被代理的类以及接口</li>\n</ol>\n<p><img src=\"https://yimoorua-img.oss-cn-chengdu.aliyuncs.com/md-imgs/image-20230208155217655.png\" alt=\"image-20230208155217655\"><br>3. 通过Proxy的静态方法<br>newProxyInstance(ClassLoader loader, Class[] interfaces, InvocationHandler h) //创建一个Subject接口代理<br><span style=\"color:green\">RealSubject target = new RealSubject();</span><br>// Create a proxy to wrap the original implementation<br><span style=\"color:green\">DebugProxy proxy = new DebugProxy(target);</span><br>// Get a reference to the proxy through the Subject interface<br><span style=\"color:green\">Subject sub = (Subject) Proxy.newProxyInstance(<br>Subject.class.getClassLoader(),new Class[] { Subject.class }, proxy);</span><br>4. 通过 Subject代理调用RealSubject实现类的方法<br><b style=\"color:green\">String info = sub.say(“Peter”, 24);</b><br><b style=\"color:green\">System.out.println(info);</b></p>\n<h3 id=\"7-4-动态代理与AOP-Aspect-Orient-Programming\"><a href=\"#7-4-动态代理与AOP-Aspect-Orient-Programming\" class=\"headerlink\" title=\"7.4 动态代理与AOP  (Aspect Orient Programming)\"></a>7.4 动态代理与AOP  (Aspect Orient Programming)</h3><p>前面介绍的Proxy和InvocationHandler，很难看出这种动态代理的优势，下 面介绍一种更实用的动态代理机制</p>\n<p><img src=\"https://yimoorua-img.oss-cn-chengdu.aliyuncs.com/md-imgs/image-20230208160013463.png\" alt=\"image-20230208160013463\"> </p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">interface</span> <span class=\"token class-name\">Dog</span><span class=\"token punctuation\">&#123;</span> \n     <span class=\"token keyword\">void</span> <span class=\"token function\">info</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n     <span class=\"token keyword\">void</span> <span class=\"token function\">run</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">&#125;</span>\n\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">HuntingDog</span> <span class=\"token keyword\">implements</span> <span class=\"token class-name\">Dog</span><span class=\"token punctuation\">&#123;</span>\n   <span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">info</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span>\n      <span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"我是一只猎狗\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token punctuation\">&#125;</span>\n   <span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">run</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span>\n      <span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"我奔跑迅速\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">&#125;</span>\n<span class=\"token punctuation\">&#125;</span>\n\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">DogUtil</span><span class=\"token punctuation\">&#123;</span>\n     <span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">method1</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span>\n         <span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"=====模拟通用方法一=====\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token punctuation\">&#125;</span>\n     <span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">method2</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span>\n         <span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"=====模拟通用方法二=====\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">&#125;</span>\n<span class=\"token punctuation\">&#125;</span>\n\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">MyInvocationHandler</span> <span class=\"token keyword\">implements</span> <span class=\"token class-name\">InvocationHandler</span><span class=\"token punctuation\">&#123;</span>\n     <span class=\"token comment\">// 需要被代理的对象</span>\n     <span class=\"token keyword\">private</span> <span class=\"token class-name\">Object</span> target<span class=\"token punctuation\">;</span>\n     <span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">setTarget</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">Object</span> target<span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span>\n     <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>target <span class=\"token operator\">=</span> target<span class=\"token punctuation\">;</span><span class=\"token punctuation\">&#125;</span>\n     <span class=\"token comment\">// 执行动态代理对象的所有方法时， 都会被替换成执行如下的invoke方法</span>\n<span class=\"token keyword\">public</span> <span class=\"token class-name\">Object</span> <span class=\"token function\">invoke</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">Object</span> proxy<span class=\"token punctuation\">,</span> <span class=\"token class-name\">Method</span> method<span class=\"token punctuation\">,</span> <span class=\"token class-name\">Object</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> args<span class=\"token punctuation\">)</span> <span class=\"token keyword\">throws</span> <span class=\"token class-name\">Exception</span><span class=\"token punctuation\">&#123;</span>\n      <span class=\"token class-name\">DogUtil</span> du <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">DogUtil</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n      <span class=\"token comment\">// 执行DogUtil对象中的method1。</span>\n      du<span class=\"token punctuation\">.</span><span class=\"token function\">method1</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n      <span class=\"token comment\">// 以target作为主调来执行method方法</span>\n      <span class=\"token class-name\">Object</span> result <span class=\"token operator\">=</span> method<span class=\"token punctuation\">.</span><span class=\"token function\">invoke</span><span class=\"token punctuation\">(</span>target <span class=\"token punctuation\">,</span> args<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n      <span class=\"token comment\">// 执行DogUtil对象中的method2。</span>\n      du<span class=\"token punctuation\">.</span><span class=\"token function\">method2</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n      <span class=\"token keyword\">return</span> result<span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">&#125;</span>\n      <span class=\"token punctuation\">&#125;</span>\n      \n<span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">MyProxyFactory</span><span class=\"token punctuation\">&#123;</span>\n   <span class=\"token comment\">// 为指定target生成动态代理对象</span>\n   <span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token class-name\">Object</span> <span class=\"token function\">getProxy</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">Object</span> target<span class=\"token punctuation\">)</span> <span class=\"token keyword\">throws</span> <span class=\"token class-name\">Exception</span><span class=\"token punctuation\">&#123;</span>\n    <span class=\"token comment\">// 创建一个MyInvokationHandler对象</span>\n    <span class=\"token class-name\">MyInvokationHandler</span> handler <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">MyInvokationHandler</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n   <span class=\"token comment\">// 为MyInvokationHandler设置target对象</span>\n    handler<span class=\"token punctuation\">.</span><span class=\"token function\">setTarget</span><span class=\"token punctuation\">(</span>target<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n   <span class=\"token comment\">// 创建、并返回一个动态代理对象</span>\n   <span class=\"token keyword\">return</span> <span class=\"token class-name\">Proxy</span><span class=\"token punctuation\">.</span><span class=\"token function\">newProxyInstance</span><span class=\"token punctuation\">(</span>target<span class=\"token punctuation\">.</span><span class=\"token function\">getClass</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">getClassLoader</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>target<span class=\"token punctuation\">.</span><span class=\"token function\">getClass</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">getInterfaces</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">,</span> handler<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token punctuation\">&#125;</span>\n<span class=\"token punctuation\">&#125;</span>\n\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">Test</span><span class=\"token punctuation\">&#123;</span>\n     <span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">void</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">String</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> args<span class=\"token punctuation\">)</span> <span class=\"token keyword\">throws</span> <span class=\"token class-name\">Exception</span><span class=\"token punctuation\">&#123;</span>\n     <span class=\"token comment\">// 创建一个原始的HuntingDog对象，作为target</span>\n       <span class=\"token class-name\">Dog</span> target <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">HuntingDog</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n     <span class=\"token comment\">// 以指定的target来创建动态代理</span>\n       <span class=\"token class-name\">Dog</span> dog <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token class-name\">Dog</span><span class=\"token punctuation\">)</span><span class=\"token class-name\">MyProxyFactory</span><span class=\"token punctuation\">.</span><span class=\"token function\">getProxy</span><span class=\"token punctuation\">(</span>target<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> \n       dog<span class=\"token punctuation\">.</span><span class=\"token function\">info</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n       dog<span class=\"token punctuation\">.</span><span class=\"token function\">run</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">&#125;</span>\n  <span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<ul>\n<li>使用Proxy生成一个动态代理时，往往并不会凭空产生一个动态代理，这样没有太大的意义。通常都是为指定的目标对象生成动态代理</li>\n<li>这种动态代理在AOP中被称为AOP代理， AOP代理可代替目标对象， AOP代理包含了目标对象的全部方法。但AOP代理中的方法与目标对象的方法存在差异：<br><b style=\"color:red\">AOP代理里的方法可以在执行目标方法之前、之后插入一些通用处理</b></li>\n</ul>\n<p>AOP代理的方法：</p>\n<ol>\n<li>动态代理增加的通用方法1</li>\n<li>回调目标对象的方法</li>\n<li>动态代理增加的通用方法2</li>\n</ol>\n","feature":true,"text":"Java反射机制1、Java反射机制概述1.1 Java反射（Java Reflection） Reflection (反射)是被视为动态语言的关键，反射机制允许程序在执行期 借助于Reflection API取得任何类的内部信息，并能直接操作任意对象的内 部属性及方法。 加载完...","link":"","photos":[],"count_time":{"symbolsCount":"14k","symbolsTime":"12 mins."},"categories":[{"name":"Java","slug":"Java","count":8,"path":"api/categories/Java.json"}],"tags":[{"name":"Java","slug":"Java","count":8,"path":"api/tags/Java.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#Java%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6\"><span class=\"toc-text\">Java反射机制</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#1%E3%80%81Java%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6%E6%A6%82%E8%BF%B0\"><span class=\"toc-text\">1、Java反射机制概述</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-1-Java%E5%8F%8D%E5%B0%84%EF%BC%88Java-Reflection%EF%BC%89\"><span class=\"toc-text\">1.1 Java反射（Java Reflection）</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-2-%E8%A1%A5%E5%85%85%EF%BC%9A%E5%8A%A8%E6%80%81%E8%AF%AD%E8%A8%80-vs-%E9%9D%99%E6%80%81%E8%AF%AD%E8%A8%80\"><span class=\"toc-text\">1.2 补充：动态语言 vs 静态语言</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-3-Java%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6%E7%A0%94%E7%A9%B6%E5%8F%8A%E5%BA%94%E7%94%A8\"><span class=\"toc-text\">1.3 Java反射机制研究及应用</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#2%E3%80%81%E7%90%86%E8%A7%A3Class%E7%B1%BB%E5%B9%B6%E8%8E%B7%E5%8F%96Class%E5%AE%9E%E4%BE%8B\"><span class=\"toc-text\">2、理解Class类并获取Class实例</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-1-Class-%E7%B1%BB\"><span class=\"toc-text\">2.1 Class 类</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-2-Class%E7%B1%BB%E7%9A%84%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95\"><span class=\"toc-text\">2.2 Class类的常用方法</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-3-%E5%8F%8D%E5%B0%84%E7%9A%84%E5%BA%94%E7%94%A8%E4%B8%BE%E4%BE%8B\"><span class=\"toc-text\">2.3 反射的应用举例</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-4-%E8%8E%B7%E5%8F%96Class%E7%B1%BB%E7%9A%84%E5%AE%9E%E4%BE%8B%EF%BC%88%E5%9B%9B%E7%A7%8D%E6%96%B9%E6%B3%95%EF%BC%89\"><span class=\"toc-text\">2.4 获取Class类的实例（四种方法）</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-5-%E5%93%AA%E4%BA%9B%E7%B1%BB%E5%9E%8B%E5%8F%AF%E4%BB%A5%E6%9C%89Class%E5%AF%B9%E8%B1%A1%EF%BC%9F\"><span class=\"toc-text\">2.5 哪些类型可以有Class对象？</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#3%E3%80%81%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%E4%B8%8EClassLoader%E7%9A%84%E7%90%86%E8%A7%A3\"><span class=\"toc-text\">3、类的加载与ClassLoader的理解</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-1-%E4%BA%86%E8%A7%A3%EF%BC%9A%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B\"><span class=\"toc-text\">3.1 了解：类的加载过程</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-2-%E4%BA%86%E8%A7%A3%EF%BC%9A-%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E4%BC%9A%E5%8F%91%E7%94%9F%E7%B1%BB%E5%88%9D%E5%A7%8B%E5%8C%96%EF%BC%9F\"><span class=\"toc-text\">3.2 了解： 什么时候会发生类初始化？</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-3-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E7%9A%84%E4%BD%9C%E7%94%A8\"><span class=\"toc-text\">3.3 类加载器的作用</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-4-%E4%BA%86%E8%A7%A3%EF%BC%9A-ClassLoader\"><span class=\"toc-text\">3.4 了解： ClassLoader</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#4%E3%80%81%E5%88%9B%E5%BB%BA%E8%BF%90%E8%A1%8C%E6%97%B6%E7%B1%BB%E7%9A%84%E5%AF%B9%E8%B1%A1\"><span class=\"toc-text\">4、创建运行时类的对象</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#5%E3%80%81%E8%8E%B7%E5%8F%96%E8%BF%90%E8%A1%8C%E6%97%B6%E7%B1%BB%E7%9A%84%E5%AE%8C%E6%95%B4%E7%BB%93%E6%9E%84\"><span class=\"toc-text\">5、获取运行时类的完整结构</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#6%E3%80%81%E8%B0%83%E7%94%A8%E8%BF%90%E8%A1%8C%E6%97%B6%E7%B1%BB%E7%9A%84%E6%8C%87%E5%AE%9A%E7%BB%93%E6%9E%84\"><span class=\"toc-text\">6、调用运行时类的指定结构</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#6-1-%E8%B0%83%E7%94%A8%E6%8C%87%E5%AE%9A%E6%96%B9%E6%B3%95\"><span class=\"toc-text\">6.1 调用指定方法</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#6-2-%E8%B0%83%E7%94%A8%E6%8C%87%E5%AE%9A%E5%B1%9E%E6%80%A7\"><span class=\"toc-text\">6.2 调用指定属性</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#6-3-%E5%85%B3%E4%BA%8EsetAccessible%E6%96%B9%E6%B3%95%E7%9A%84%E4%BD%BF%E7%94%A8\"><span class=\"toc-text\">6.3 关于setAccessible方法的使用</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#7%E3%80%81%E5%8F%8D%E5%B0%84%E7%9A%84%E5%BA%94%E7%94%A8%EF%BC%9A%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86\"><span class=\"toc-text\">7、反射的应用：动态代理</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#7-1-%E4%BB%A3%E7%90%86%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%8E%9F%E7%90%86\"><span class=\"toc-text\">7.1 代理设计模式的原理:</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#7-2-Java%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E7%9B%B8%E5%85%B3API\"><span class=\"toc-text\">7.2 Java动态代理相关API</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#7-3-%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E6%AD%A5%E9%AA%A4\"><span class=\"toc-text\">7.3 动态代理步骤</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#7-4-%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E4%B8%8EAOP-Aspect-Orient-Programming\"><span class=\"toc-text\">7.4 动态代理与AOP  (Aspect Orient Programming)</span></a></li></ol></li></ol></li></ol>","author":{"name":"YimooRua","slug":"blog-author","avatar":"/static/img/avator.gif","link":"/","description":"这是一个知识分享博客🎉，有什么建议请留言。欢迎探讨技术😁。","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/static/img/svg/bilibili-line.svg","link":"https://space.bilibili.com/242073282"},"github":{"icon":"/static/img/svg/github.svg","link":"https://github.com/YimooR"},"csdn":{"icon":"/static/img/svg/csdn.svg","link":"https://blog.csdn.net/weixin_43143863?spm=1000.2115.3001.5343"},"qq":{"icon":"/static/img/svg/qq.svg","link":"https://user.qzone.qq.com/1035605573"}}}},"mapped":true,"prev_post":{"title":"Java多线程学习笔记","uid":"9b430e9648b2eee98ad3a00b595936ff","slug":"Java/多线程","date":"2023-02-09T14:33:12.000Z","updated":"2023-02-12T04:06:38.652Z","comments":true,"path":"api/articles/Java/多线程.json","keywords":null,"cover":"https://yimoorua-img.oss-cn-chengdu.aliyuncs.com/images/AgAAC6u-TVO-6GCp-41Pb5VAdprXFwlM.png","text":"Java多线程1、基本概念：程序、进程、线程 程序(program)是为完成特定任务、用某种语言编写的一组指令的集合。即指一 段静态的代码，静态对象。 进程(process)是程序的一次执行过程，或是正在运行的一个程序。是一个动态 的过程：有它自身的产生、存在和消亡的过程。——生...","link":"","photos":[],"count_time":{"symbolsCount":"18k","symbolsTime":"16 mins."},"categories":[{"name":"Java","slug":"Java","count":8,"path":"api/categories/Java.json"}],"tags":[{"name":"Java","slug":"Java","count":8,"path":"api/tags/Java.json"}],"author":{"name":"YimooRua","slug":"blog-author","avatar":"/static/img/avator.gif","link":"/","description":"这是一个知识分享博客🎉，有什么建议请留言。欢迎探讨技术😁。","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/static/img/svg/bilibili-line.svg","link":"https://space.bilibili.com/242073282"},"github":{"icon":"/static/img/svg/github.svg","link":"https://github.com/YimooR"},"csdn":{"icon":"/static/img/svg/csdn.svg","link":"https://blog.csdn.net/weixin_43143863?spm=1000.2115.3001.5343"},"qq":{"icon":"/static/img/svg/qq.svg","link":"https://user.qzone.qq.com/1035605573"}}}},"feature":true},"next_post":{"title":"搭建图床","uid":"bb71d6addb13151a6cf3720a8c5516d6","slug":"Hexo/搭建图床","date":"2023-02-02T15:11:00.000Z","updated":"2023-02-02T15:44:37.068Z","comments":true,"path":"api/articles/Hexo/搭建图床.json","keywords":null,"cover":"https://yimoorua-img.oss-cn-chengdu.aliyuncs.com/images/AgAAC6u-TVOZz2AAaN5Gl77-CtWr2-Tr.png","text":"搭建图床（Typora+PicGo+阿里云OSS服务 ）安装Typora下载Typora,目前Typora支持多平台安装，进入国内官网，国外的太慢了，目前需要收费，89rmb即可拿下，若不想花钱，这里有beta版,不过还是建议大家支持正版。（根据你的电脑选择具体版本），下载完先放...","link":"","photos":[],"count_time":{"symbolsCount":"1.3k","symbolsTime":"1 mins."},"categories":[{"name":"Hexo","slug":"Hexo","count":2,"path":"api/categories/Hexo.json"}],"tags":[{"name":"Hexo","slug":"Hexo","count":2,"path":"api/tags/Hexo.json"}],"author":{"name":"YimooRua","slug":"blog-author","avatar":"/static/img/avator.gif","link":"/","description":"这是一个知识分享博客🎉，有什么建议请留言。欢迎探讨技术😁。","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/static/img/svg/bilibili-line.svg","link":"https://space.bilibili.com/242073282"},"github":{"icon":"/static/img/svg/github.svg","link":"https://github.com/YimooR"},"csdn":{"icon":"/static/img/svg/csdn.svg","link":"https://blog.csdn.net/weixin_43143863?spm=1000.2115.3001.5343"},"qq":{"icon":"/static/img/svg/qq.svg","link":"https://user.qzone.qq.com/1035605573"}}}},"feature":true}}