[{"id":"b4385835b600a92e333b705d67a57883","title":"IDEA安装和使用教程","content":"个人学习版IDEA安装使用教程1、在 IDEA 官网下载安装包并且安装在自己电脑上。\n2、如果你电脑上的IDEA之前就使用过其他激活教程，那么我建议你先重置你的IDEA。这样能避免因为以前的激活补丁而导致永久激活失败，后期失效了又得折腾是很麻烦的。（Ps：新电脑新安装的IDEA无需重置，可以直接跳过这一步直接开始激活。）\n重置IDEA也很方便了，这里准备了脚本给大家，双击运行脚本就重置好了。\n3、重置电脑，找到【重置脚本】文件夹，右键该文件夹新建终端\n    \nmac版：\n\n输入chmod u+x reset_jetbrains_eval_mac_linux.sh命令，回车\n输入./reset_jetbrains_eval_mac_linux.sh命令，回车\n显示done提示，则完成重置。\n\nwindows版：\n\n直接双击reset_jetbrains_eval_windows.vbs文件\n\n弹出done对话框则完成。\n\n\n4、打开补丁文件夹，右键该文件夹新建终端\n  \nmac版：\n\n输入chmod u+x install.sh命令，回车\n输入./install.sh命令，回车\n提示done，完成\n\nwindows版：\n\n双击install-all-users.vbs文件\n \n \n\n\n\n\n\n\n\n\n注意\n注意：这个激活脚本是支持 JetBrains 所有产品的！也就是说脚本运行一次之后，你电脑上安装的所有 JetBrains 软件就都可以永久了，直接按照后面的步骤输入激活码就行！\n比如你电脑上现在安装了IDEA 和PyCharm这两款软件，上面的激活脚本你只需要运行一次就可以了！而且后续如果你再安装其他 JetBrains 的软件也不需要再运行激活脚本，直接按照后面的步骤输入激活码就可以了！\n\n5、然后我们打开 IDEA，如下图所示点击 Activation code 。\n \n6、然后复制下面的激活码粘贴进去。\n6G5NXCPJZB-eyJsaWNlbnNlSWQiOiI2RzVOWENQSlpCIiwibGljZW5zZWVOYW1lIjoic2lnbnVwIHNjb290ZXIiLCJhc3NpZ25lZU5hbWUiOiIiLCJhc3NpZ25lZUVtYWlsIjoiIiwibGljZW5zZVJlc3RyaWN0aW9uIjoiIiwiY2hlY2tDb25jdXJyZW50VXNlIjpmYWxzZSwicHJvZHVjdHMiOlt7ImNvZGUiOiJQU0kiLCJmYWxsYmFja0RhdGUiOiIyMDI1LTA4LTAxIiwicGFpZFVwVG8iOiIyMDI1LTA4LTAxIiwiZXh0ZW5kZWQiOnRydWV9LHsiY29kZSI6IlBEQiIsImZhbGxiYWNrRGF0ZSI6IjIwMjUtMDgtMDEiLCJwYWlkVXBUbyI6IjIwMjUtMDgtMDEiLCJleHRlbmRlZCI6dHJ1ZX0seyJjb2RlIjoiSUkiLCJmYWxsYmFja0RhdGUiOiIyMDI1LTA4LTAxIiwicGFpZFVwVG8iOiIyMDI1LTA4LTAxIiwiZXh0ZW5kZWQiOmZhbHNlfSx7ImNvZGUiOiJQUEMiLCJmYWxsYmFja0RhdGUiOiIyMDI1LTA4LTAxIiwicGFpZFVwVG8iOiIyMDI1LTA4LTAxIiwiZXh0ZW5kZWQiOnRydWV9LHsiY29kZSI6IlBHTyIsImZhbGxiYWNrRGF0ZSI6IjIwMjUtMDgtMDEiLCJwYWlkVXBUbyI6IjIwMjUtMDgtMDEiLCJleHRlbmRlZCI6dHJ1ZX0seyJjb2RlIjoiUFNXIiwiZmFsbGJhY2tEYXRlIjoiMjAyNS0wOC0wMSIsInBhaWRVcFRvIjoiMjAyNS0wOC0wMSIsImV4dGVuZGVkIjp0cnVlfSx7ImNvZGUiOiJQV1MiLCJmYWxsYmFja0RhdGUiOiIyMDI1LTA4LTAxIiwicGFpZFVwVG8iOiIyMDI1LTA4LTAxIiwiZXh0ZW5kZWQiOnRydWV9LHsiY29kZSI6IlBQUyIsImZhbGxiYWNrRGF0ZSI6IjIwMjUtMDgtMDEiLCJwYWlkVXBUbyI6IjIwMjUtMDgtMDEiLCJleHRlbmRlZCI6dHJ1ZX0seyJjb2RlIjoiUFJCIiwiZmFsbGJhY2tEYXRlIjoiMjAyNS0wOC0wMSIsInBhaWRVcFRvIjoiMjAyNS0wOC0wMSIsImV4dGVuZGVkIjp0cnVlfSx7ImNvZGUiOiJQQ1dNUCIsImZhbGxiYWNrRGF0ZSI6IjIwMjUtMDgtMDEiLCJwYWlkVXBUbyI6IjIwMjUtMDgtMDEiLCJleHRlbmRlZCI6dHJ1ZX1dLCJtZXRhZGF0YSI6IjAxMjAyMjA5MDJQU0FOMDAwMDA1IiwiaGFzaCI6IlRSSUFMOi0xMDc4MzkwNTY4IiwiZ3JhY2VQZXJpb2REYXlzIjo3LCJhdXRvUHJvbG9uZ2F0ZWQiOmZhbHNlLCJpc0F1dG9Qcm9sb25nYXRlZCI6ZmFsc2V9-SnRVlQQR1/9nxZ2AXsQ0seYwU5OjaiUMXrnQIIdNRvykzqQ0Q+vjXlmO7iAUwhwlsyfoMrLuvmLYwoD7fV8Mpz9Gs2gsTR8DfSHuAdvZlFENlIuFoIqyO8BneM9paD0yLxiqxy/WWuOqW6c1v9ubbfdT6z9UnzSUjPKlsjXfq9J2gcDALrv9E0RPTOZqKfnsg7PF0wNQ0/d00dy1k3zI+zJyTRpDxkCaGgijlY/LZ/wqd/kRfcbQuRzdJ/JXa3nj26rACqykKXaBH5thuvkTyySOpZwZMJVJyW7B7ro/hkFCljZug3K+bTw5VwySzJtDcQ9tDYuu0zSAeXrcv2qrOg==-MIIETDCCAjSgAwIBAgIBDTANBgkqhkiG9w0BAQsFADAYMRYwFAYDVQQDDA1KZXRQcm9maWxlIENBMB4XDTIwMTAxOTA5MDU1M1oXDTIyMTAyMTA5MDU1M1owHzEdMBsGA1UEAwwUcHJvZDJ5LWZyb20tMjAyMDEwMTkwggEiMA0GCSqGSIb3DQEBAQUAA4IBDwAwggEKAoIBAQCUlaUFc1wf+CfY9wzFWEL2euKQ5nswqb57V8QZG7d7RoR6rwYUIXseTOAFq210oMEe++LCjzKDuqwDfsyhgDNTgZBPAaC4vUU2oy+XR+Fq8nBixWIsH668HeOnRK6RRhsr0rJzRB95aZ3EAPzBuQ2qPaNGm17pAX0Rd6MPRgjp75IWwI9eA6aMEdPQEVN7uyOtM5zSsjoj79Lbu1fjShOnQZuJcsV8tqnayeFkNzv2LTOlofU/Tbx502Ro073gGjoeRzNvrynAP03pL486P3KCAyiNPhDs2z8/COMrxRlZW5mfzo0xsK0dQGNH3UoG/9RVwHG4eS8LFpMTR9oetHZBAgMBAAGjgZkwgZYwCQYDVR0TBAIwADAdBgNVHQ4EFgQUJNoRIpb1hUHAk0foMSNM9MCEAv8wSAYDVR0jBEEwP4AUo562SGdCEjZBvW3gubSgUouX8bOhHKQaMBgxFjAUBgNVBAMMDUpldFByb2ZpbGUgQ0GCCQDSbLGDsoN54TATBgNVHSUEDDAKBggrBgEFBQcDATALBgNVHQ8EBAMCBaAwDQYJKoZIhvcNAQELBQADggIBABqRoNGxAQct9dQUFK8xqhiZaYPd30TlmCmSAaGJ0eBpvkVeqA2jGYhAQRqFiAlFC63JKvWvRZO1iRuWCEfUMkdqQ9VQPXziE/BlsOIgrL6RlJfuFcEZ8TK3syIfIGQZNCxYhLLUuet2HE6LJYPQ5c0jH4kDooRpcVZ4rBxNwddpctUO2te9UU5/FjhioZQsPvd92qOTsV+8Cyl2fvNhNKD1Uu9ff5AkVIQn4JU23ozdB/R5oUlebwaTE6WZNBs+TA/qPj+5/we9NH71WRB0hqUoLI2AKKyiPw++FtN4Su1vsdDlrAzDj9ILjpjJKA1ImuVcG329/WTYIKysZ1CWK3zATg9BeCUPAV1pQy8ToXOq+RSYen6winZ2OO93eyHv2Iw5kbn1dqfBw1BuTE29V2FJKicJSu8iEOpfoafwJISXmz1wnnWL3V/0NxTulfWsXugOoLfv0ZIBP1xH9kmf22jjQ2JiHhQZP7ZDsreRrOeIQ/c4yR8IQvMLfC0WKQqrHu5ZzXTH4NO3CwGWSlTY74kE91zXB5mwWAx1jig+UXYc2w4RkVhy0//lOmVya/PEepuuTTI4+UJwC7qbVlh5zfhj8oTNUXgN0AOc+Q0/WFPl1aw5VV/VrO8FCoB15lFVlpKaQ1Yh+DVU8ke+rt9Th0BCHXe0uZOEmH0nOnH/0onD\n\n7、如果粘贴激活码之后是下图这个样子，说明激活码失效了！大家可以在这个网址获取新的激活码：http://idea.javatiku.cn/\n \n8、激活码粘贴之后如下图所示，就说明有效，然后我们点击 Activate 激活。\n\n9、最后就激活成功了，点击 Continue 关闭窗口就好了。\n（不得将上述内容用于商业或者非法用途，否则，一切后果请用户自负。本站信息来自网络，版权争议与本站无关，您必须在下载后的24个小时之内，从您的电脑中彻底删除上述内容。访问和下载本站内容，说明您已同意上述条款。）\n","slug":"Java/idea安装","date":"2023-02-18T14:33:12.000Z","categories_index":"Java","tags_index":"Java","author_index":"YimooRua"},{"id":"99f674fe5fbaafaaba3d22a30094ce34","title":"Java枚举类与注解学习笔记","content":"枚举类与注解1、枚举类的使用\n类的对象只有有限个，确定的。举例如下：\n星期：Monday(星期一)、……、Sunday(星期天) \n性别：Man(男)、Woman(女) \n季节：Spring(春节)……Winter(冬天)  \n支付方式：Cash（现金）、WeChatPay（微信）、Alipay(支付宝)、BankCard(银行卡)、CreditCard(信用卡)\n就职状态：Busy、Free、Vocation、Dimission\n订单状态：Nonpayment（未付款）、Paid（已付款）、Delivered（已发货）、Return（退货）、Checked（已确认）Fulfilled（已配货）、\n线程状态：创建、就绪、运行、阻塞、死亡\n\n\n当需要定义一组常量时，强烈建议使用枚举类\n\n1.1 如何自定义枚举类\n枚举类的实现\nJDK1.5之前需要自定义枚举类\nJDK 1.5 新增的 enum 关键字用于定义枚举类\n\n\n若枚举只有一个对象, 则可以作为一种单例模式的实现方式。\n枚举类的属性\n枚举类对象的属性不应允许被改动, 所以应该使用 private final 修饰\n\n枚举类的使用 private final 修饰的属性应该在构造器中为其赋值\n\n若枚举类显式的定义了带参数的构造器, 则在列出枚举值时也必须对应的传入参数\n\n\n\n\n自定义枚举类：\n\n私有化类的构造器，保证不能在类的外部创建其对象\n在类的内部创建枚举类的实例。声明为：public static final \n对象如果有实例变量，应该声明为private final，并在构造器中初始化\n\n例：\nclass Season&#123;\nprivate final String SEASONNAME;//季节的名称\nprivate final String SEASONDESC;//季节的描述\nprivate Season(String seasonName,String seasonDesc)&#123;\nthis.SEASONNAME = seasonName;\nthis.SEASONDESC = seasonDesc; &#125;\npublic static final Season SPRING = new Season(\"春天\", \"春暖花开\");\npublic static final Season SUMMER = new Season(\"夏天\", \"夏日炎炎\");\npublic static final Season AUTUMN = new Season(\"秋天\", \"秋高气爽\");\npublic static final Season WINTER = new Season(\"冬天\", \"白雪皑皑\");\n&#125;\n\n1.2 如何使用关键字enum定义枚举类\n使用说明\n\n使用 enum 定义的枚举类默认继承了 java.lang.Enum类，因此不能再继承其他类\n枚举类的构造器只能使用 private 权限修饰符\n枚举类的所有实例必须在枚举类中显式列出(分隔 ; 结尾)。列出的实例系统会自动添加 public static final 修饰\n必须在枚举类的第一行声明枚举类对象\n\n\nJDK 1.5 中可以在 switch 表达式中使用Enum定义的枚举类的对象作为表达式, case 子句可以直接使用枚举值的名字, 无需添加枚举类作为限定。\n\n\n例：\npublic enum SeasonEnum &#123;\nSPRING(\"春天\",\"春风又绿江南岸\"),\nSUMMER(\"夏天\",\"映日荷花别样红\"),\nAUTUMN(\"秋天\",\"秋水共长天一色\"),\nWINTER(\"冬天\",\"窗含西岭千秋雪\");\nprivate final String seasonName;\nprivate final String seasonDesc;\nprivate SeasonEnum(String seasonName, String seasonDesc) &#123;\nthis.seasonName = seasonName;\nthis.seasonDesc = seasonDesc; &#125;\npublic String getSeasonName() &#123;\nreturn seasonName; &#125;\npublic String getSeasonDesc() &#123;\nreturn seasonDesc; \n &#125; \n&#125;\n\n1.3 Enum类的主要方法主要方法如下：\n  \nEnum类的主要方法：\n\nvalues()方法：返回枚举类型的对象数组。该方法可以很方便地遍历所有的枚举值。\nvalueOf(String str)：可以把一个字符串转为对应的枚举类对象。要求字符串必须是枚举类对象的“名字”。如不是，会有运行时异常：IllegalArgumentException。 \n toString()：返回当前枚举类对象常量的名称\n\n1.4 实现接口的枚举类\n和普通 Java 类一样，枚举类可以实现一个或多个接口\n若每个枚举值在调用实现的接口方法呈现相同的行为方式，则只要统一实现该方法即可。\n若需要每个枚举值在调用实现的接口方法呈现出不同的行为方式, 则可以让每个枚举值分别来实现该方法2、注解的使用\n\n2.1 注解(Annotation)概述\n从 JDK 5.0 开始, Java 增加了对元数据(MetaData) 的支持, 也就是Annotation(注解) \nAnnotation 其实就是代码里的特殊标记, 这些标记可以在编译, 类加载, 运行时被读取, 并执行相应的处理。通过使用 Annotation, 程序员可以在不改变原有逻辑的情况下, 在源文件中嵌入一些补充信息。代码分析工具、开发工具和部署工具可以通过这些补充信息进行验证或者进行部署。\nAnnotation 可以像修饰符一样被使用, 可用于修饰包,类, 构造器, 方 法, 成员变量, 参数, 局部变量的声明, 这些信息被保存在 Annotation 的 “name=value” 对中。\n在JavaSE中，注解的使用目的比较简单，例如标记过时的功能，忽略警告等。在JavaEE/Android中注解占据了更重要的角色，例如用来配置应用程序的任何切面，代替JavaEE旧版中所遗留的繁冗代码和XML配置等。 \n未来的开发模式都是基于注解的，JPA是基于注解的，Spring2.5以上都是基于注解的，Hibernate3.x以后也是基于注解的，现在的Struts2有一部分也是基于注解的了，注解是一种趋势，一定程度上可以说：框架 = 注解 + 反射 + 设计模式\n\n2.2 常见的Annotation示例\n使用 Annotation 时要在其前面增加 @ 符号, 并把该 Annotation 当成一个修饰符使用。用于修饰它支持的程序元素\n\n示例一：生成文档相关的注解\n\n@author 标明开发该类模块的作者，多个作者之间使用,分割\n@version 标明该类模块的版本\n@see 参考转向，也就是相关主题\n@since 从哪个版本开始增加的\n@param 对方法中某参数的说明，如果没有参数就不能写\n@return 对方法返回值的说明，如果方法的返回值类型是void就不能写\n@exception 对方法可能抛出的异常进行说明 ，如果方法没有用throws显式抛出的异常就不能写\n其中@param @return 和 @exception 这三个标记都是只用于方法的。@param的格式要求：@param 形参名 形参类型 形参说明@return 的格式要求：@return 返回值类型 返回值说明@exception的格式要求：@exception 异常类型 异常说明@param和@exception可以并列多个package com.annotation.javadoc;\n/**\n@author yimoorua\n@version 1.0\n@see Math.java\n */\n public class JavadocTest &#123;\n /**\n程序的主方法，程序的入口\n@param args String[] 命令行参数\n */\n public static void main(String[] args) &#123;\n &#125;\n /**\n求圆面积的方法\n@param radius double 半径值\n@return double 圆的面积\n */\n public static double getArea(double radius)&#123;\n return Math.PI * radius * radius; \n   &#125; \n &#125;\n\n\n示例二：在编译时进行格式检查(JDK内置的三个基本注解)\n\n@Override: 限定重写父类方法, 该注解只能用于方法\n\n@Deprecated: 用于表示所修饰的元素(类, 方法等)已过时。通常是因为所修饰的结构危险或存在更好的选择\n\n@SuppressWarnings: 抑制编译器警告\npackage com.annotation.javadoc;\n  public class AnnotationTest&#123;\n  public static void main(String[] args) &#123;\n  @SuppressWarnings(\"unused\")\n  int a = 10;\n  &#125;\n  @Deprecated\n  public void print()&#123;\n     System.**out**.println(\"过时的方法\");\n  &#125;\n  @Override\n  public String toString() &#123;\n     return \"重写的toString方法()\"; \n    &#125; \n  &#125;\n\n\n示例三：跟踪代码依赖性，实现替代配置文件功能\n\nServlet3.0提供了注解(annotation),使得不再需要在web.xml文件中进行Servlet的部署。@WebServlet(\"/login\")\npublic class LoginServlet extends HttpServlet &#123;\n  private static final long serialVersionUID = 1L;\n  protected void doGet(HttpServletRequest request, HttpServletResponse response) throws\n  ServletException, IOException &#123; &#125;\n  protected void doPost(HttpServletRequest request, HttpServletResponse response) throws\n  ServletException, IOException &#123;\n  doGet(request, response);\n     &#125; \n  &#125; \n&lt;servlet> \n    &lt;servlet-name>LoginServlet&lt;/servlet-name> \n    &lt;servlet-class>com.servlet.LoginServlet&lt;/servlet-class>\n&lt;/servlet> \n&lt;servlet-mapping> \n  &lt;servlet-name>LoginServlet&lt;/servlet-name> \n  &lt;url-pattern>/login&lt;/url-pattern>\n&lt;/servlet-mapping>\nspring框架中关于“事务”的管理\n\n@Transactional(propagation=Propagation.REQUIRES_NEW,isolation=Isolation.READ_COMMITTED,readOnly=false,timeout=3)\npublic void buyBook(String username, String isbn) &#123;\n  //1.查询书的单价\n  int price = bookShopDao.findBookPriceByIsbn(isbn);\n  //2. 更新库存\n  bookShopDao.updateBookStock(isbn);\n  //3. 更新用户的余额\n  bookShopDao.updateUserAccount(username, price); \n&#125;\n\n&lt;!-- 配置事务属性 --> \n&lt;tx:advice transaction-manager=\"dataSourceTransactionManager\" id=\"txAdvice\">\n   &lt;tx:attributes>\n     &lt;!-- 配置每个方法使用的事务属性 --> \n     &lt;tx:method name=\"buyBook\" propagation=\"REQUIRES_NEW\" isolation=\"READ_COMMITTED\" read-only=\"false\" timeout=\"3\" />\n   &lt;/tx:attributes>\n&lt;/tx:advice>\n\n2.3 自定义Annotation\n定义新的 Annotation 类型使用 @interface关键字\n自定义注解自动继承了java.lang.annotation.Annotation接口\nAnnotation 的成员变量在 Annotation 定义中以无参数方法的形式来声明。其方法名和返回值定义了该成员的名字和类型。我们称为配置参数。类型只能是八种基本数据类型、String类型、Class类型、enum类型、Annotation类型、以上所有类型的数组。 \n可以在定义 Annotation 的成员变量时为其指定初始值, 指定成员变量的初始值可使用 default 关键字\n如果只有一个参数成员，建议使用参数名为value\n如果定义的注解含有配置参数，那么使用时必须指定参数值，除非它有默认值。格式是“参数名 = 参数值”，如果只有一个参数成员，且名称为value，可以省略“value=” \n没有成员定义的 Annotation 称为标记; 包含成员变量的 Annotation 称为元数据 Annotation\n\n注意：自定义注解必须配上注解的信息处理流程才有意义。\n例：\n@MyAnnotation(value=\"yimoorua\")\npublic class MyAnnotationTest &#123;\n    public static void main(String[] args) &#123;\n        Class clazz = MyAnnotationTest.class;\n        Annotation a = clazz.getAnnotation(MyAnnotation.class);\n        MyAnnotation m = (MyAnnotation) a;\n        String info = m.value();\n        System.out.println(info);\n    &#125; \n&#125;\n@Retention(RetentionPolicy.RUNTIME)\n@Target(ElementType.TYPE)\n@interface MyAnnotation&#123;\nString value() default \"yimoorua\"; \n&#125;\n\n2.4 JDK中的元注解\nJDK 的元 Annotation 用于修饰其他 Annotation 定义\n\nJDK5.0提供了4个标准的meta-annotation类型，分别是：\n\nRetention\nTarget\nDocumented\nInherited\n\n\n\n元数据的理解：String name = “yimoorua”;\n元注解：\n\n@Retention: 只能用于修饰一个 Annotation 定义, 用于指定该 Annotation 的生命周期, @Rentention 包含一个 RetentionPolicy 类型的成员变量, 使用@Rentention 时必须为该 value 成员变量指定值:\nRetentionPolicy.SOURCE: 在源文件中有效（即源文件保留）,编译器直接丢弃这种策略的注释\nRetentionPolicy.CLASS: 在class文件中有效（即class保留）,当运行 Java 程序时, JVM 不会保留注解。 这是默认值\nRetentionPolicy.RUNTIME: 在运行时有效（即运行时保留），当运行Java程序时, JVM会保留注释。程序可以通过反射获取该注释。\n\n\n\n\npublic enum RetentionPolicy&#123;\nSOURCE,\nCLASS,\nRUNTIME\n&#125;\n@Retention(RetentionPolicy.SOURCE)\n@interface MyAnnotation1&#123; &#125;\n@Retention(RetentionPolicy.RUNTIME) @interface MyAnnotation2&#123; &#125;\n\n@Target: 用于修饰 Annotation 定义, 用于指定被修饰的 Annotation 能用于修饰哪些程序元素。 @Target 也包含一个名为 value 的成员变量。\n\n\n\n取值(ElemetType)\n\n取值(ElementType)\n\n\n\n\nCONSTRUCTOR\n用于描述构造器\nPACKAGE\n用于描述包\n\n\nFIELD\n用于描述域\nPARAMETER\n用于描述参数\n\n\nLOCAL VARIABLE\n用于描述局部变量\nTYPE\n用于描述类、接口(包括注解类型）或enum声明\n\n\nMETHOD\n用于描述方法\n\n\n\n\n\n@Documented: 用于指定被该元 Annotation 修饰的 Annotation 类将被javadoc 工具提取成文档。默认情况下，javadoc是不包括注解的。 \n\n定义为Documented的注解必须设置Retention值为RUNTIME。 \n\n\n@Inherited: 被它修饰的 Annotation 将具有继承性。如果某个类使用了被@Inherited 修饰的 Annotation, 则其子类将自动具有该注解。\n\n比如：如果把标有@Inherited注解的自定义的注解标注在类级别上，子类则可以继承父类类级别的注解\n实际应用中，使用较少\n\n\n\n2.5 利用反射获取注解信息（在反射部分涉及）\nJDK 5.0 在 java.lang.reflect 包下新增了AnnotatedElement 接口, 该接口代表程序中可以接受注解的程序元素\n\n当一个Annotation类型被定义为运行时Annotation后, 该注解才是运行时可见, 当 class 文件被载入时保存在 class 文件中的 Annotation 才会被虚拟机读取\n\n程序可以调用 AnnotatedElement对象的如下方法来访问 Annotation 信息\n\n\n  \nJava 8对注解处理提供了两点改进：可重复的注解及可用于类型的注解。此外，反射也得到了加强，在Java8中能够得到方法参数的名称。这会简化标注在方法参数上的注解。\n可重复注解示例：\n \n \n  \n2.6 JDK 8中注解的新特性类型注解：\n\nJDK1.8之后，关于元注解@Target的参数类型ElementType枚举值多了两个：TYPE_PARAMETER,TYPE_USE。\n\n在Java 8之前，注解只能是在声明的地方所使用，Java8开始，注解可以应用在任何地方。 \n\nElementType.TYPE_PARAMETER 表示该注解能写在类型变量的声明语句中（如：泛型声明）。 \nElementType.TYPE_USE 表示该注解能写在使用类型的任何语句中。\n\n\n\npublic class TestTypeDefine&lt;@TypeDefine() U> &#123;\nprivate U u;\npublic &lt;@TypeDefine() T> void test(T t)&#123;\n&#125; &#125;\n@Target(&#123;ElementType.TYPE_PARAMETER&#125;)\n@interface TypeDefine&#123; &#125;\n\n@MyAnnotation\npublic class AnnotationTest&lt;U> &#123;\n@MyAnnotation\nprivate String name;\npublic static void main(String[] args) &#123;\nAnnotationTest&lt;@MyAnnotation String> t = null;\nint a = (@MyAnnotation int) 2L;\n@MyAnnotation\nint b = 10;\n&#125;\npublic static &lt;@MyAnnotation T> void method(T t) &#123; &#125;\npublic static void test(@MyAnnotation String arg) throws @MyAnnotation Exception &#123; &#125; &#125;\n@Target(ElementType.TYPE_USE)\n@interface MyAnnotation &#123; &#125;\n\n","slug":"Java/枚举类与注解","date":"2023-02-11T16:33:12.000Z","categories_index":"Java","tags_index":"Java","author_index":"YimooRua"},{"id":"9b430e9648b2eee98ad3a00b595936ff","title":"Java多线程学习笔记","content":"Java多线程1、基本概念：程序、进程、线程\n程序(program)是为完成特定任务、用某种语言编写的一组指令的集合。即指一 段静态的代码，静态对象。\n进程(process)是程序的一次执行过程，或是正在运行的一个程序。是一个动态 的过程：有它自身的产生、存在和消亡的过程。——生命周期\n如：运行中的QQ，运行中的MP3播放器\n程序是静态的，进程是动态的\n进程作为资源分配的单位， 系统在运行时会为每个进程分配不同的内存区域\n\n\n线程(thread)，进程可进一步细化为线程，是一个程序内部的一条执行路径。\n若一个进程同一时间并行执行多个线程，就是支持多线程的\n线程作为调度和执行的单位，每个线程拥有独立的运行栈和程序计数器(pc)，线程切换的开 销小\n一个进程中的多个线程共享相同的内存单元/内存地址空间&gt;它们从同一堆中分配对象，可以 访问相同的变量和对象。这就使得线程间通信更简便、高效。但多个线程操作共享的系统资 源可能就会带来安全的隐患。\n\n\n\n \n\n \n\n单核CPU和多核CPU的理解\n\n单核CPU，其实是一种假的多线程，因为在一个时间单元内， 也只能执行一个线程的任务。例如：虽然有多车道，但是收费站只有一个工作人员在收费，只有收了费 才能通过，那么CPU就好比收费人员。如果有某个人不想交钱，那么收费人员可以 把他“挂起”(晾着他， 等他想通了， 准备好了钱， 再去收费) 。但是因为CPU时 间单元特别短，因此感觉不出来。\n如果是多核的话， 才能更好的发挥多线程的效率。(现在的服务器都是多核的)\n一个Java应用程序java.exe，其实至少有三个线程： main()主线程， gc()垃圾回收线程，异常处理线程。当然如果发生异常，会影响主线程。\n\n\n并行与并发\n\n并行： 多个CPU同时执行多个任务。比如：多个人同时做不同的事。\n并发：一个CPU(采用时间片)同时执行多个任务。比如：秒杀、多个人做同一件事。\n\n\n\n使用多线程的优点背景：以单核CPU为例， 只使用单个线程先后完成多个任务(调用多个方 法)，肯定比用多个线程来完成用的时间更短，为何仍需多线程呢？\n多线程程序的优点：\n\n提高应用程序的响应。对图形化界面更有意义，可增强用户体验。\n提高计算机系统CPU的利用率\n改善程序结构。将既长又复杂的进程分为多个线程，独立运行，利于理解和修改\n\n何时需要多线程\n\n程序需要同时执行两个或多个任务。\n\n程序需要实现一些需要等待的任务时，如用户输入、文件读写操作、网络操作、搜索等。\n\n需要一些后台运行的程序时。\n\n\n2、线程的创建和使用注意：以下程序不是多线程\npublic class Sample &#123;\n    public void method1(String str) &#123;\n        System.out.println(str);\n    &#125;\n\n    public void method2(String str) &#123;\n          method1(str);\n   &#125;\n\npublic static void main(String[] args) &#123;\n    Sample s = new Sample();\n     s.method2(\"hello!\");\n   &#125;\n&#125;\n2.1 线程的创建和启动\nJava语言的JVM允许程序运行多个线程，它通过java.lang.Thread类来体现。\n\nThread类的特性\n\n每个线程都是通过某个特定Thread对象的run()方法来完成操作的，经常把run()方法的主体称为线程体\n通过该Thread对象的start()方法来启动这个线程，而非直接调用run()\n\n\n\n2.2 Thread类构造器\n\nThread()：创建新的Thread对象\n\nThread(String threadname)：创建线程并指定线程实例名\n\nThread(Runnable target)：指定创建线程的目标对象，它实现了Runnable接 口中的run方法\n\nThread(Runnable target, String name)：创建新的Thread对象\n\n\n2.3 API中创建线程的两种方式\nJDK1.5之前创建新执行线程有两种方法：\n\n继承Thread类的方式\n\n 定义子类继承Thread类。\n 子类中重写Thread类中的run方法。\n 创建Thread子类对象，即创建了线程对象。\n 调用线程对象start方法：启动线程，调用run方法。\n\nmt子线程的创建和启动过程\n  \n\n \n \n注意点\n\n\n如果自己手动调用run()方法，那么就只是普通方法，没有启动多线程模式。\nrun()方法由JVM调用，什么时候调用，执行的过程控制都有操作系统的CPU 调度决定。\n想要启动多线程，必须调用start方法。\n一个线程对象只能调用一次start()方法启动，如果重复调用了，则将抛出以上 的异常“IllegalThreadStateException”。\n\n\n实现Runnable接口的方式\n\n定义子类，实现Runnable接口。\n子类中重写Runnable接口中的run方法。\n通过Thread类含参构造器创建线程对象。\n将Runnable接口的子类对象作为实际参数传递给Thread类的构造器中。\n调用Thread类的start方法：开启线程，调用Runnable子类接口的run方法。\n\n\n\n2.4 继承方式和实现方式的联系与区别public class Thread extends Object implements Runnable\n\n区别\n\n继承Thread：线程代码存放Thread子类run方法中。\n\n实现Runnable：线程代码存在接口的子类的run方法。\n\n实现方式的好处\n\n避免了单继承的局限性\n\n多个线程可以共享同一个接口实现类的对象，非常适合多个相同线程来处理同一份资源。\n\n\n\n\n2.5 Thread类的有关方法(1)\nvoid start():  启动线程，并执行对象的run()方法\nrun():  线程在被调度时执行的操作\nString getName():  返回线程的名称\nvoid setName(String name): 设置该线程名称\nstatic Thread currentThread(): 返回当前线程。在Thread子类中就 是this，通常用于主线程和Runnable实现类\n\n2.6 Thread类的有关方法(2)\nstatic void yield() ：线程让步\n\n暂停当前正在执行的线程，把执行机会让给优先级相同或更高的线程\n\n若队列中没有同优先级的线程，忽略此方法\n\njoin() ：当某个程序执行流中调用其他线程的 join() 方法时，调用线程将 被阻塞，直到 join() 方法加入的 join 线程执行完为止\n\n低优先级的线程也可以获得执行\n\n\nstatic void sleep (long millis)：(指定时间:毫秒)\n\n令当前活动线程在指定时间段内放弃对CPU控制,使其他线程有机会被执行,时间到后 重排队。\n\n抛出InterruptedException异常\n\n\n\nstop() :  强制线程生命期结束，不推荐使用\n\nboolean isAlive()：返回boolean，判断线程是否还活着\n\n\n2.7 线程的调度\n调度策略\n\n时间片             \n\n抢占式：高优先级的线程抢占CPU\n\n\n\nJava的调度方法\n\n同优先级线程组成先进先出队列(先到先服务)，使用时间片策略 \n对高优先级，使用优先调度的抢占式策略\n\n\n\n2.8 线程的优先级\n线程的优先级等级\nMAX_PRIORITY：10\nMIN   PRIORITY：1\nNORM_PRIORITY：5\n\n\n涉及的方法\ngetPriority() ：返回线程优先值\nsetPriority(int newPriority) ：改变线程的优先级\n\n\n说明\n线程创建时继承父线程的优先级\n低优先级只是获得调度的概率低，并非一定是在高优先级线程之后才被调用\n\n\n\n2.9  补充：线程的分类Java中的线程分为两类：一种是守护线程，一种是用户线程。\n\n它们在几乎每个方面都是相同的，唯一的区别是判断JVM何时离开。\n守护线程是用来服务用户线程的，通过在start()方法前调用thread.setDaemon(true)可以把一个用户线程变成一个守护线程。\nJava垃圾回收就是一个典型的守护线程。\n若JVM中都是守护线程，当前JVM将退出。\n形象理解： 兔死狗烹，鸟尽弓藏\n\n3、线程的生命周期JDK中用Thread.State类定义了线程的几种状态要想实现多线程，必须在主线程中创建新的线程对象。Java语言使用Thread类 及其子类的对象来表示线程，在它的一个完整的生命周期中通常要经历如下的五种状态：\n\n新建：当一个Thread类或其子类的对象被声明并创建时，新生的线程对象处于新建状态\n就绪：处于新建状态的线程被start()后，将进入线程队列等待CPU时间片，此时它已 具备了运行的条件，只是没分配到CPU资源\n运行： 当就绪的线程被调度并获得CPU资源时,便进入运行状态，  run()方法定义了线程的操作和功能\n阻塞： 在某种特殊情况下，被人为挂起或执行输入输出操作时， 让出 CPU 并临时中 止自己的执行，进入阻塞状态\n死亡： 线程完成了它的全部工作或线程被提前强制性地中止或出现异常导致结束\n\n \n \n4、线程的同步问题的提出\n\n多个线程执行的不确定性引起执行结果的不稳定\n\n多个线程对账本的共享，会造成操作的不完整性，会破坏数据。\n\n\n例 题模拟火车站售票程序，开启三个窗口售票。\nclass Ticket implements Runnable &#123;\n    private int tick = 100;\n    public void run() &#123;\n         while (true) &#123;\n             if (tick > 0) &#123;\n                System.out.println(Thread.currentThread ().getName() + \"售出车票， tick号为： \" + tick--);\n             &#125; else\n                 break;\n               &#125;\n                   &#125;\n               &#125; \nclass TicketDemo &#123;\n     public static void main(String[] args) &#123;\n          Ticket t = new Ticket();\n          Thread t1 = new Thread(t);\n          Thread t2 = new Thread(t);\n          Thread t3 = new Thread(t);\n          t1.setName(\"t1窗口\");\n          t2.setName(\"t2窗口\");\n          t3.setName(\"t3窗口\");\n          t1.start();\n          t2.start();\n          t3.start();\n      &#125;\n&#125;\n\n \n \n   private int tick = 100;\n   public void run()&#123;\n   while(true)&#123;\n   if(tick>0)&#123;\ntry&#123;\n   Thread.sleep(10);\n  &#125;catch(InterruptedException e)&#123; e.printStackTrace();&#125;\n      System.out.println(Thread.currentThread().getName()+“售出车票，tick号为：    \"+tick--);\n      &#125;  \n    &#125; \n  &#125;\n\n多线程出现了安全问题\n问题的原因：当多条语句在操作同一个线程共享数据时，一个线程对多条语句只执行了一部分，还没有 执行完，另一个线程参与进来执行。导致共享数据的错误。\n&lt;b style=”color:red”解决办法：对多条操作共享数据的语句，只能让一个线程都执行完，在执行过程中，其他线程不可以 参与执行。\n\n4.1 Synchronized的使用方法Java对于多线程的安全问题提供了专业的解决方式：同步机制\n\n  同步代码块： synchronized (对象){  // 需要被同步的代码;}\n\nsynchronized还可以放在方法声明中，表示整个方法为同步方法。\n 例如：\n \n    public synchronized void show (String name){\n        …\n }\n\n \n4.2 同步机制中的锁\n同步锁机制：在《Thinking in Java》中，是这么说的：对于并发工作，你需要某种方式来防 止两个任务访问相同的资源 (其实就是共享资源竞争) 。  防止这种冲突的方法 就是当资源被一个任务使用时，在其上加锁。第一个访问某项资源的任务必须 锁定这项资源，使其他任务在其被解锁之前，就无法访问它了，而在其被解锁 之时，另一个任务就可以锁定并使用它了。\n\nsynchronized的锁是什么？\n\n任意对象都可以作为同步锁。所有对象都自动含有单一的锁 (监视器) 。\n 同步方法的锁：静态方法 (类名.class) 、非静态方法 (this)\n 同步代码块：自己指定，很多时候也是指定为this或类名.class注意：\n\n\n必须确保使用同一个资源的多个线程共用一把锁，这个非常重要，否则就无法保证共享资源的安全\n\n一个线程类中的所有静态方法共用同一把锁 (类名.class) ，所有非静态方法共用同一把锁 (this) ，同步代码块 (指定需谨慎)\n\n\n4.3  同步的范围1、如何找问题，即代码是否存在线程安全？(非常重要)(1) 明确哪些代码是多线程运行的代码(2) 明确多个线程是否有共享数据(3) 明确多线程运行代码中是否有多条语句操作共享数据\n2、如何解决呢？(非常重要)对多条操作共享数据的语句，只能让一个线程都执行完，在执行过程中，其 他线程不可以参与执行。即所有操作共享数据的这些语句都要放在同步范围中\n3、切记：\n\n范围太小：没锁住所有有安全问题的代码\n范围太大：没发挥多线程的功能。\n\n4.4  释放锁的操作\n当前线程的同步方法、同步代码块执行结束。\n当前线程在同步代码块、同步方法中遇到break、return终止了该代码块、该方法的继续执行。\n当前线程在同步代码块、同步方法中出现了未处理的Error或Exception，导 致异常结束。\n当前线程在同步代码块、同步方法中执行了线程对象的wait()方法，当前线 程暂停，并释放锁。\n\n4.5 不会释放锁的操作\n线程执行同步代码块或同步方法时，程序调用Thread.sleep()、Thread.yield()方法暂停当前线程的执行\n\n线程执行同步代码块时，其他线程调用了该线程的suspend()方法将该线程 挂起，该线程不会释放锁(同步监视器)。\n\n应尽量避免使用suspend()和resume()来控制线程\n\n\n\n4.6 单例设计模式之懒汉式(线程安全)class Singleton &#123;\n      private static Singleton instance = null;\n      private Singleton()&#123;&#125;\n      public static Singleton getInstance()&#123; \n            if(instance==null)&#123;\n               synchronized(Singleton.class)&#123;\n            if(instance == null)&#123;\n               instance=new Singleton();\n             &#125;               \n            &#125;               \n           &#125;\n              return instance;\n             &#125;             \n           &#125;\npublic class SingletonTest&#123;\n       public static void main(String[] args)&#123;\n           Singleton s1=Singleton.getInstance();\n           Singleton s2=Singleton.getInstance();\n           System.out.println(s1==s2);\n           &#125;      \n       &#125;\n\n4.7 线程的死锁问题\n死锁\n不同的线程分别占用对方需要的同步资源不放弃，都在等待对方放弃自己需要的同步资源，就形成了线程的死锁\n出现死锁后，不会出现异常，不会出现提示，只是所有的线程都处于阻塞状态，无法继续\n\n\n解决方法\n专门的算法、原则\n尽量减少同步资源的定义\n尽量避免嵌套同步\n\n\n\npublic class DeadLockTest &#123;\n      public static void main(String[] args) &#123;\n            final StringBuffer s1 = new StringBuffer();\n            final StringBuffer s2 = new StringBuffer();\n              new Thread() &#123;\n                   public void run() &#123;\n                         synchronized (s1) &#123;\n                            s2.append(\"A\");\n                         synchronized (s2) &#123;\n                            s2.append(\"B\");      \n                            System.out.print(s1);  \n                            System.out.print(s2);\n                       &#125;\n                    &#125;\n                &#125;\n             &#125;.start();\n\nnew Thread() &#123;\n        public void run() &#123;\n             synchronized (s2) &#123;\n                  s2.append(\"C\");\n             synchronized (s1) &#123;\n                  s1.append(\"D\");\n                  System.out.print(s2);\n                  System.out.print(s1);\n            &#125;\n          &#125;\n       &#125;\n   &#125;.start();\n  &#125;\n&#125;\n4.8 Lock(锁)\n从JDK 5.0开始，Java提供了更强大的线程同步机制——通过显式定义同步锁对象来实现同步。同步锁使用Lock对象充当。\n\njava.util.concurrent.locks.Lock接口是控制多个线程对共享资源进行访问的工具。 锁提供了对共享资源的独占访问，每次只能有一个线程对Lock对象 加锁，线程开始访问共享资源之前应先获得Lock对象。\n\nReentrantLock 类实现了 Lock ，它拥有与 synchronized 相同的并发性和内存语义， 在实现线程安全的控制中，比较常用的是ReentrantLock，可以显式加锁、释放锁。\n\n\nclass A&#123;\n    private final ReentrantLock lock = new ReenTrantLock(); \n    public void m()&#123;\n        lock.lock();//加锁\n     try&#123;\n       //保证线程安全的代码;\n      &#125;\n     finally&#123;\n        lock.unlock();//解锁\n      &#125;\n    &#125;\n&#125;\n注意：如果同步代码有异常，要将unlock()写入finally语句块\n4.9  synchronized 与 Lock 的对比\n Lock是显式锁(手动开启和关闭锁，别忘记关闭锁)， synchronized是 隐式锁，出了作用域自动释放\n\n Lock只有代码块锁， synchronized有代码块锁和方法锁\n\n 使用Lock锁， JVM将花费较少的时间来调度线程，性能更好。并且具有 更好的扩展性(提供更多的子类)\n\n\n优先使用顺序：Lock &gt; 同步代码块(已经进入了方法体，分配了相应资源) &gt; 同步方法 (在方法体之外)\n5、线程的通信思考\n使用两个线程打印 1-100。线程1， 线程2 交替打印\nclass Communication implements Runnable &#123;\n        int i = 1;\n       public void run() &#123;\n           while (true) &#123;\n             synchronized (this) &#123;\n                notify();\n               if (i &lt;= 100) &#123;\n                 System.out.println(Thread.currentThread().getName() +\n                   \":\" + i++);\n           &#125; else\n              break;\n         try &#123;\n            wait();\n         &#125; catch (InterruptedException e) &#123;\n           e.printStackTrace();\n            &#125;\n         &#125;\n      &#125;\n    &#125;\n&#125;\n\n\nwait() 与 notify() 和 notifyAll()\nwait()：令当前线程挂起并放弃CPU、同步资源并等待，使别的线程可访问并修改共享资源，而当      前线程排队等候其他线程调用notify()或notifyAll()方法唤醒， 唤醒后等待重新获得对监视器的所有权后才能继续执行。\nnotify()：唤醒正在排队等待同步资源的线程中优先级最高者结束等待\nnotifyAll ()：唤醒正在排队等待资源的所有线程结束等待.\n\n\n这三个方法只有在synchronized方法或synchronized代码块中才能使用，否则会报java.lang.IllegalMonitorStateException异常。\n因为这三个方法必须有锁对象调用，而任意对象都可以作为synchronized的同步锁， 因此这三个方法只能在Object类中声明。\n\n5.1 wait() 方法\n在当前线程中调用方法：  对象名.wait()\n使当前线程进入等待(某对象)状态 ，直到另一线程对该对象发出 notify (或notifyAll) 为止。\n调用方法的必要条件：当前线程必须具有对该对象的监控权(加锁) 调用此方法后，当前线程将释放对象监控权 ，然后进入等待\n在当前线程被notify后，要重新获得监控权，然后从断点处继续代码的执行。\n\n5.2 notify()/notifyAll()\n在当前线程中调用方法：  对象名.notify()\n功能：唤醒等待该对象监控权的一个/所有线程。\n调用方法的必要条件：当前线程必须具有对该对象的监控权(加锁)\n\n经典例题：生产者/消费者问题\n\n生产者(Productor)将产品交给店员(Clerk)，而消费者(Customer)从店员处 取走产品，店员一次只能持有固定数量的产品(比如:20)，如果生产者试图 生产更多的产品，店员会叫生产者停一下，如果店中有空位放产品了再通 知生产者继续生产；如果店中没有产品了，店员会告诉消费者等一下，如 果店中有产品了再通知消费者来取走产品。\n这里可能出现两个问题：\n生产者比消费者快时，消费者会漏掉一些数据没有取到。\n消费者比生产者快时，消费者会取相同的数据。\n\n\n\n\nclass Clerk &#123; // 售货员\n     private int product = 0;\n\n     public synchronized void addProduct() &#123; if (product >= 20) &#123;\n         try &#123;\n             wait();\n          &#125; catch (InterruptedException e) &#123;\n             e.printStackTrace();\n          &#125;\n         &#125; else &#123;\n            product++;\n         System.out.println(\"生产者生产了 第\" + product + \"个产品\");\n         notifyAll();\n        &#125;\n       &#125;\n\n  public synchronized void getProduct() &#123;\n      if (this.product &lt;= 0) &#123;\n         try &#123;\n           wait();\n       &#125; catch (InterruptedException e) &#123; \n           e.printStackTrace();\n      &#125;\n     &#125; else &#123;\n        System.out.println(\"消费者取走了第\" +product + \"个产品\");\n        product--;\n        notifyAll();\n     &#125;\n   &#125;\n&#125;\n\nclass Productor implements Runnable &#123; // 生产者\n    Clerk clerk;\n\n  public Productor(Clerk clerk) &#123;\n     this.clerk = clerk;\n&#125;\n\n   public void run() &#123;\n     System.out.println(\"生产者开始生产产品\");\n    while (true) &#123;\n  try &#123;\n     Thread.sleep((int) Math.random() * 1000);\n   &#125; catch (InterruptedException e) &#123;\n     e.printStackTrace();\n   &#125;\n     clerk.addProduct();\n    &#125;\n   &#125;\n&#125;\n\n\nclass Consumer implements Runnable &#123; // 消费者\n   Clerk clerk;\npublic Consumer(Clerk clerk) &#123;\n     this.clerk = clerk;\n&#125;\npublic void run() &#123;\n    System.out.println(\"消费者开始取走产品\");\nwhile (true) &#123;\n    try &#123;\n      Thread.sleep((int) Math.random() * 1000);\n   &#125; catch (InterruptedException e) &#123;\n      e.printStackTrace();\n   &#125;\n      clerk.getProduct();\n   &#125;\n  &#125;\n&#125;\n\n\npublic class ProductTest &#123;\n    public static void main(String[] args) &#123;\n        Clerk clerk = new Clerk();\n        Thread productorThread = new Thread(new Productor(clerk));\n        Thread consumerThread = new Thread(new Consumer(clerk));\n        productorThread.start();\n        consumerThread.start();\n   &#125;\n&#125;\n\n\n模拟银行取钱的问题\n\n定义一个Account类1)该Account类封装了账户编号(String)和余额(double)两个属性2)设置相应属性的getter和setter方法3)提供无参和有两个参数的构造器4)系统根据账号判断与用户是否匹配，需提供hashCode()和equals()方法的重写\n提供两个取钱的线程类：小明、小明’swife1)提供了Account类的account属性和double类的取款额的属性2)提供带线程名的构造器3)run()方法中提供取钱的操作\n在主类中创建线程进行测试。考虑线程安全问题。\n\nclass Account &#123;\n    private String accountId;\n    private double balance;\n    public Account() &#123;\n   &#125;\n    public Account(String accountId, double balance) &#123;\n      this.accountId = accountId;\n      this.balance = balance;\n   &#125;\n    public String getAccountId() &#123;\n      return accountId;\n   &#125;\n    public void setAccountId(String accountId) &#123; \n      this.accountId = accountId;\n   &#125;\n    public double getBalance() &#123;\n      return balance;\n   &#125;\n    public void setBalance(double balance) &#123; \n      this.balance = balance;\n   &#125;\n    public String toString() &#123;\n      return \"Account [accountId=\" + accountId + \", balance=\" + balance + \"]\";\n   &#125;\n\n\nclass Account &#123;\n   private String accountId;\n   private double balance;\n   public Account() &#123;\n   &#125;\n   public Account(String accountId, double balance) &#123; \n      this.accountId = accountId;\n      this.balance = balance;\n   &#125;\n   public String getAccountId() &#123;\n      return accountId;\n   &#125;\n   public void setAccountId(String accountId) &#123; \n     this.accountId = accountId;\n  &#125;\n   public double getBalance() &#123;\n     return balance;\n  &#125;\n    public void setBalance(double balance) &#123; \n     this.balance = balance;\n  &#125;\n    public String toString() &#123;\n        return \"Account [accountId=\" + accountId + \", balance=\" + balance + \"]\";\n&#125;\n\n\npublic int hashCode() &#123;\n      final int prime = 31;\n            int result = 1;\n            result = prime * result + ((accountId == null) ? 0 : accountId.hashCode());\n            long temp;\n            temp = Double.doubleToLongBits(balance);\n            result = prime * result + (int) (temp ^ (temp >>> 32));\n         return result;\n     &#125;\n      public boolean equals(Object obj) &#123;\n        if (this == obj)\n           return true;\n        if (obj == null)\n           return false;\n        if (getClass() != obj.getClass())\n           return false;\n         Account other = (Account) obj;\n        if (accountId == null) &#123;\n           if (other.accountId != null)\n                return false;\n             &#125; else if (!accountId.equals(other.accountId)) \n                return false;\n        if (Double.doubleToLongBits(balance) != Double.doubleToLongBits(other.balance))\n         return false;\n         return true;\n     &#125;\n&#125;\n\nclass WithDrawThread extends Thread &#123;\n        Account account;\n        // 要取款的额度\n        double withDraw;\n        public WithDrawThread(String name, Account account, double amt) &#123;\n        super(name);\n        this.account = account;\n        this.withDraw = amt;\n       &#125;\n     public void run() &#123;\n        synchronized (account) &#123;\n          if (account.getBalance() > withDraw) &#123;\n                System.out.println(Thread.currentThread().getName() + \":取款成功，取现的金额为： \" + withDraw); \n            try &#123;\n                 Thread.sleep(50);\n             &#125; catch (InterruptedException e) &#123;\n                e.printStackTrace();\n            &#125;\n               account.setBalance(account.getBalance() - withDraw);\n            &#125; else &#123;\n                System.out.println(\"取现额度超过账户余额，取款失败\");\n       &#125;\n            System.out.println(\"现在账户的余额为： \" + account.getBalance());\n      &#125;\n    &#125;\n&#125;\n\npublic class WithDrawThreadTest &#123;\n     public static void main(String[] args) &#123;\n       Account account = new Account(\"1234567\", 10000);     \n       Thread t1 = new WithDrawThread(\"小明\", account, 8000);\n       Thread t2 = new WithDrawThread(\"小明's wife\", account, 2800); \n       t1.start();\n       t2.start();\n     &#125;\n&#125;\n6、JDK5.0新增线程创建方式6.1 新增方式一：实现Callable接口\n与使用Runnable相比，  Callable功能更强大些\n\n相比run()方法， 可以有返回值\n方法可以抛出异常\n支持泛型的返回值\n需要借助FutureTask类， 比如获取返回结果\n\n\nFuture接口\n\n可以对具体Runnable、Callable任务的执行结果进行取消、查询是否完成、获取结果等。\nFutrueTask是Futrue接口的唯一的实现类\nFutureTask 同时实现了Runnable, Future接口。它既可以作为Runnable被线程执行，又可以作为Future得到Callable的返回值\n\n\n\n6.2 新增方式二：使用线程池\n背景： 经常创建和销毁、使用量特别大的资源，比如并发情况下的线程，对性能影响很大。\n思路： 提前创建好多个线程，放入线程池中，使用时直接获取，使用完放回池中。可以避免频繁创建销毁、实现重复利用。类似生活中的公共交 通工具。\n好处：\n提高响应速度 (减少了创建新线程的时间)\n降低资源消耗 (重复利用线程池中线程，不需要每次都创建)  \n便于线程管理\ncorePoolSize：核心池的大小\nmaximumPoolSize：最大线程数\nkeepAliveTime：线程没有任务时最多保持多长时间后会终止    \n…\n\n\n\n\n\n6.3 线程池相关API\nJDK 5.0起提供了线程池相关API：ExecutorService 和 Executors\nExecutorService：真正的线程池接口。常见子类ThreadPoolExecutor\nvoid execute(Runnable command) ：执行任务/命令，没有返回值，一般用来执行Runnable\n Future submit(Callable task)：执行任务，有返回值， 一般又来执行Callable\nvoid shutdown() ：关闭连接池\n\n\nExecutors：工具类、线程池的工厂类，用于创建并返回不同类型的线程池\nExecutors.newCachedThreadPool()：创建一个可根据需要创建新线程的线程池         \nExecutors.newFixedThreadPool(n); 创建一个可重用固定线程数的线程池       \nExecutors.newSingleThreadExecutor() ：创建一个只有一个线程的线程池\nExecutors.newScheduledThreadPool(n)：创建一个线程池，它可安排在给定延迟后运行命令或者定期地执行。\n\n\n\n","slug":"Java/多线程","date":"2023-02-09T14:33:12.000Z","categories_index":"Java","tags_index":"Java","author_index":"YimooRua"},{"id":"4f643f8888ac5de96f9123ba132fb3d8","title":"Java反射学习笔记","content":"Java反射机制1、Java反射机制概述1.1 Java反射（Java Reflection）\nReflection (反射)是被视为动态语言的关键，反射机制允许程序在执行期 借助于Reflection API取得任何类的内部信息，并能直接操作任意对象的内 部属性及方法。\n\n加载完类之后，在堆内存的方法区中就产生了一个Class类型的对象 (一个 类只有一个Class对象) ，这个对象就包含了完整的类的结构信息。我们可 以通过这个对象看到类的结构。这个对象就像一面镜子，透过这个镜子看 到类的结构，所以，我们形象的称之为： 反射。\n  正常方式： 引入需要的”包类”名称 →  通过new实例化 →  取得实例化对象  反射方式：  实例化对象 →  getClass()方法 →  得到完整的“包类”名称\n\n\n1.2 补充：动态语言 vs 静态语言1、动态语言是一类在运行时可以改变其结构的语言：例如新的函数、对象、甚至代码可以被引进，已有的函数可以被删除或是其他结构上的变化。通俗点说就是在运行时代码可以根据某些条件改变自身结构。主要动态语言： Object-C、C#、JavaScript、PHP、Python、Erlang。\n2、静态语言\n与动态语言相对应的， 运行时结构不可变的语言就是静态语言。如Java、C、 C++。\n\n\n\n\n\n\n\n\n\nJava不是动态语言，但Java可以称之为“准动态语言” 。即Java有一定的动态性，我们可以利用反射机制、字节码操作获得类似动态语言的特性。Java的动态性让编程的时候更加灵活！\n1.3 Java反射机制研究及应用Java反射机制提供的功能\n\n在运行时判断任意一个对象所属的类\n在运行时构造任意一个类的对象\n在运行时判断任意一个类所具有的成员变量和方法\n在运行时获取泛型信息\n在运行时调用任意一个对象的成员变量和方法\n在运行时处理注解\n生成动态代理\n\n\n\n反射相关的主要API\n\njava.lang.Class:代表一个类\njava.lang.reflect.Method:代表类的方法\njava.lang.reflect.Field:代表类的成员变量\njava.lang.reflect.Constructor:代表类的构造器\n… …\n\n2、理解Class类并获取Class实例2.1 Class 类在Object类中定义了以下的方法，此方法将被所有子类继承：\npublic final Class getClass()\n以上的方法返回值的类型是一个Class类，此类是Java反射的源头，实际上所谓反射从程序的运行结果来看也很好理解，即：可以通过对象反射求出类的名称。\n \n\n对象照镜子后可以得到的信息：某个类的属性、方法和构造器、某个类到底实现了哪些接口。对于每个类而言， JRE 都为其保留一个不变的 Class 类型的对象。一个 Class 对象包含了特定某个结构(class/interface/enum/annotation/primitive type/void/[])的有关信息。\nClass本身也是一个类\nClass 对象只能由系统建立对象\n一个加载的类在 JVM 中只会有一个Class实例\n一个Class对象对应的是一个加载到JVM中的一个.class文件\n每个类的实例都会记得自己是由哪个 Class 实例所生成\n通过Class可以完整地得到一个类中的所有被加载的结构\nClass类是Reflection的根源，针对任何你想动态加载、运行的类，唯有先获得相应的Class对象\n\n\n\n2.2 Class类的常用方法\n\n\n方法名\n功能说明\n\n\n\nstatic Class forName(String name)\n返回指定类名 name 的 Class 对象\n\n\nObject newInstance()\n调用缺省构造函数，返回该Class对象的一个实例\n\n\ngetName()\n返回此Class对象所表示的实体(类、接口、数组类、基本类型 或void)名称\n\n\nClass getSuperClass()\n返回当前Class对象的父类的Class对象\n\n\nClass [] getInterfaces()\n获取当前Class对象的接口\n\n\nClassLoader getClassLoader()\n返回该类的类加载器\n\n\nClass getSuperclass()\n返回表示此Class所表示的实体的超类的Class\n\n\nConstructor[] getConstructors()\n返回一个包含某些Constructor对象的数组\n\n\nField[] getDeclaredFields()\n返回Field对象的一个数组\n\n\nMethod getMethod(String\n返回一个Method对象， 此对象的形参类型为paramType\n\n\n2.3 反射的应用举例String str = \"test4.Person\";\nClass clazz = Class.forName(str);\nObject obj = clazz.newInstance();\nField field = clazz.getField(\"name\");\nfield.set(obj, \"Peter\");\nObject name = field.get(obj);\nSystem.out.println(name);\n注：test4.Person是test4包下的Person类\n2.4 获取Class类的实例（四种方法）\n前提： 若已知具体的类，通过类的class属性获取， 该方法最为安全可靠， 程序性能最高实例：Class clazz = String.class;\n前提： 已知某个类的实例，调用该实例的getClass()方法获取Class对象实例：Class clazz = “www.yimoorua.top“ .getClass();\n前提： 已知一个类的全类名，且该类在类路径下， 可通过Class类的静态方 法forName()获取，可能抛出ClassNotFoundException实例：Class clazz = Class.forName(“java.lang.String”);\n其他方式(不做要求)ClassLoader cl = this.getClass().getClassLoader();Class clazz4 = cl.loadClass(“类的全类名”);\n\n2.5 哪些类型可以有Class对象？\nclass：外部类，成员(成员内部类，静态内部类) ，局部内部类，匿名内部类\ninterface ：接口\n[]：数组\nenum：枚举\nannotation：注解@interface\nprimitive type：基本数据类型\nvoid\n\nClass c1 = Object.class;\nClass c2 = Comparable.class;\nClass c3 = String[].class;\nClass c4 = int[][].class;\nClass c5 = ElementType.class;\nClass c6 = Override.class;\nClass c7 = int.class;\nClass c8 = void.class;\nClass c9 = Class.class;\n\nint[] a = new int[10];\nint[] b = new int[100];\nClass c10 = a.getClass();\nClass c11 = b.getClass();\n// 只要元素类型与维度一样，就是同一个Class\nSystem.out.println(c10 == c11);\n\n3、类的加载与ClassLoader的理解3.1 了解：类的加载过程当程序主动使用某个类时，如果该类还未被加载到内存中，则系统会通过 如下三个步骤来对该类进行初始化。\n\n\n加载：将class文件字节码内容加载到内存中，并将这些静态数据转换成方法区的运行时 数据结构，然后生成一个代表这个类的java.lang.Class对象，作为方法区中类数据的访问 入口(即引用地址)。所有需要访问和使用类数据只能通过这个Class对象。这个加载的 过程需要类加载器参与。\n链接：将Java类的二进制代码合并到JVM的运行状态之中的过程。\n验证：确保加载的类信息符合JVM规范，例如：以cafe开头，没有安全方面的问题\n准备：正式为类变量(static)分配内存并&lt;b style=”color:blue&gt;”设置类变量默认初始值的阶段，这些内存都将在方法区中进行分配。\n解析：虚拟机常量池内的符号引用(常量名)替换为直接引用(地址)的过程。\n\n\n初始化：\n执行类构造器()方法的过程。 类构造器()方法是由编译期自动收集类中 所有类变量的赋值动作和静态代码块中的语句合并产生的。  (类构造器是构造类信 息的，不是构造该类对象的构造器) 。\n当初始化一个类的时候， 如果发现其父类还没有进行初始化，则需要先触发其父类 的初始化。\n虚拟机会保证一个类的()方法在多线程环境中被正确加锁和同步\n\n\n\npublic class ClassLoadingTest &#123;\n         public static void main(String[] args) &#123;\n              System.out.println(A.m);\n         &#125;\n    &#125;\n\nclass A &#123;\n       static &#123;\n        m = 300;\n      &#125; \n    static int m = 100;\n   &#125;\n//第二步：链接结束后m=0\n//第三步：初始化后， m的值由&lt;clinit>()方法执行决定\n//       这个A的类构造器&lt;clinit>()方法由类变量的赋值和静态代码块中的语句按照顺序合并 产生，类似于\n//     &lt;clinit>()&#123;\n//         m = 300;\n//         m = 100;\n//     &#125;\n\n3.2 了解： 什么时候会发生类初始化？\n类的主动引用 (一定会发生类的初始化)\n当虚拟机启动，先初始化main方法所在的类\nnew一个类的对象\n调用类的静态成员 (除了final常量) 和静态方法\n使用java.lang.reflect包的方法对类进行反射调用\n当初始化一个类，如果其父类没有被初始化，则先会初始化它的父类  \n\n\n类的被动引用 (不会发生类的初始化)\n当访问一个静态域时，只有真正声明这个域的类才会被初始化\n当通过子类引用父类的静态变量，不会导致子类初始化  \n\n\n通过数组定义类引用，不会触发此类的初始化\n引用常量不会触发此类的初始化 (常量在链接阶段就存入调用类的常量池中了)\n\n\n\npublic class ClassLoadingTest &#123;\n      public static void main(String[] args) &#123;\n         // 主动引用：一定会导致A和Father的初始化 \n         // A a = new A();\n         // System.out.println(A.m);\n         // Class.forName(\"com.yimoorua.java2.A\");\n         // 被动引用\n         A[] array = new A[5];//不会导致A和Father的 初始化\n         // System.out.println(A.b);//只会初始化 Father\n         // System.out.println(A.M);//不会导致A和 Father的初始化\n&#125;\n        static &#123;\n            System.out.println(\"main所在的类\"); \n     &#125;\n&#125;\nclass Father &#123;\n     static int b = 2;\n     static &#123;\n        System.out.println(\"父类被加载\"); &#125;\n    &#125;\n&#125;\n\nclass A extends Father &#123;\n      static &#123;\n         System.out.println(\"子类被加载\"); \n         m = 300;\n      &#125;\n    static int m = 100;\n    static final int M = 1;\n&#125;\n\n3.3 类加载器的作用\n\n类加载的作用： 将class文件字节码内容加载到内存中，并将这些静态数据转换成方法区的运行时数据结构，然后在堆中生成一个代表这个类的java.lang.Class对象，作为方法区中类数据的访问入口。\n类缓存： 标准的JavaSE类加载器可以按要求查找类，但一旦某个类被加载到类加载器中，它将维持加载 (缓存) 一段时间。不过JVM垃圾回收机制可以回收这些Class对象。\n\n3.4 了解： ClassLoader类加载器作用是用来把类(class)装载进内存的。 JVM 规范定义了如下类型的类的加载器。\n \n\n引导类加载器(Bootstap)：用C++编写的，是JVM自带的类加载器， 负责Java平台核心库，用来装载核心类库。该加载器无法直接获取\n扩展类加载器(Extension)：负责jre/lib/ext目录下的jar包或 – D java.ext.dirs 指定目录下的jar包装入工作库\n系统类加载器(System)：负责java –classpath 或 – D java.class.path所指的目录下的类与jar包装入工作 ，是最常用的加载器\n\n//1.获取一个系统类加载器\nClassLoader classloader = ClassLoader.getSystemClassLoader();\nSystem.out.println(classloader);\n//2.获取系统类加载器的父类加载器，即扩展类加载器\nclassloader = classloader.getParent();\nSystem.out.println(classloader);\n//3.获取扩展类加载器的父类加载器，即引导类加载器\nclassloader = classloader.getParent();\nSystem.out.println(classloader);\n//4.测试当前类由哪个类加载器进行加载\nclassloader = Class.forName(\"exer2.ClassloaderDemo\").getClassLoader();\nSystem.out.println(classloader);\n//5.测试JDK提供的Object类由哪个类加载器加载\nclassloader =\nClass.forName(\"java.lang.Object\").getClassLoader();\nSystem.out.println(classloader);\n//*6.关于类加载器的一个主要方法： getResourceAsStream(String str):获取类路 径下的指定文件的输入流\nInputStream in = null;\nin = this.getClass().getClassLoader().getResourceAsStream(\"exer2\\\\test.properties\");\nSystem.out.println(in);\n\n4、创建运行时类的对象有了Class对象，能做什么？创建类的对象： 调用Class对象的newInstance()方法要 求：      1) 类必须有一个无参数的构造器。      2) 类的构造器的访问权限需要足够。\n难道没有无参的构造器就不能创建对象了吗？不是！只要在操作的时候明确的调用类中的构造器， 并将参数传递进去之后，才可以实例化操作。 \n步骤如下：\n\n通过Class类的getDeclaredConstructor(Class … parameterTypes)取得本类的指定形参类型的构造器\n向构造器的形参中传递一个对象数组进去，里面包含了构造器中所需的各个参数。         \n通过Constructor实例化对象。\n\n \n以上是反射机制应用最多的地方。 \n//1.根据全类名获取对应的Class对象\nString name = “yimoorua.java.Person\";\nClass clazz = null;\nclazz = Class.forName(name);\n//2.调用指定参数结构的构造器，生成Constructor的实例\nConstructor con = clazz.getConstructor(String.class,Integer.class);\n//3.通过Constructor的实例创建对应类的对象，并初始化类属性\nPerson p2 = (Person) con.newInstance(\"Peter\",20);\nSystem.out.println(p2);\n\n5、获取运行时类的完整结构通过反射获取运行时类的完整结构\nField、Method 、Constructor、Superclass、Interface 、Annotation\n\n实现的全部接口\n所继承的父类\n全部的构造器\n全部的方法\n全部的Field\n\n使用反射可以取得：1. 实现的全部接口 public Class&lt;?&gt;[] getInterfaces() 确定此对象所表示的类或接口实现的接口。\n2. 所继承的父类 public Class&lt;? Super T&gt; getSuperclass()返回表示此 Class 所表示的实体(类、接口、基本类型)的父类的 Class。\n3. 全部的构造器public Constructor[] getConstructors()返回此 Class 对象所表示的类的所有public构造方法。public Constructor[] getDeclaredConstructors()返回此 Class 对象表示的类声明的所有构造方法。\nConstructor类中：\n\n取得修饰符: public int getModifiers();\n取得方法名称: public String getName();\n取得参数的类型： public Class&lt;?&gt;[] getParameterTypes();\n\n4. 全部的方法 public Method[] getDeclaredMethods()返回此Class对象所表示的类或接口的全部方法 public Method[] getMethods()返回此Class对象所表示的类或接口的public的方法\n Method类中： public Class getReturnType()取得全部的返回值\n public Class[] getParameterTypes()取得全部的参数 public int getModifiers()取得修饰符 public Class&lt;?&gt;[] getExceptionTypes()取得异常信息\n5. 全部的Field public Field[] getFields()返回此Class对象所表示的类或接口的public的Field。 public Field[] getDeclaredFields()返回此Class对象所表示的类或接口的全部Field。\n Field方法中： public int getModifiers()  以整数形式返回此Field的修饰符 public Class&lt;?&gt; getType()  得到Field的属性类型 public String getName()  返回Field的名称。\n6. Annotation相关  get Annotation(Class annotationClass)  getDeclaredAnnotations()\n7. 泛型相关获取父类泛型类型： Type getGenericSuperclass()泛型类型： ParameterizedType获取实际的泛型类型参数数组： getActualTypeArguments()\n8. 类所在的包  Package getPackage()\n小 结：1.在实际的操作中，取得类的信息的操作代码，并不会经常开发。2.一定要熟悉java.lang.reflect包的作用，反射机制。3.如何取得属性、方法、构造器的名称，修饰符等。\n6、调用运行时类的指定结构6.1 调用指定方法通过反射，调用类中的方法，通过Method类完成。步骤：                  \n\n通过Class类的getMethod(String name,Class…parameterTypes)方法取得 一个Method对象，并设置此方法操作时所需要的参数类型。                \n之后使用Object invoke(Object obj, Object[] args)进行调用，并向方法中传递要设置的obj对象的参数信息。\n\n \nObject invoke (Object obj ,Object…args)\n说明：\n\nObject 对应原方法的返回值，若原方法无返回值，此时返回null \n若原方法若为静态方法，此时形参Object obj可为null         \n若原方法形参列表为空，则Object[] args为null\n若原方法声明为private,则需要在调用此invoke()方法前，显式调用 方法对象的setAccessible(true)方法，将可访问private的方法。\n\n6.2 调用指定属性在反射机制中，可以直接通过Field类操作类中的属性，通过Field类提供的set()和 get()方法就可以完成设置和取得属性内容的操作。\n\npublic Field getField(String name) 返回此Class对象表示的类或接口的指定的 public的Field。\npublic Field getDeclaredField(String name)返回此Class对象表示的类或接口的 指定的Field。\n\n在Field中：\n\npublic Object get(Object obj) 取得指定对象obj上此Field的属性内容\npublic void set(Object obj,Object value) 设置指定对象obj上此Field的属性内容\n\n6.3 关于setAccessible方法的使用\nMethod和Field 、Constructor对象都有setAccessible()方法。\nsetAccessible启动和禁用访问安全检查的开关。\n参数值为true则指示反射的对象在使用时应该取消Java语言访问检查。   \n提高反射的效率。如果代码中必须用反射，而该句代码需要频繁的被调用，那么请设置为true。\n使得原本无法访问的私有成员也可以访问\n\n\n参数值为false则指示反射的对象应该实施Java语言访问检查。\n\n7、反射的应用：动态代理7.1 代理设计模式的原理:使用一个代理将对象包装起来, 然后用该代理对象取代原始对象。任何对原 始对象的调用都要通过代理。代理对象决定是否以及何时将方法调用转到原 始对象上。\n\n之前为大家讲解过代理机制的操作，属于静态代理，特征是代理类和目标 对象的类都是在编译期间确定下来，不利于程序的扩展。同时，每一个代 理类只能为一个接口服务，这样一来程序开发中必然产生过多的代理。 最好可以通过一个代理类完成全部的代理功能。\n动态代理是指客户通过代理类来调用其它对象的方法，并且是在程序运行时根据需要动态创建目标类的代理对象。\n动态代理使用场合:\n调试\n远程方法调用\n\n\n动态代理相比于静态代理的优点：抽象角色中(接口)声明的所有方法都被转移到调用处理器一个集中的方法中 处理，这样，我们可以更加灵活和统一的处理众多的方法。\n\n7.2 Java动态代理相关API\nProxy ：专门完成代理的操作类，是所有动态代理类的父类。通过此类为一 个或多个接口动态地生成实现类。\n提供用于创建动态代理类和动态代理对象的静态方法\nstatic Class getProxyClass(ClassLoader loader, Class… interfaces)  创建一个动态代理类所对应的Class对象\nstatic Object   newProxyInstance(ClassLoader loader, Class&lt;?&gt;[] interfaces, InvocationHandler h)  直接创建一个动态代理对象\n\n\n\n7.3 动态代理步骤\n创建一个实现接口InvocationHandler的类，它必须实现invoke方法，以完成代理的具体操作。public Object invoke(Object theProxy #代理类的对象, Method method #要调用的方法, Object[] params #方法调用时所需要的参数) throws Throwable&#123;\n      try&#123;\n          Object retval = method.invoke(targetObj, params);\n          // Print out the result\n          System.out.println(retval);\n          return retval; \n        &#125;catch (Exception exc)&#123;&#125;\n     &#125;\n创建被代理的类以及接口\n\n3. 通过Proxy的静态方法newProxyInstance(ClassLoader loader, Class[] interfaces, InvocationHandler h) //创建一个Subject接口代理RealSubject target = new RealSubject();// Create a proxy to wrap the original implementationDebugProxy proxy = new DebugProxy(target);// Get a reference to the proxy through the Subject interfaceSubject sub = (Subject) Proxy.newProxyInstance(Subject.class.getClassLoader(),new Class[] { Subject.class }, proxy);4. 通过 Subject代理调用RealSubject实现类的方法String info = sub.say(“Peter”, 24);System.out.println(info);\n7.4 动态代理与AOP  (Aspect Orient Programming)前面介绍的Proxy和InvocationHandler，很难看出这种动态代理的优势，下 面介绍一种更实用的动态代理机制\n \npublic interface Dog&#123; \n     void info();\n     void run();\n&#125;\n\npublic class HuntingDog implements Dog&#123;\n   public void info()&#123;\n      System.out.println(\"我是一只猎狗\"); &#125;\n   public void run()&#123;\n      System.out.println(\"我奔跑迅速\");\n  &#125;\n&#125;\n\npublic class DogUtil&#123;\n     public void method1()&#123;\n         System.out.println(\"=====模拟通用方法一=====\"); &#125;\n     public void method2()&#123;\n         System.out.println(\"=====模拟通用方法二=====\");\n    &#125;\n&#125;\n\npublic class MyInvocationHandler implements InvocationHandler&#123;\n     // 需要被代理的对象\n     private Object target;\n     public void setTarget(Object target)&#123;\n     this.target = target;&#125;\n     // 执行动态代理对象的所有方法时， 都会被替换成执行如下的invoke方法\npublic Object invoke(Object proxy, Method method, Object[] args) throws Exception&#123;\n      DogUtil du = new DogUtil();\n      // 执行DogUtil对象中的method1。\n      du.method1();\n      // 以target作为主调来执行method方法\n      Object result = method.invoke(target , args);\n      // 执行DogUtil对象中的method2。\n      du.method2();\n      return result;\n        &#125;\n      &#125;\n      \npublic class MyProxyFactory&#123;\n   // 为指定target生成动态代理对象\n   public static Object getProxy(Object target) throws Exception&#123;\n    // 创建一个MyInvokationHandler对象\n    MyInvokationHandler handler = new MyInvokationHandler();\n   // 为MyInvokationHandler设置target对象\n    handler.setTarget(target);\n   // 创建、并返回一个动态代理对象\n   return Proxy.newProxyInstance(target.getClass().getClassLoader(),target.getClass().getInterfaces() , handler); &#125;\n&#125;\n\npublic class Test&#123;\n     public static void main(String[] args) throws Exception&#123;\n     // 创建一个原始的HuntingDog对象，作为target\n       Dog target = new HuntingDog();\n     // 以指定的target来创建动态代理\n       Dog dog = (Dog)MyProxyFactory.getProxy(target); \n       dog.info();\n       dog.run();\n    &#125;\n  &#125;\n\n\n使用Proxy生成一个动态代理时，往往并不会凭空产生一个动态代理，这样没有太大的意义。通常都是为指定的目标对象生成动态代理\n这种动态代理在AOP中被称为AOP代理， AOP代理可代替目标对象， AOP代理包含了目标对象的全部方法。但AOP代理中的方法与目标对象的方法存在差异：AOP代理里的方法可以在执行目标方法之前、之后插入一些通用处理\n\nAOP代理的方法：\n\n动态代理增加的通用方法1\n回调目标对象的方法\n动态代理增加的通用方法2\n\n","slug":"Java/反射","date":"2023-02-08T12:33:12.000Z","categories_index":"Java","tags_index":"Java","author_index":"YimooRua"},{"id":"bb71d6addb13151a6cf3720a8c5516d6","title":"搭建图床","content":"搭建图床（Typora+PicGo+阿里云OSS服务 ）安装Typora下载Typora,目前Typora支持多平台安装，进入国内官网，国外的太慢了，目前需要收费，89rmb即可拿下，若不想花钱，这里有beta版,不过还是建议大家支持正版。（根据你的电脑选择具体版本），下载完先放着直接进行下一步。\n\n购买阿里云OSS服务1.前提是你得有一个阿里云账号，没有的直接注册就行，然后选择对象存储OSS，如果找不到直接在搜索栏搜索OSS，点击折扣套餐或者立即购买。\n\n2.进入如下界面，资源包类型和地域不用管，存储包规格正常40GB完全够用了，购买时常自选，半年到5年不等，价格还是比较合适的，一年才9rmb，选择完成之后点击立即购买，然后付款完成。\n3.创建Bucket,还是进入OSS对象存储，如果找不到就搜索，进入管理控制台。名称自定义，后面要用，地域选择离自己近的，读写权限改为公共读，其他不用动，点击确定。\n\n\n\n4.点击Bucket列表就可以看到你刚才创建的Bucket，点击概览\n\n点击Bucket名称，进入Bucket管理\n\n记住图中所指示的，我的是vicent-picture-for-typora和oss-cn-beijing。\n\n点击文件管理，新建一个目录，我的是img_for_typora/。\n\n5.创建AccessKey\n鼠标放在右上角的图像上就出来了如下图，点击AccessKey管理\n\n先点击继续使用AccessKey，然后再点击创建AccessKey。\n\n创建完成后，复制AccessKey ID和AccessKey Secret。\n\nPicGo下载可以去官方下载，选择对应的版本，我的是windows64,选择如下图。\n如果github访问不了，可以自取安装包\n\n直接点击安装，成功界面如下\n\n点击图床设置，然后点击阿里云OSS，\n\n这里的设定KeyId将之前的AccessKey ID复制过来\n设定KeySecret将之前的AccessKey Secret复制过来\n设定存储空间名就是下图中的1，之前2.4的设置\n确认存储区域就是下图中的2，之前2.4的设置\n存储路径为之前新建目录名\n然后点击确定，设置为默认图床\n\n\nTypora配置点击文件-&gt;偏好设置-&gt;图像按照如下图进行设置，其中PicGo路径为之前安装PicGo的路径\n\n至此所有的步骤都已经配置完成，可以直接再Typora中将图片上传到图床了。\n注意此时上传图片或者点击验证图片上传选项会报错Failed to fetch，如下图：\n\n\n报错原因：如上图所示，Typora端口使用的是36677，而PicGo使用的端口是36678，此时只需要将PicGo的端口号改为36677即可，如下图所示：\n打开PicGo选择PicGo设置，设置监听端口为36677，问题解决。此时你如果点击验证图片上传选项仍然报错，没有关系，图片已经能够上传了，这可能是一个typora的bug。\n\n（转自阿里云开发者社区）\n","slug":"Hexo/搭建图床","date":"2023-02-02T15:11:00.000Z","categories_index":"Hexo","tags_index":"Hexo","author_index":"YimooRua"},{"id":"3a4f7cb185da38b5b4569400c0d1c93f","title":"Java异常学习笔记","content":"Java异常处理异常概述与异常体系结构\n\n\n\n\n\n\n\n\n在使用计算机语言进行项目开发的过程中，即使程序员把代码写得尽善尽美，在系统的运行过程中仍然会遇到一些问题，因为很多问题不是靠代码能够避免的，比如：客户输入数据的格式，读取文件是否存在，网络是否始终保持通畅等等。\n\n异常：在Java语言中，将程序执行中发生的不正常情况称为“异常”。（开发过程中的语法错误和逻辑错误不是异常）\nJava程序在执行过程中所发生的异常事件可分为两类：\nError：Java虚拟机无法解决的严重问题。如：JVM系统内部错误、资源耗尽等严重情况。比如：StackOverflowError和OOM。一般不编写针对性的代码进行处理。\nException：其它因编程错误或偶然的外在因素导致的一般性问题，可以使用针对性的代码进行处理。例如：✅空指针访问✅试图读取不存在的文件✅网络连接中断✅数组角标越界\n对于这些错误，一般有两种解决方法：一是遇到错误就终止程序的运行。另一种方法是由程序员在编写程序时，就考虑到错误的检测、错误消息的提示，以及错误的处理。\n捕获错误最理想的是在编译期间，但有的错误只有在运行时才会发生。比如：除数为0，数组下标越界等分类：编译时异常和运行时异常\n\n\n\n\n蓝色：非受检（unchecked）异常红色：受检（checked）异常\n1.运行时异常\n\n是指编译器不要求强制处置的异常。一般是指编程时的逻辑错误，是程员应该积极避免其出现的异常。java.lang.RuntimeException类及它的子类都是运行时异常。\n对于这类异常，可以不作处理，因为这类异常很普遍，若全处理可能会对程序的可读性和运行效率产生影响。\n\n2.编译时异常\n\n是指编译器要求必须处置的异常。即程序在运行时由于外界因素造成的一般性异常。编译器要求  Java程序必须捕获或声明所有编译时异常。\n对于这类异常，如果程序不处理，可能会带来意想不到的结果。\n\n常见异常\njava.lang.RuntimeException\nClassCastException\nArrayindexOutOfBoundsException\nNul PointerException\nArithmeticException\nNumberFormatException\nInputMismatchException\n\n\njava.io.OExeption\nFileNotFoundException\nEOFException\n\n\njava.lang.ClassNotFoundException\njava.lang.InterruptedException\njava.io.FileNotFoundException\njava.sql.SQLException\n\nArraylndexOutofBoundsException示例如下：\npublic class IndexOutExp &#123;\n      public static void main(String[] args) &#123;\n            String friends[] = &#123; \"lisa\", \"bily\",\"kessy\" &#125;;\n                  for (int i 0;ix 5;i++) &#123;\n                      System.out.println(friends[i]); // friends[4]?\n                      &#125;\n                  System.out.println(\"\\n this is the end\");\n      &#125;\n&#125;\n\n\n\n\n\n\n提示\n程序IndexOutExp.java编译正确，运行结果：java IndexOutExp  lisa  bily  kessy  java.lang.ArraylndexOutofBoundsException     at Test7_1.main(Test7_ 1.java:5)  Exception in thread “main”\n\nNullPointerException示例如下：\npublic class NullRef &#123;\n    int i = 1;\n    public static void main(String[] args) &#123;\n         NullRef t = new Nul1Ref();\n         t = null;\n         System.out. printin(t.i);\n      &#125;\n&#125;\n\n\n\n\n\n\n提示\n程序NulRef.java编译正确，运行结果：java NullRef  java.lang.NullPointerException          at NullRef.main(NullRef java:6)  Exception in thread “main”\n\nArithmeticException示例如下：\npublic class DivideZero &#123;\n      int x;\n      public static void main (String[] args) &#123;\n      int y;\n      DivideZero c=new Dividezero();\n      y=3/c.x;\n      System.out.println(\"program ends ok!\");\n     &#125;\n   &#125;\n\n\n\n\n\n\n提示\n程序DivideZero.java编译正确，运行结果：java DivideZerojava.lang.ArithmeticException: / by zeroat DivideZero.main(DivideZero.java:6)Exception in thread “main”\n\nClassCastException示例如下：\npublic static void main(String[] args) &#123;\n      public class Order &#123;\n         Object obj = new Date();\n         Order order;\n         Order= (Order) obj;\n         System.out.println(order);\n    &#125;\n  &#125;\n\n\n\n\n\n\n提示\n程序Personjava编译正确，运行结果：java Person  java.lang.java.lang.ClassCastException   at Person.main(Person.java:5)   Exception in thread “main”\n\n异常处理机制一：try-catch-finally在编写程序时，经常要在可能出现错误的地方加上检测的代码，如进行x/y运算时，要检测分母为0，数据为空，输入的不是数据而是字符等。过多的if-else分支会导致程序的代码加长、臃肿，可读性差。因此采用异常处理机制。\nJava异常处理Java采用的异常处理机制，是将异常处理的程序代码集中在一起，与正常的程序代码分开，使得程序简洁、优雅，并易于维护。\nJava异常处理的方式：方式一：try-catch-finally方式二：throws+异常类型\n\nJava提供的是异常处理的抓抛模型。\nJava程序的执行过程中如出现异常，会生成一个异常类对象，该异常对象将被提交给Java运行时系统，这个过程称为抛出(throw)异常。\n异常对象的生成👉由虚拟机自动生成：程序运行过程中，虚拟机检测到程序发生了问题，如果在当前代码中没有找到相应的处理程序，就会在后台自动创建一个对应异常类的实例对象并抛出——自动抛出👉由开发人员手动创建：Exception exception = new ClassCastException();——创建好的异常对象不抛出对程序没有任何影响，和创建一个 普通对象一样\n\n异常的抛出机制\n \n为保证程序正常执行，代码必须对可能出现的异常进行处理。\n\n如果一个方法内抛出异常，该异常对象会被抛给调用者方法中处理。如果异常没有在调用者方法中处理，它继续被抛给这个调用方法的上层方法。这个过程将一直继续下去，直到异常被处理。这一过程称为捕获(catch)异常。\n如果一个异常回到main()方法，并且main()也不处理，则程序运行终止。\n程序员通常只能处理Exception，而对Error无能为力。\n\n异常处理是通过ty-catch-finally语句实现的。\ntry&#123;\n...//可能产生异常的代码\n&#125;\ncatch( ExceptionName1 e)&#123;\n...//当产生ExceptionName1型异常时的处置措施\n&#125;catch( ExceptionName2 e)&#123;\n...//当产生ExceptionName2型异常时的处置措施\n&#125;finally&#123;\n...//无论是否发生异常，都无条件执行的语句\n&#125;]\n\n\ntry捕获异常的第一步是用try..}语句块选定捕获异常的范围，将可能出现异常的代码放在try语句块中。\ncatch (Exceptiontype e)在catch语句块中是对异常对象进行处理的代码。每个try语句块可以伴随一个或多个catch语句，用于处理可能产生的不同类型的异常对象。\n\n\n\n\n\n\n\n提示\n如果明确知道产生的是何种异常，可以用该异常类作为catch的参数；也可以用其父类作为catch的参数。比如：可以用 ArithmeticException 类作为参数的地方，就可以用RuntimeException类作为参数，或者用所有异常的父类Exception类作为参数。但不能是与ArithmeticException类无关的异常，如NullPointerException ( catch中的语句将不会执行)。\n\n\n捕获异常的有关信息：与其它对象一样，可以访问一个异常对象的成员变量或调用它的方法。\ngetMessage() 获取异常信息，返回字符串\nprintStack Trace() 获取异常类名和异常信息，以及异常出现在程序中的位置。返回值void。\n\n\n\n  \n\nfinally👉捕获异常的最后一步是通过finally语句为异常处理提供一个统一的出口，使得在控制流转到程序的其它部分以前，能够对程序的状态作统一的管理。👉不论在try代码块中是否发生了异常事件，catch语句是否执行，catch语句是否有异常，catch语句中是否有return，finally块中的语句都会被执行。👉finally语句和catch语句是任选的。\n\n \npublic class IndexOutExp &#123;\n      public static void main(Stringt[] args) &#123;\n            String friends[] =&#123; \"1isa\",\"bily\",\"kessy\" &#125;;\n                  try &#123;\n                      for (int i = 0; i&lt; 5; i++) &#123;\n                         System.out.println(friends [i]);\n                       &#125;\n                  &#125; catch (ArrayIndexOutofBounds Exception e) &#123;\n                      System.out.println(\"index err\");\n                  &#125;\n                      System.out.println(\"\\n this is the end\");\n                  &#125;\n                    &#125;\n\n\n\n\n\n\n提示\n程序indexOutExp.java运行结果：java IndexOutExp     lisa     bily     kessy     index err     this is the end\n\n举例：\npublic class DivideZero1 &#123;\n        int X;\n        public static void main (String[] args)&#123;\n             int y;\n             DivideZero1 C = new DivideZero1();\n             try&#123;\n             y=3/c.x;\n             &#125; catch (ArithmeticException e) &#123;\n              System.out.println(\"divide by zero error!\");\n             &#125;\n             System. out.println(\"program ends ok!\");\n            &#125;\n          &#125;\n\n\n\n\n\n\n提示\n程序DivideZero1运行结果：java Dividezero1    divide by zero error!    program ends ok!\n\n练习：编写一个类ExceptionTest，在main方法中使用try、catch、finally，要求：👉在try块中，编写被零除的代码。👉在catch块中，捕获被零除所产生的异常，并且打印异常信息👉在finally块中，打印一条语句。\n体会\n\n捕获和不捕获异常，程序的运行有什么不同。\n体会try语句块中可能发生多个不同异常时的处理。\n体会finally语句块的使用。\n\n不捕获异常时的情况\n\n前面使用的异常都是RuntimeException类或是它的子类，这些类的异常的特点是：即使没有使用try和catch捕获，Java自己也能捕获，并且编译通过(但运行时会发生异常使得程序运行终止)。\n如果抛出的异常是IOException等类型的非运行时异常，则必须捕获，否则编译错误。也就是说，我们必须处理编译时异常，将异常进行捕捉，转化为运行时异常\n\nIOException异常处理举例（1）\nimport java.io.*;\n\npublic class IOExp &#123;\n     public static void main(String[] args) &#123;\n         FileInputStream in=new FileInputStream (\"atguigushk.txt\");\n         int b;\n         b = in.read();\n         while (b != -1) &#123;\n         System.out.print((char) b);\n         b = in.read();\n       &#125;\n       in.close();\n     &#125;\n    &#125;\n\nIOException异常处理举例（2）\nimport java.io.*;\npublic class IOExp &#123;\n      public static void main(String[] args) &#123;\n          try &#123;\n             FileInputStream in = new FileInputstream(\"atguigushk.txt\");\n             int b;\n             b = in.read();\n             while (b ！= -1)&#123;\n                System.out.print((char) b);\n                b = in.read();\n             &#125;\n             in.close();\n             &#125; catch (IOException e) &#123;\n                System.out.println(e);\n          &#125; finally &#123;\n               System.out.println(\" It's ok!\");\n       &#125;\n    &#125;\n&#125;\n\n练习2 捕获和处理IOException异常编译、运行应用程序IOExp.java，体会Java语言中异常的捕获和处理机制。相关知识：FilelnputStream类的成员方法read()的功能是每次从相应的(本地为ASCl码编码格式)文件中读取一个字节，并转换成0~255之间的int型整数返回，到达文件末尾时则返回-1。\n异常处理机制二：throws\n声明抛出异常是Java中处理异常的第二种方式➡️如果一个方法(中的语句执行时）可能生成某种异常，但是并不能确定如何处理这种异常，则此方法应显示地声明抛出异常，表明该方法将不对这些异常进行处理，而由该方法的调用者负责处理。➡️在方法声明中用throws语句可以声明抛出异常的列表，throws后面的异常类型可以是方法中产生的异常类型，也可以是它的父类。\n声明抛出异常举例：public void readFile (String file) throws FileNotFoundException {…// 读文件的操作可能产生FileNotFoundException类型的异常FilelnputStream fis = new FilelnputStream(file);…}       \n\n举例：\nimport java.io.*;\n       public class ThrowsTest &#123;\n             public static void main(String[] args) &#123;\n                     ThrowsTest t =new ThrowsTest();\n                      try &#123;\n                           t.readFile();\n                      &#125;catch (I0Exception e) &#123;\n                           e.printStackTrace();\n                        &#125;\n             &#125;\n             public void readFile() throws IOException&#123; //throws：抛出IO异常\n                     FileInputStream in = new FileInputstream(\"atguigushk.txt\");\n                     int b;\n                     b = in.read()；\n                     while (b != -1) &#123;\n                         System.out.print( (char) b);\n                         b= in.read();\n                       &#125;\n                       in.close();\n             &#125;\n       &#125;\n\n \n重写方法声明抛出异常的原则重写方法不能抛出比被重写方法范围更大的异常类型。在多态的情况下，对methodA()方法的调用-异常的捕获按父类声明的异常处理。\npublic class A{public void methodA() throws IOException {. . .}}public class B1 extends A{  public void methodA() throws FileNotFoundException{   . . .}}public class B2 extends A{   public void methodA() throws Exception { //报错   . . .}}\n手动抛出异常：throwJava异常类对象除在程序执行过程中出现异常时由系统自动生成并抛出，也可根据需要使用人工创建并抛出。➡️首先要生成异常类对象，然后通过throw语句实现抛出操作(提交给Java运行环境)。IOException e = new IOException();throw e;➡️可以抛出的异常必须是 Throwable或其子类的实例。下面的语句在编译时将会产生语法错误：throw new String(“want to throw”);\n用户自定义异常类\n一般地，用户自定义异常类都是RuntimeException的子类。\n自定义异常类通常需要编写几个重载的构造器。\n自定义异常需要提供serialVersionUI。\n自定义的异常通过throw抛出。\n自定义异常最重要的是异常类的名字，当异常出现时，可以根据名字判断异常类型。\n\n用户自定义异常类MyException，用于描述数据取值范围错误信息。用户自己的异常类必须继承现有的异常类。\n例一：\nclass MyException extends Exception &#123;\n      static final long serialVersionUID = 13465653435L;\n      private int idnumber;\n      public MyException(String message, int id) &#123;\n           super (message);\n           this.idnumber= id;\n       &#125;\n      public int getId() &#123;\n           return idnumber;\n      &#125;\n  &#125;\n例二：\npublic class MyExpTest&#123;\n      public void regist(int num) throws MyException &#123;\n           if(num &lt; 0)\n           throw new MyException(\"人数为负值，不合理\"，3);\n           else\n               System.out.println(\"登记人数\"+ num);\n       &#125;\n       public void manager() &#123;\n            try &#123;\n               regist(100);\n            &#125; catch (MyException e) &#123;\n               System.out.print（\"登记失败，出错种类\"+ e.getId());\n               &#125;\n                System.out.print(\"本次登记操作结束\");\n              &#125;\npublic static void main(String args[])&#123;\n           MyExpTest t = new MyExpTest();\n           t.manager();\n           &#125; \n         &#125;\n\n总结：异常处理5个关键字\n \n","slug":"Java/异常处理","date":"2023-01-24T09:33:12.000Z","categories_index":"Java","tags_index":"Java","author_index":"YimooRua"},{"id":"62d0949e8eed72da6db7f84008a4bde1","title":"Java泛型学习笔记","content":"Java泛型1、为什么要有泛型(Generic)\n泛型：标签\n举例：中药店，每个抽屉外面贴着标签,超市购物架上很多瓶子，每个瓶子裝的是什么，有标签 \n泛型的设计背景集合容器类在设计阶段/声明阶段不能确定这个容器到底实际存的是什么类型的对象，所以在JDK1.5之前只能把元素类型设计为Object，JDK1.5之后使用泛型来解决。因为这个时候除了元素的类型不确定，其他的部分是确定的，例如关于这个元素如何保存，如何管理等是确定的，因此此时把元素的类型设计成一个参数，这个类型参数叫做泛型。Collection&lt;E&gt;，List&lt;E&gt;，ArrayList&lt;E&gt;这个&lt;E&gt;就是类型参数，即泛型。\n泛型的概念\n所谓泛型，就是允许在定义类、接口时通过一个标识表示类中某个属性的类型或者是某个方法的返回值及参数类型。这个类型参数将在使用时（例如，继承或实现这个接口，用这个类型声明变量、创建对象时）确定（即传入实际的类型参数，也称为类型实参）。\n从JDK1.5以后，Java引入了“参数化类型(Parameterized type）” 的概念，允许我们在创建集合时再指定集合元素的类型，正如：List&lt;String&gt;，这表明该List只能保存字符串类型的对象。\nJDK1.5改写了集合框架中的全部接口和类，为这些接口、类增加了泛型支持，从而可以在声明集合变量、创建集合对象时传入类型实参。\n\n\n\n那么为什么要有泛型呢，直接Object不是也可以存储数据吗？\n\n解决元素存储的安全性问题，好比商品、药品标签，不会弄错。\n解决获取数据元素时，需要类型强制转换的问题，好比不用每回拿商品、药品都要辨别。\n\n \n \nJava泛型可以保证如果程序在编译时没有发出警告，运行时就不会产生ClassCastException异常。同时，代码更加简洁、健壮。\n2、在集合中使用泛型ArrayList‹Integer> list = new ArrayList&lt;>();//类型推断\n    list.add(78);\n    list.add(88);\n    list.add(77);\n    list.add(66);\n    //遍历方式一：\n    //for (Integer i: list)&#123;\n    //不需要强转\n    //System.out.println(i);\n    //&#125;\n    //遍历方式二：\n    Iterator&lt;Integer> iterator = list.iterator();\n    while(iterator.hasNext())&#123;\n    System.out.println(iterator.next());\n&#125;\n\nMap&lt;String, Integer> map= new HashMap&lt; String, Integer >();\n   map.put (\"Tom1\", 34);\n   map.put (\"Tom2\" , 44);\n   map.put (\"Tom3\", 33);\n   map.put (\"Tom4\", 32);\n   //添加失败\n   //map.put(33,\"Tom\");\n   Set&lt;Entry&lt;String, Integer> entrySet = map.entrySet();\n   Iterator&lt;Entry&lt;String, Integer>> iterator = entrySet.iterator();\n   while (iterator.hasNext())&#123;\n   Entry&lt;String, Integer> entry = iterator.next();\n    System.out.printin(entry.getKey() +\"--->\" + entry.getValue());\n   &#125;\n\n3、自定义泛型结构\n泛型的声明interface List 和 class GenTest&lt;K,V&gt;其中，T,K,V不代表值，而是表示类型。这里使用任意字母都可以。常用T表示，是Type的缩写。\n泛型的实例化：一定要在类名后面指定类型参数的值（类型）。如：\nList strList = new ArrayList();\nIterator iterator = customers.iterator();\n\n\n\nT只能是类，不能用基本数据类型填充。但可以使用包装类填充\n把一个集合中的内容限制为一个特定的数据类型，这就是generics背后的核心思想\n\nComparable c = new Date();\nSystem.out.printin(c.compareTo(\"red\"));\n//JDK 1.5之前\nComparable&lt;Date> c = new Date();\nSystem.out.printin(c.compareTo(\"red\"));\n//JDK 1.5\n体会：使用泛型的主要优点是能够在编译时而不是在运行时检测错误。\n泛型类、泛型接口\n泛型类可能有多个参数，此时应将多个参数一起放在尖括号内。比如：＜E1,E2,E3&gt;\n泛型类的构造器如下：public GenericClass(){}。而下面是错误的：public GenericClass(){}\n实例化后，操作原来泛型位置的结构必须与指定的泛型类型一致。\n泛型不同的引用不能相互赋值。尽管在编译时ArrayList和ArrayList是两种类型，但是，在运行时只有一个ArrayList被加载到JVM中。\n泛型如果不指定，将被擦除，泛型对应的类型均按照Object处理，但不等价于Object。经验：泛型要使用一路都用。要不用，一路都不要用。\n如果泛型结构是一个接口或抽象类，则不可创建泛型类的对象。\njdk1.7，泛型的简化操作：ArrayList&lt;Fruit&gt; flist = new ArrayList&lt;&gt;();\n泛型的指定中不能使用基本数据类型，可以使用包裝类替换。class GenericTest &#123;\n     public static void main(String[] args) &#123;\n     // 1、 使用时：类似于object，不等同于Object\n         ArrayList list = new ArrayList();\n     // list.add(new Date());//有风险\n         list.add(\"hello\");\n         test(list);//泛型擦除，编译不会类型检查\n     // ArrayListxObject〉 list2 = new ArrayListxObject>();\n     // test(list2);//一旦指定object，编译会类型检查，必须按照Object处理\n     &#125;\n      public static void test(ArrayList‹String> list) &#123;\n          String str = \"\";\n          for (String s : list)&#123;\n          str += s + \",\";\n        &#125;\n          System.out.println(\"元素：\" + str);\n       &#125;\n      &#125;\n在类/接口上声明的泛型，在本类或本接口中即代表某种类型，可以作为非静态属性的类型、非静态方法的参数类型、非静态方法的返回值类型。但在静态方法中不能使用类的泛型。\n异常类不能是泛型的\n不能使用new El。但是可以：El elements = (El)new Object()capacity;参考：ArrayList源码中声明：Object()elementData，而非泛型参数类型数组。\n父类有泛型，子类可以选择保留泛型也可以选择指定泛型类型：\n子类不保留父类的泛型：按需实现 没有类型–&gt;擦除 具体类型\n子类保留父类的泛型：泛型子类 全部保留 部分保留\n\n\n\n结论：子类必须是“富二代”，子类除了指定或保留父类的泛型，还可以增加自己的泛型\n//自定义泛型类\nclass Father&lt;T1, T2>&#123;&#125;\n// 子类不保留父类的泛型\n// 1)没有类型 擦除\nclass Son1 extends Father &#123;&#125;\n  // 等价于class Son extends Father&lt;Object, Object>&#123;\n// 2)具体类型\nclass Son2 extends Father&lt;Integer, String> &#123;&#125;\n// 子类保留父类的泛型\n// 1)全部保留\nclass Son3&lt;T1, T2> extends Father&lt;T1, T2> &#123;&#125;\n// 2)部分保留\nclass Son4&lt;T2> extends Father&lt;Integer,T2> &#123;\n&#125;\n\n//自定义泛型类\nclass Father&lt;T1, T2>&#123;&#125;\n// 子类不保留父类的泛型\n// 1)没有类型 擦除\nclass Son&lt;A, B> extends Father&#123;\n  //等价于class Son extends Father&lt;object,object>&#123;\n&#125;\n// 2)具体类型\nclass Son2&lt;A, B> extends Father&lt;Integer, String> &#123;\n&#125;\n// 子类保留父类的泛型\n//1)全部保留\nclass Son3&lt;T1, T2, A, B> extends Father&lt;T1, T2> &#123;\n&#125;\n// 2)部分保留\nclass Son4&lt;T2, A, B> extends Father&lt;Integer，T2>&#123;\n&#125;\n\n//自定义泛型类\nclass Person&lt;T> &#123;\n//使用T类型定义变量\nprivate T info;\n//使用T类型定义一般方法\npublic T getInfo() &#123;\n// 不能在try-catch中使用泛型定义\nreturn info;\n&#125;\npublic void setInfo(T info) &#123;\nthis.info = info;\n&#125;\n// 使用T类型定义构造器\npublic Person()&#123;&#125;\npublic Person(T info) &#123;\nthis.info = info;\n&#125;\n// static的方法中不能声明泛型\n//public static void show(T t) &#123;\n//&#125;\n/！不能在try-catch中使用泛型定义\n//public void test()&#123;\n//try &#123;\n/ catch (MyException&lt;T> ex)&#123;\n  //&#125;\n  //&#125;\n&#125;\n泛型方法\n方法，也可以被泛型化，不管此时定义在其中的类是不是泛型类。在泛型方法中可以定义泛型参数，此时，参数的类型就是传入数据的类型。\n泛型方法的格式：[访问权限]&lt;泛型&gt;返回类型 方法名([泛型标识参数名称]）抛出的异常\n泛型方法声明泛型时也可以指定上限public class DAO &#123;\n    public &lt;E> E get(int id,E  e)&#123;\n        E result = null;\n        return result;\n    &#125;\n&#125;\npublic static &lt;T> void fromArrayToCol lection(T[] a, Collection&lt;T> c) &#123;\n      for (T o: a) &#123;\n        c.add(o);\n    &#125;\n&#125;\npublic static void main(String[〕 args) &#123;\n     Object[] ao = new Object[100];\n     Collection&lt;object> co = new ArrayList&lt;Object>();\n     fromArrayToCollection(ao, co);\n     String[] sa = new String[20];\n     Collection&lt;String> cs = new ArrayList&lt;>();\n     fromArrayToCollection(sa, cs);\n     Collection&lt;Double〉 cd = new ArrayList&lt;>();\n     // 下面代码中T是Double类，但sa是String类型，编译错误。\n     // fromArrayToCollection(sa, cd);\n     //下面代码中T是Object类型，sa是String类型，可以赋值成功。\n     fromArrayToCollection(sa, co);\n&#125;\nclass Creature&#123;&#125;\nclass Person extends Creature&#123;&#125;\nclass Man extends Person&#123;&#125;\nclass PersonTest &#123;\n    public static &lt;T extends Person> void test(T t)&#123;\n      System.out.printin(t);\n    &#125;\npublic static void main(String[〕 args) &#123;\n      test (new Person());\n      test (new Man());\n      //The method test(T) in the type PersonTest is not\n      //applicable for the arguments (Creature)\n      test (new Creature());\n    &#125;\n&#125;\n\n4、泛型在继承上的使用请输出如下来两段代码有何不同\npublic void printCollection (Collection c) &#123;\nIterator i = c.iterator();\nSystem.out.printin(i.next());\nfor (int k = 0; k &lt; c.size(); k++)&#123;\n   System.out.println(i.next());\n  &#125;\n&#125;\npublic void printCollection (Collection&lt;Object> c) &#123;\n   for (object e:c)&#123;\n    System.out.println(e);\n    &#125;\n&#125;\n\n如果B是A的一个子类型（子类或者子接口），而G是具有泛型声明的类或接口，G&lt;B&gt;并不是G&lt;A&gt;的子类型！\n比如：String是Object的子类，但是List&lt;String&gt;并不是List&lt;Object&gt;的子类。B =&gt; AG&lt;B&gt; ≠&gt; G&lt;A&gt;\npublic void testGenericAndSubClass() &#123;\n    Person[]  persons =  null;\n    Man [] mans = null;\n   //而 Person[] 是 Man[] 的父类\n    persons =  mans;\n    Person p = mans[o];\n    //在泛型的集合上\n    List&lt;Person>  personList = null;\n    List&lt; Man> manList = null;\n    // personList = manList;(报错)\n&#125;\n\n5、通配符的使用\n使用类型通配符：?比如：List&lt;?&gt; , Map&lt;?,?&gt;List&lt;?&gt;是List&lt;String&gt;、List&lt;Object&gt;等各种泛型List的父类。\n读取List&lt;?&gt;的对象list中的元素时，永远是安全的，因为不管list的真实类型是什么，它包含的都是Object。\n写入list中的元素时，不行。因为我们不知道c的元素类型，我们不能向其中添加对象。＞唯一的例外是null，它是所有类型的成员。\n\n\n将任意元素加入到其中不是类型安全的：Collection&lt;?&gt; c = new ArrayListe String&gt;();c.add(new Object());//编译时错误因为我们不知道c的元素类型，我们不能向其中添加对象。add方法有类型参数E作为集合的元素类型。我们传给add的任何参数都必须是一个未知类型的子类。因为我们不知道那是什么类型，所以我们无法传任何东西进去。\n唯一的例外的是null，它是所有类型的成员。\n另一方面，我们可以调用get()方法并使用其返回值。返回值是一个未知的类型，但是我们知道，它总是一个Object。\n\npublic static void main(String[] args) &#123;\n        List&lt;?>list = null;\n        list = new ArrayList&lt;String>();\n        list = new ArrayList&lt;Double>();\n         // list.add(3);//编译不通过\n        list.add(null);\n        List&lt;String> 11 = new ArrayList&lt;String>();\n        List&lt;Integer> 12 = new ArrayList&lt;Integer>();\n        11.add(\"Yimoorua\");\n        12.add(15);\n        read(11);\n        read(12);\n  public static void read (List&lt;?> list) &#123;\n        for (Object o : list) &#123;\n            System.out.println(o);\n   &#125;\n\n\n\n\n\n\n\n注意\n//注意点1：编译错误：不能用在泛型方法声明上，返回值类型前面&lt;&gt;不能使用？public static  void test(ArrayList list){}\n//注意点2：编译错误：不能用在泛型类的声明上class GenericTypeClass&lt;?&gt;{}\n//注意点3：编译错误：不能用在创建对象上，右边属于创建集合对象ArrayList  list2 = new ArrayList();\n\n有限制的通配符\n\n\n允许所有泛型的引用调用\n通配符指定上限上限extends：使用时指定的类型必须是继承某个类，或者实现某个接口，即&lt;=\n通配符指定下限下限super：使用时指定的类型不能小于操作的类，即&gt;=\n举例：（无穷小，Number]\n只允许泛型为Number及Number子类的引用调用\n [Number，无穷大）\n只允许泛型为Number及Number父类的引用调用\n\n只允许泛型为实现Comparable接口的实现类的引用调用\n\npublic static void printCollection3(Collection&lt;? extends Person> coll) &#123;\n  //Iterator只能用Iterator&lt;?>或Iterator&lt;? extends Person>.why?\n  Iterator&lt;?> iterator = coll.iterator();\n    while (iterator.hasNext()) &#123;\n         System.out.println(iterator.next());\n       &#125;\n   &#125;\npublic static void printCollection4(Collection&lt;? super Person〉 coll)&#123;\n//Iterator只能用Iterator&lt;？>或Iterator&lt;? super Person>.why?\n      Iterator&lt;?〉iterator=coll.iterator();\n    while (iterator.hasNext()) &#123;\n          System.out.println(iterator.next());\n      &#125;\n   &#125;\n\n思考：为什么编译如下的操作会报错？\npublic static void addstrings(List«? extends Object> list)&#123;\n       list.add(\"aaa\");\n       list.add(\"aaa\");\n       list.add(new A());\n       list.add(new Circle());\n       list.add (new Geometricobject());\n       list.add(new object());\n    &#125;\npublic void addString(List&lt;? super A> list)&#123;\n       list.add(new A());\n       list.add(new Circle());\n       list.add(new Geometricobject());\n       list.add(new Obiect());\n    &#125;\n\n6、泛型应用举例泛型嵌套\npublic static void main(String[] args) &#123;\n      HashMapxString, ArrayList&lt;Citizen>> map = new HashMap&lt;String, ArrayList&lt;Citizen>>();\n      ArrayList&lt;Citizen> list = new ArrayList&lt;Citizen>();\n      list.add(new Citizen(\"刘恺威\"));\n      list.add(new Citizen(\"杨幂\"));\n      list.add(new Citizen(\"小糯米\"));\n      map.put(\"刘恺威\"，list);\n      SetxEntry&lt;String, ArrayList&lt;Citizen>> entrySet = map. entrySet();\n      Iterator&lt;Entry&lt;String, ArrayListxCitizen>> iterator = entrySet.iterator();\n      while (iterator.hasNext()) &#123;\n           Entry&lt;String, ArrayList&lt;Citizen>> entry = iterator.next();\n           String key = entry.getKey();\n           ArrayList&lt;Citizen> value = entry.getValue();\n           System. out.println(\"户主：\"+ key);\n           System.out.println(\"家庭成员：\"+ value);\n             &#125;\n       &#125;\n实际举例\n用户在设计类的时候往往会使用类的关联关系，例如，一个人中可以定义一个信息的属性，但是一个人可能有各种各样的信息（如联系方式、基本信息等），所以此信息属性的类型就可以通过泛型进行声明，然后只要设计相应的信息类即可。\n","slug":"Java/泛型","date":"2023-01-23T07:33:12.000Z","categories_index":"Java","tags_index":"Java","author_index":"YimooRua"},{"id":"0320adbbfdab8d9c75ad8f7cfd85cb84","title":"Linux之软件安装","content":"第三章 软件包安装一、 软件包分类1、 软件包分类\n源码包\n二进制包（脚本安装包）2、源码包2.1 源码包什么样\n\n[root@localhost~]# vim hello.c\n#include &lt;stdio.h>\nint main (void)\nprintf (\"hello world\\n”);\n&#125;\n\n[root@localhost~]# rpm -ivh /mnt/cdrom/Packages/gcc-4.4.6-4.e16.i686.rpm\n\n[root@localhost~]# gcc -c hello.c\n#-c生成\".o\"头文件。这里会生成 hello.o 头文件，但是不会生成执行文件\n\n[root@localhost~]# gcc -o hello hello.o\n#-o 生成执行文件，并制定执行文件名。这里生成的hello 就是可执行文件\n\n[root@localhost~]# ./hello\nhello world\n#执行hello 文件\n\n2.2 源码包特点源码包的优点是：\n\n开源，如果有足够的能力， 可以修改源代码\n可以自由选择所需的功能\n软件是编译安装，所以更加适合自己的系统，更加稳定也效率更高\n卸载方便源码包有缺点吗？\n安装过程步骤较多，尤其安装较大的软件集合时（如 LAMP 环境搭建），容易出现拼写错误\n编译过程时间较长，安装比二进制安装时间长\n因为是编译安装，安装过程中一旦报错新手很难解决3、二进制包3.1 二进制包分类\nDPKG 包：是由 Debian Linux 所开发出来的包管理机制，通过 DPKG 包，Debian Linux就可以进行软件包管理。主要应用在 Debian 和 unbuntu 中。\nRPM 包：是由 Red Hat 公司所开发的包管理系统。功能强大，安裝、升级、查询和卸载都非常简单和方便。目前很多 Linux 都在使用这种包管理方式，包括 Fedora、 CentOS、SuSE 等。我们学习的是 Centos 6.3， 所以我们将要学习 RPM 包管理系统3.2 特点RPM 包的优点：\n包管理系统简单，只通过几个命令就可以实现包的安裝、升级、查询和卸载\n安装速度比源码包安裝快的多RPM 包的缺点：\n经过编译，不再可以看到源代码\n功能选择不如源码包灵活\n依赖性。有时我们会发现需要安装软件包a时需要先安装b和c，而安装b时需要安装 d 和e。这是需要先安装d和e，再安装b和c，最后才能安装a包。比如说，我买了个漂亮的灯具，打算安装到我们家客厅，可是在安装灯具之前我们家客厅总要有顶棚吧，顶棚总要是做好了防水和刷好油漆了吧，这个装修和安装软件其实类似总要有一定的顺序的。可是有时依赖性会非常繁琐3.3 RPM包依赖\n\n\n1）树形依赖      a——&gt;b——&gt;c\n2）环形依赖      a——&gt;b——&gt;e——&gt;a\n3）函数库依赖\n什么是模块依赖？我们举一个例子，尝试安裝以下文件：\n[root@localhost Packages]# rpm -ivh mysql-connector-odbc-5.2.5-7.e17.x86_64.rpm\n错误：依赖检测失败：\nlibodbe.so.20(64bit) 被 mysql-connector-odbe-5.2.5-7.e17.x86_64 需要\nLibodbeinst.so.20(64bit) 被 mysql-connector-odbe-5.2.5-7.e17.x86_64 需要\n发现报错，需要安装 “ libodbe. so.2 “ 函数库文件，这时会发现在光盘中根本找不到这个文件。那是因为函数库没有单独成包，是包含在某一个软件包中的。而如果要知道在哪个软件包中，需要查询网站www.rpmfind. net。\n二、 rpm安装1、rpm包命名规则httpd-2.2.15-15. el6. centos. 1.i686. Tpm\n\n\n\n代码\n含义\n\n\n\nhttpd\n软件包名\n\n\n2.2.15\n软件版本\n\n\n15\n软件发布的次数\n\n\ne16\n软件发行商。el6是 Redlat 公司发布,适合 RHEL6.x(Red Hat Enterprise Linux)和 Centos6.x           下使用\n\n\ni686\n适合的硬件平台。RPM 包可以在不同的硬件平台安装，选择适合不同 CPU 的软件版本，可以最大化的发挥 CPU 性能，所以出现了所谓的 i386(386 以上计算机都可以安装）、1586 (586以上的计算机都可以安装）、1686（奔腾II 以上计算机都可以安装，目前所有的 CPU 都是奔腾II以上，所以这个软件版本居多）、×86 64(64 位 CPU 可以安装）和 noarch（没有硬件限制）等文件名了。\n\n\nrpm\n包的扩展名。我们说过 Linux 下文件不是靠扩展名区分文件类型，也就是 Limux 中扩展名没有任何含义。可是这里怎么又出现了扩展名呢？原因很简单，如果我不把 RPM的扩展名叫做“ .rpm ”，管理员很难知道这是一个 RPM包，当然也就无法正确安装了。也就是说如果RPM 包不用“.rpm ”作为扩展名，系统可以正确识别没有问题，可是管理员很难识别这是个什么样的软件\n\n\n包全名：如果操作的是未安装软件包，则使用包全名，而且需要注意绝对路径包名：如果操作的是己经安装的软件包，则使用包名即可，系统会生产 RPM 包的数据库(/var/lib/rpm/），而且可以在任意路径下操作\n2、依赖性已经讲过了，不再重复。\n3、rpm包手工命令安裝3.1 默认安装位置\n\n\n/etc/\n配置文件安装目录\n\n\n\n/usr/bin/\n可执行的命令安装目录\n\n\n/usr/lib/\n程序所使用的函数库保存位置\n\n\n/usr/share/doc/\n基本的软件使用手册保存位置\n\n\n/usr/share/man/\n帮助文件保存位置\n\n\n3.2 RPM 包安裝\n安装命令\n\n\n\n\n\n\n\n\nrpm - ivh 包全名#注意一定是包全名。如果跟包全名的命令要注意路经，因为软伴包在光盘当中选项：\n\n\n-i   install安装(install）-v  显示更详细的信息 (verbose)-h 打印#显示安装进度(hash)\n\n–nodeps不检测依赖性安装。软件时会检测依赖性，确定所需的底层软件是否安装。如果没有安装则会报错。如果我不管依赖性，想强行安装，可以使用这个选项。注意：这样不检测依赖性安装的软件基本是不能使用的，所以不建议这样做\n–replacefiles 替换文件安装。如果安装软件包，可是包中部分文件己经存在，那么正常安装时           候，会报错“某个文件己经存在”从而导致软件无法安装，使用这个选项可以忽视这个报错，而覆盖安装\n–replacepkgs替换软件包安装。如果软件包己经安装，此选项可以把软件包重复安装一遍。\n–force强制安装。不管是否已经安装，都重新安装。就是–replacefiles和–replacepkgs 的综合。\n–test 测试安装。不会实际安裝，只是检测一下依赖性。\n–prefix 指定安装路径。为安装软件指定安装路径，而不使用默认安装路径。注意：如果指定了安装路径，软件没有安装到系统默认路径中的话，系统会找不到这些安装的软件，需要进行手工配置才能被系统识别。所以rpm 包我们一般都采用默认路径安装。\n\n\n服务启动[root@localhost~]# service 服务名 start|stop|restart|status\n参数:\nstart:启动服务\nstop:停止服务\nrestart:重启服务\nstatus:查看服务状态\n[root@localhost~]# systemctl restart httpd\n#这个命令也行\n3.3 RPM 包升级\n\n[root@localhost~]# rpm -Uvh 包全名\n选项:\n-U（大写）升级安装，如果没有安装过，系统直接安装。如果安装过的版本较旧，则升级到新版本(upgrade）\n[root@localhost~]# rpm - Fvh 包全名\n选项:\n-F（大写）升级安装，如果没有安装过，则不会安装。必须安装有较旧版本，才能升级 (freshen)\n3.4 卸载[root@localhost~]# rpm -e 包名\n选项:\n--nodeps    #不检查依赖性\n-e          #卸载\n\n3.5 查询1）查询软件包是否安装可以查询软件包是否安装，命令格式如下：\n[root@localhost~]# rpm -q 包名\n选项：\n-q：查询 (query)\n2）查询系统中的所有安装软件包可以查询 Linux 系统中所有己经安装的软件包，命令格式如下：\n[root@localhost~]# rpm -qa\n选项：\n-a:  所有 (all)\n当然，可以用管道符来查看所需的内容，比如：\n[root@localhost ~]# rpm -qa | grep httpd\n你会发现，使用“rpm -q 包名”只能查看这个包是否安裝，但是使用“rpm -qa grep 包名”会把包含包名称的所有包都列出来。3）查询软件包的详细信息可以查询己经安装的某个软件包的详细信息，命令格式如下：\n[root@localhost ^]# rpm - qi 包名\n选项：\n-i： 查询软件信息 (information)\n也可以查询还没有安装的软件包的详细信息，命令格式如下：\n[root@localhost ^]# rpm - qip 包全名\n选项：\n-p: 查询没有安装的软件包 (package)\n4）查询软件包中的文件列表可以查询己经安装的软件包中的文件列表和安装的完整目录，命令格式如下：\n[root@localhost ~]# rpm - ql 包名\n选项：\n-l：列出软件包中所有的文件列表和软件所安装的目录 （list)\n那么，可以查询还没有安装的软件包中的文件列表和打算安装的位置吗？答案是可以，命令格式如下：\n[root@localhost ~]# rpm -qlp 包全名\n选项：\n-D: 查询没有安装的软件包信息 (package）\n5）查询系统文件属于哪个 RPM 包既然可以知道每个 RPM 包中的文件的安装位置，那么可以查询系统文件属于哪个 RPM 包吗？当然可以，不过需要注意的是，手工建立的文件是不能查询的，因为这些文件不是通过 RPM 包安装的，当然不能反向查询它属于哪个 RPM包。命令格式如下：\n[root@localhost ~]# rpm - qf 系统文件名\n选项：\n-f：查询系统文件属于哪个软件包（file)\n6）查询软件包所依赖的软件包查询系统中和己经安装的软件包有依赖关系的软件包，命令格式如下：\n[root@localhost ~]# rpm - qR 包名\n选项：\n-R： 查询软件包的依赖性 (requires)\n可以查询没有安装的软件包的依赖性吗？加 “-p”选项即可。例如，查看一下还没有安装的 bind软件包的依赖包，可以执行如下命令：\n[root@localhost ~]# rpm -qRp /mnt/cdrom/Packages/bind-9.8.2-0.10.rcl.el6.i686.rpm\n\n3.6 验证1）基本命令\n[root@localhost ~]#rpm -Va\n选项：\n   - Va 校验本机已经安装的所有软件包\n[root@localhost ~]#rpm -V 已安装的包名\n选项：\n   -V 校验指定RPM包中的文件（verify）\n[root@localhost ~]#rpm -Vf 系统文件名\n选项：\n   -Vf 校验某个系统文件是否被修改\n2）验证举例\n[root@localhost ~]#rpm -V httpd\nS.5....T.            c           /etc/httpd/conf/httpd.conf\n验证内容             文件类型       文件名\n出现提示信息，我们来解释下最前面共有8个信息内容，是表示验证内容的。文件名前面的c是表示这是个配置文件（configuration）。最后是文件名。那么验证内容中的8个信息的具体内容如下：\n\nS  文件大小是否改变\nM  文件的类型或文件的权限（rwx）是否被改变\n5 文件MD5校验和是否改变（可以看成文件内容是否改变）\nD 设备的主从代码是否改变\n L 文件路径是否改变\n U 文件的属主（所有者）是否改变\n G 文件的属组是否改变\nT 文件的修改时间是否改变Apache配置文件的文件类型是c，那么还有那些文件类型呢？\nc 配置文件（config file）\nd 普通文档（documentation）\ng “鬼”文件（ghost file），很少见，就是文件不应该被这个RPM包包含\nl 授权文件（license file）\nr 描述文件（read me）\n\n3.7 数字证书刚刚的校验方法只能对已经安装的RPM包中的文件进行校验，但是如果PRM包本身就被动过手脚，那么校验就不能解决问题了。我们就必须使用数字证书验证了。数字证书有如下特点：\n\n首先必须找到原厂的公钥文件，然后进行安装\n再安装RPM包时，会提取RPM包中的证书信息，然后和本机安装的原厂证书进行验证\n如果验证通过，则允许安装；如果验证不通过，则不允许安装并警告1）数字证书位置那么数字证书在哪里呢？其实在Centos 6.3的第一张光盘中就有，当然它默认也会放在系统中。[root@localhost ~]# ll /mnt/cdrom/RPM-GPG-KEY-CentOS-6\n-r--r--r-- 2 root root 1706 7月    2 04:21   /mnt/cdrom/RPM-GPG-KEY-CentOS-6\n#光盘中的数字证书位置\n\n[root@localhost ~]# ll/etc/pki/rpm-gpg/RPM-GPG-KEY-CentOS-6\n-rw-r--r--. l root root 1706 6月 26 17:29 /etc/pki/rpm-gpg/RPM-GPG-KEY-CentOS-6\n#系统中的数字证书位置\n2）数字证书导入[root@localhost ~]# rpm --import /etc/pki/rpm-gpg/RPM-GPG-KEY-CentOS-6\n选项：\n   --import 导入数字证书\n我们如何查询系统中安装好的数字证书呢？命令如下：[bash@localhost ~]# rpm -qa | grep gpg-pubkey\ngpg-pubkey-c105b9de-4e0fd3a3\n3.8 RPM包中文件的提取1）cpio命令cpio命令主要有三种基本模式：“-o”模式指的是copy-out模式，就是把数据备份到文件库中；“-i”模式指的是copy-in模式，就是把数据从文件库中恢复：“-p”模式指的是复制模式，就是不把数据备份到cpio库中，而是直接复制为其他文件。命令如下：[root@localhost ~]#cpio -o[vcB] > [文件|设备]\n#备份\n选项：\n   -o: copy-out 模式，备份\n   -v: 显示备份过程\n   -c: 使用较新的portable format存储方式\n   -B：设定输入输出块为5120bytes，而不是模式的512butes\n[root@localhost ~]# cpio -i[vcdu] &lt; [文件|设备]\n#还原\n选项：\n   -i: copy-in 模式，还原\n   -v: 显示还原过程\n   -c: 使用较新的portable format存储方式\n   -d: 还原时自动新建目录\n   -u: 自动使用较新的文件覆盖较旧的文件\n[root@localhost ~]#cpio -p 目标目录\n举几个例子吧，先来看看使用cpio备份数据的方法，命令如下：例子：利用find命令找到文件，备份\n[root@localhost ~]# find /etc -print | cpio -ocvB > /root/etc.cpio\n#利用find指定要备份/etc/目录。使用>导出到etc.cpio文件\n[root@localhost ~]# ll -h etc.cpio\n-rw-r--r--. l root root 21M 6月 5 12:29 etc.cpio\n#etc.cpio 文件生成\n再来看看如何恢复cpio的备份数据，命令如下：[root@localhost ~]#cpio -idvcu &lt; /root/etc.cpio\n#还原etc的备份\n#但是如果大家查看下当前目录/root,会发现没有生成etc目录。这是因为备份是/etc目录使用的是绝对路径,所以 恢复的数据直接恢复到了/etc系统目录中,而没有生成在/root/etc中。\n在CentOS 5. x的版本中，是可以利用上面的命令备份与恢复指定的文件。但是到CentOS6. x当中， 需要更加严谨。如果备份时使用绝对路径，则恢复的数据会直接到绝对路径指定的路径中，如果需要 把数据恢复到当前目录中，则需要使用相对路径，例如： 备份：[root@localhost ~]# cd /etc\n#进入/etc目录\n[root@localhost ~]# find . -print | cpio -ocvB > /root/etc. cpio\n#利用find指定要备份/etc/目录,使用〉导出到etc. cpio文件\n恢复：\n[root@localhost~]# cd /root\n#回到/root目录中\n[root@localhost ~]# mkdir etc_test\n#建立恢复测试目录\n[root@localhost ~]# cd etc_test\n#进入测试目录,数据恢复到此\n[root@localhost etc_test]# cpio -idvcu &lt; /root/etc. cpio\n#还原/etc目录的数据,因为备份时使用的是相对路径,则会还原到/root/etc_test/目录下\n最后来演示一下cpio命令的“-p”复制模式，命令如下：[root@localhost]# cd /tmp/\n#进入/tap目录\n[root@localhost tmp]# nn -rf *\n#删除/tap目录中所有数据\n[root@localhost tmp]# mkdir test\n#建立备份目录\n[root@localhost tmp]# find /boot/ -print | cpio -p /tmp/test\n#备份/boot/目录到/tmp/test/目录中\n[root@localhost tmp]# Is test/\nboot\n#在/test目录中备份出了boot目录\n2）提取RPM包中文件[root@localhost ~]#rpm2cpio 包全名 | cpio -idv .文件绝对路径\nrpm2cpio\t←将rpm包转换为cpio格式的命令\ncpio\t←是一个标准工具,它用于创建软件档案文件和从档案文件中提取文件\n举个例子，现在我假设把系统中的/bin/ls命令不小心误删除了，那么我可以修复回来吗？这时有两 种方法修复，要不就是使用—force选项覆盖安装一遍coreutils-8.4-19.el6. i686包，要不就可以使用cpio命令提取出/bin/ls命令文件，再把它拷贝到对应位置就可以了。不过我是怎么知道/bin/ls命令是属于coreutils-8.4-19.el6.i686这个软件包的呢？还记得-qf选项吗？命令如下： [root@localhost ~]#rpm -qf /bin/ls\ncoreutils-8.4-19.el6.i686\n#査看Is文件属于哪个软件包\n那么我们在讲RPM包中文件提取，所以我们使用第二章方法，cpio命令提取出Is命令文件，然 后拷贝到对应位置，命令如下：[root@localhost ~]# mv /bin/ls /root/\n#把/bin/ls命令移动到/root目录下,造成误删除的假象\n[root@localhost ~]#ls\n-bash ls: command not found\n#这时执行ls命令,系统会报错“命令没有找到”\n\n[root@localhost ~]# rpm2cpio /mnt/cdrom/Packages/coreutils-8.4-19.el6.i686. rpm | cpio -idv . /bin/ls\n・/bin/ls\n24772 块\n#提取ls命令文件到当前目录下\n\n[root@localhost ~]#\tcp /root/bin/ls /bin/\n#把提取出来的ls命令文件复制到/bin目录下\n\n[root@localhost\t~]#ls\nanaconda-ks. cfg bin inittab install, log install, log. syslog ls\n#恭喜你,Is命令又可以正常使用了\n4、rpm包在线安装（yum安装）4.1 yum源文件解析yum源配置文件保存在/etc/yum.repos.d/目录中，文件的扩展名一定是”*.repo” 。也就是说， yum源配置文件只要扩展名是“ *.repo ”就会生效。[root@localhost ~]# Is /etc/yum.repos.d/\nCentOS-Base.repo CentOS-Debuginfo.repo CentOS-fasttrack.repo CentOS-Media.repo CentOS-Vault.repo\n这个目录中有5个yum源配置文件，默认情况下CentOS-Base. repo文件生效。我们打开这个文 件看看，命令如下：[root@localhost yum.repos.d]# vim /etc/yum.repos.d/CentOS-Base.repo\n[base]\nname=CentOS-$re1easever - Base\nmirror1ist=http://mirror1ist.centos.org/?release=$releasever&amp;arch=$basearch&amp;\nrepo=os\nbaseurl=http://mirror.centos.org/centos/$releasever/os/$basearch/\ngpgcheck=1\ngpgkey=file:///etc/pki/rpm-gpg/RPM-GPG-KEY-CentOS-6\n…省略部分输出…\n在CentOS-Base. repo文件中有5个yum源容器，这里只列出了 base容器，其他容器和base容器类似。我们解释一下base这个容器。\n[base]:容器名称，一定要放在中。\nname：容器说明，可以自己随便写。\nmirrorlist：镜像站点，这个可以注释掉。\nbaseurl：我们的yum源服务器的地址。默认是CentOS官方的yum源服务器，是可以使用的。 如果你觉得慢，则可以改成你喜欢的yum源地址。\nenabled：此容器是否生效，如果不写或写成enabled=l则表示此容器生效，写成enabled=0 则表示此容器不生效。\ngpgcheck：如果为1则表示RPM的数字证书生效；如果为0则表示RPM的数字证书不生效。\ngpgkey：数字证书的公钥文件保存位置。不用修改。4.2 搭建本地光盘yum源第一步：放入CentOS安装光盘，并挂载光盘到指定位置。命令如下：[root@localhost ~]# mkdir /mnt/cdrom\n#创建cdrom目录,作为光盘的挂载点\n[root@localhost ~]# mount /dev/cdrom /mnt/cdrom/\nmount: block device /dev/srO is write-protected, mounting read-only\n#挂载光盘到/rnnt/cdrom目录下\n第二步：修改其他几个yum源配置文件的扩展名，让它们失效，因为只有扩展名是“ *.repo ”的 文件才能作为yum源配置文件。当然也可以删除其他几个yum源配置文件，但是如果删除了，当你 又想用网络作为yum源时，就没有了参考文件，所以最好还是修改扩展名。命令如下： [root@localhost ~]# cd /etc/yum.repos.d/\n[root@localhost yum.repos.d]# mv CentOS-Base.repo CentOS-Base.repo.bak\n[root@localhost yum.repos.d]# mv CentOS-Debuginfo.repo CentOS-Debuginfo. repo.bak\n[root@localhost yum.repos.d]# mv CentOS-Vault.repo CentOS-Vault.repo.bak\n第三步：修改光盘yum源配置文件CentOS-Media. repo,参照以下方法修改: [root@localhost yum.repos.d]# vim CentOS-Media.repo\n[c6-media]\nname=CentOS-$re1easever - Media\nbaseurl=file:///mnt/cdrom\n#地址为你自己的光盘挂载地址\n#              file:///media/cdrom/\n#              file:///media/cdrecorder/\n#注释这两个不存在的地址\ngpgcheck=1\nenabled=1\n#把enabled=0改为enabled=1,让这个yum源配置文件生效\ngpgkey=file:///etc/pki/rpm-gpg/RPM-GPG-KEY-CentOS-6\n配置完成，现在可以感受一下yum的便捷了。\n\n4.3 yum命令1）査询\n\n査询yum源服务器上所有可安装的软件包列表。[root@localhost yum.repos.d]# yum list\n#査询所有可用软件包列表\nInstalled Packages\n#己经安装的软件包\nConsoleKit.i686 0.4.1-3.el6 @anaconda-Cent0S-201207051201.1386/6.3\nConsoleKit-libs.i686 0.4.1-3.el6 @anaconda-Cent0S-201207051201.i386/6.3 ...省略部分输出... Available Packages #还可以安装的软件包 \n389-ds-base.i686 \n389-ds-base-deve1.i686\n#软件名\n...省略部分输出...\n査询yum源服务器中是否包含某个软件包。[root@localhost yum.repos.d]# yum list 包名\n#査询单个软件包\n例如：\n[root@localhost yum.repos.d]# yum list samba\nAvailable Packages\nsamba.i686\t3.5.10-125.el6\n搜索yum源服务器上所有和关键字相关的软件包。[root@localhost yum.repos.d]# yum search 关键字\n#搜索服务器上所有和关键字相关的软件包\n例如：\n[root@localhost ~]# yum search ifconfig\n己加载插件：fastestmirror, langpacks\nLoading mirror speeds from cached hostfile\n============================== 匹 配 : ifconfig net-tools.x86_64 : Basic networking tools\nyum search搜索可以用于确定某个软件在哪个相关包当中。此例子可以确定“ifconfig”命令 需要安装”net-tools”包。\n査询指定软件包的信息。[root@localhost yum.repos.d]# yum info samba \n#查询samba软件包的信息\nAvailable Packages\t←还没有安装\nName\t:samba\t    ←包名\nArch\t:i686\t    ←适合的硬件平台\nVersion\t:3.5.10     ←版本\nRelease\t:125.el6    ←发布版本\nSize\t:4.9 M\t    ←大小\nRepo\t:c6-media   ←在光盘上\n…省略部分输出…\t\n2）安装[root@localhost yum.repos.d]# yum -y install 包名 \n选项：\n  install\t安装\n  -y\t自动回答yes。如果不加-y,那么每个安装的软件都需要手工回答yes\n例如：\n[root@localhost yum.repos.d]# yum -y install gcc\n#使用yum自动安装gcc\n3）升级[root@localhost yum.repos.d]# yum -y update 包名\n#升级指定的软件包\n选项：\nupdate：\t升级\n-y：\t自动回答yes\n\n注意：在进行升级操作时，yum源服务器中软件包的版本要比本机安装的软件包的版本高。\n[root@localhost yum.repos.d]# yum -y update\n#升级本机所有软件包\n这条命令会升级系统中所有的软件包。不过我们的生产服务器是稳定优先的，所以这种全系统升 级的情况并不多见。4）卸载再次强调一下，除非你确定卸载的软件的依赖包不会对系统产生影响，否则不要执行yum的卸载, 因为很有可能在卸载软件包的同时卸载的依赖包也是重要的系统文件，这就有可能导致系统崩溃。卸 载命令如下：\n[root@localhost yum.repos.d]# yum remove 包名 \n#卸载指定的软件包\n例如：\n[root@localhost yum.repos.d]# yum remove samba \n#卸载samba软件包\n4.4 yum组管理命令\n查询可以安装的软件组\n[root@localhost yum grouplist\n#列出所有可用的软件组列表\n查询软件组内包含的软件\n[root@localhost ~]# yum groupinfo 软件组名\n#列出软件组中包含的软件 \n例如：\n[root@localhost ~]# yum groupinfo \"Web Server*\n#査询软件组”Web Server”中包含的软件\n安装软件组\n[root@localhost ~]# yum groupins tall 软件组名\n#安装指定软件组,组名可以由grouplist査询出来 \n例如：\n[root@localhost ~]# yum groupins tall \"Web Server*\n#安装网页服务软件组\n卸载软件组\n[root@localhost ~]# yum groupremove 软件组名\n#卸载指定软件组\n三、源码包安装1、注意事项1.1 应该选择哪种软件包？\n如果软件包是给大量客户提供访问，建议使用源码包安装，如LAMP环境搭建，因为源码包效率更\n\n如果软件包是给Linux底层使用，或只给少量客户访问，建议使用rpm包安装，因为rpm包简单。\n1.2 源码包是从哪里来的？rpm包是光盘中直接包含的，所以不需要用户单独下载。而源码包是通过官方网站下载的，如果需要 使用，是需要单独下载的。\n1.3 是否可以在系统中即安装rpm包的Apache,又安装源码包的Apache?答案是可以，因为两种安装方法安装的Apache，安装位置是不一样的，例如：\nRPM包：不建议指定安装位置的，建议安装在默认位置(RPM包安装的服务有标准卸载命令，不怕文 件到处安装)\n配置文件：\t/etc/httpd/conf/httpd. conf\n网页位置：\t/var/www/html/\n日志位置：\t/var/log/httpd/\n启动方法：\t1) service httpd restart\n           2) /etc/rc.d/init.d/httpd restart\n源码包：必须制定安装位置(源码包没有安装数据库，没有删除命令)\n配置文件：\t/usr/local/apache2/conf/httpd.conf\n网页文件：\t/usr/local/apache2/htdocs/\n日志位置：\t/usr/local/apache2/logs/\n启动方法：\t/usr/local/apache2/bin/apachectl start\n1.4 生产服务器上，是否会同时安装两种Apache?当然不会啊，因为系统中只有一个80端口，所以你只能启动一个Apache，装多个只能浪费资源。我们建议安装源码包的Apache。\n2、安装过程我们来解释一下源码包安装的具体步骤。(1)下载软件包。(2)解压缩。(3)进入解压目录。(4)./configure    编译前准备这一步主要有三个作用：\n\n在安装之前需要检测系统环境是否符合安装要求。\n\n定义需要的功能选项。/configure支持的功能选项较多，可以执行./configure-help 命令查询其支持的功能。一般都会通过./configure-prefix=安装路径来指定安装路径。\n\n把系统环境的检测结果和定义好的功能选项写入Makefile文件,后续的编译和安装需要依 赖这个文件的内容。需要注意的是.configure不是系统命令，而是源码包软件自带的一个脚本程序，所以必须采用 ./configure方式执行(./代表在当前目录下).(5)make    编译make会调用gcc编译器，并读取Makefile文件中的信息进行系统软件编译。编译的目的就是把源码程序转变为能被Linux识别的可执行文件，这些可执行文件保存在当前目录下。编译过程较为耗时，需要有足够的耐心。(6)make clean：清空编译内容(非必需步骤)。如果在“./configure”或“make”编译中报错，那么我们在重新执行命令前一定要记得执行make clean命令，它会清空Makefile文件或编译产生的”.o”头文件。(7)make install：编译安装这才是真正的安装过程，一般会写清楚程序的安装位置。如果忘记指定安装目录，则可以把这个 命令的执行过程保存下来，以备将来删除使用。\n\n\n3、删除源码包没有删除命令，如果需要删除，直接删除安装目录即可.\n4、打入补丁4.1 补丁的生成[root@localhost ~]# diff 选项 old new\n#比较old和new文件的不同\n选项：\n-a\t将任何文档当做文本文档处理\n-b\t忽略空格造成的不同\n-B\t忽略空白行造成的不同\n-I\t忽略大小写造成的不同\n-N\t当比较两个目录时，如果某个文件只在一个目录中，则在另一个目录中视作空文件\n-r\t当比较目录时，递归比较子目录\n-u\t使用同一的输出格式\n举例\n[root@localhost ~]# mkdir test\n#建立测试目录\n[root@localhost ~]# cd test\n#进入测试目录\n[root@localhost test]# vi old.txt\nour\nschool\nis\nfake\n#文件 old.txt,为了一会输出便于比较,每行分开\n[root@localhost test]# vi new.txt\nour\nschool\nis\nfake\nin\nchendu\n#文件 new.txt\n比较下两个文件的不同，并生成补丁文件“txt.patch”,命令如下：\n[root@localhost test]# diff -Naur /root/test/old.txt /root/test/new.txt > txt.patch #比较两个文件的不同,同时生成txt.patch补丁文件\n[root@localhost test]# vi txt.patch\n#査看下这个文件\n-- /root/test/old.txt 2022-11-23 05:51:14.347954373 +0800\n#前一个文件\n+++ /root/test/new.txt 2022-11-23 05:50:05.772988210 +0800\n#后一个文件\n@@ -2,3 +2,5 @@\nschool\nis\natguigu\n+in\n+beijing\n#后一个文件比前一个文件多两行（+表示）\n4.2 打入补丁[root@localhost test]# patch - pn &lt; 补丁文件\n#按照补丁文件进行更新 \n选项：\n-pn\tn为数字。代表按照补丁文件中的路径，指定更新文件的位置。\n-pn 不好理解，我们说明下。补丁文件是要打入旧文件的，但是你当前所在的目录和补丁文件中的记录的目录是不一定匹配的，所以就需要-pn来同步两个目录。比如我当前是在/root/test目录中（我要打补丁的旧文件就在当前目录下），补丁文件中记录的文件目录为/root/test/old.txt，这时如果写入-pl（在补丁文件目录中取消一级目录） 那么补丁文件就会打入/root/test/root/test/old.txt文件中，这显然是不对的。那如果写入的 是-p2（在补丁文件目录中取消二级目录）那么补丁文件打入的就是/root/test/test/old.txt， 这显然也不对。如果写入的是-p3（在补丁文件目录中取消三级目录）那么补丁文件就是打入的 /root/test/old・txt ,我们的old.txt文件就在这个目录下，所以就应该是-p3。那么我们更新下“old. txt”文件，命令如下：\n[root@localhost test]# patch -p3 &lt; txt.patch \npatching file old.txt \n#给old.txt文件打补丁\n[root@localhost test]# cat old.txt\n#査看下old.txt的内容吧。\nour\nschool\nis\nfake\nin\nchendu\n#多出来了 in chendu两行\n## 四、脚本安装程序\n### 1、脚本程序简介\n脚本程序包并不多见，所以在软件包分类中并没有把它列为一类。它更加类似于Windows下的程序安装，有一个可执行的安装程序，只要运行安装程序，然后进行简单的功能定制选择（比如指定安 装目录等），就可以安装成功，只不过是在字符界面下完成的。\n目前常见的脚本程序以各类硬件的驱动居多，我们需要学习一下这类软件的安装方式，以备将来不时之需。\n### 2、Webmin 安装\n#### 2.1.简介\n我们来看看脚本程序如何安装和使用。安装一个叫作Webmin的工具软件，Webmin是一个基于 Web的系统管理界面。借助任何支持表格和表单的浏览器（和File Manager模块所需要的Java）,你 就可以设置用户账号、apache、DNS、文件共享等。Webmin包括一个简单的Web服务器和许多CGI 程序，这些程序可以直接修改系统文件，比如`/etc/inetd.conf`和`/etc/passwd`。Web服务器和所有的CGI 程序都是用Perl 5编写的，没有使用任何非标准Perl模块。也就是说，Webmin是一个用Perl语言写 的、可以通过浏览器管理Linux的软件。\n\n#### 2.2.安装步骤\n首先下载 Webmin 软件，地址为 http://sourcefoige.net/projects/webadmin/files/webmin/ ，这里下载的是 webmin-1.610.tar.gZ。\n接下来解压缩软件，命令如下：\n​```bash\n[root@localhost ~]# tar -zxvf webmin-1.610.tar.gz\n进入解压目录，命令如下：\n[root@localhost ~]# cd webmin-1.610\n执行安装程序setup.sh,并指定功能选项，命令如下：\n[root@localhost webmin-1.610]# ./setup.sh\n***********************************************************************\n*              welcome to the webmin setup script,version 1.610       *\n*********************************************************************** \nwebmin is web-based interface that allows Unix-like operating systems and common Unix service to be easily administered.\nInstalling Webmin in /root/webmin-1.610 ...\n**********************************************************************\nwebmin uses separate directories for configuration files and log files.\nUnless you want to run multiple versions of webmin at the same time you can just accept the defaults.\n\nConfig file directory [/etc/webmin]:\n#选择安装位置，默认安装在/etc/webmin目录下。如果安装到默认位置，则直接回车\nLog file directory [/var/webmin]:\n\n#日志文件保存位置,直接回车,选择默认位直\n********************************************************************\nWebmin is written entirely in Perl.Please enter the full path to the\nPerl 5 interpreter on your system.\n\nFull path to perl (default /usr/bin/perl):\n#指定Perl语言的安装位置,直接回车,选择默认位置,Perl默认就安装在这里\nTesting Perl ...\nPerl seems to be installed ok\n*********************************************************************\nOperating system name: CentOS Linux\nOperating system version: 6.3\n*********************************************************************\nWebmin uses its own password protected web server to provide access to the administration programs. The setup script needs to know :\n- What port to run the web server on. There must not be another web server already using this port.\n- The login name required to access the web server.\n- The password required to access the web server.\n- If the webserver should use SSL (if your system supports it).\n- Whether to start webmin at boot time.\n\nWeb server port (default 10000):\n#指定Webmin监听的端口 ,直接回车,默认选定10000\nLogin name (default admin):admin\n#输入登录Webmin的用户名\nLogin password:\nPassword again:\n#输入登录密码\nThe Perl SSLeay library is not installed. SSL not available.\n■apache默认没有启动SSL功能,所以SSL没有被激活\nStart Webmin at boot time (y/n):y\n尊是否在开机的同时启动Webmin\n...安装过程省略...\nWebmin has been installed and started successfully. Use your web browser to go to\n\nhttp://localhost:10000/ \n\nand login with the name and password you entered previously.\n#安装完成","slug":"Linux/Linux软件安装","date":"2023-01-05T12:46:00.000Z","categories_index":"Linux","tags_index":"Linux","author_index":"YimooRua"},{"id":"ed524054e4ea66ffb037d331f140784b","title":"Linux之vim编辑器","content":"第二章  vim编辑器一、vi编辑器简介vim 是一个全屏幕纯文本编辑器，是vi编辑器的增强版，我们主要讲解的是 vim 编辑器。可以利用别名让输入vi 命令的时候，实际上执行 vim编辑器，例如：\n[root@localhost ~]# alias vi='vim'\n#定义别名\n这样定义的别名是临时生效，如果需要永久生效，请放入环境变量配置文件（~/.bashrc)\n二、vim 基本使用1、vim 的工作模式vim 工作在三种模式之下：\n \n命令模式：是主要使用快捷键的模式，是我们后面学习的重点。命令模式想要进入输入模式，可以使用以下的方式：\n插入命令\n\n\n\n命令\n作用\n\n\n\na\n在光标所在字符后插入\n\n\nA\n在光标所在行尾插入\n\n\ni\n在光标所在字符前插入\n\n\nI\n在光标所在行行首插入\n\n\no\n在光标下插入新行\n\n\nO\n在光标上插入新行\n\n\n输入模式：主要用于文本编辑，和记事本类似，输入数据就好。末行模式（编辑模式）：\n\n\n\n\n\n\nwarning\n:w #保存不退出:w  #新文件名     把文件另存为新文件:q  #不保存退出:wq #保存退出:!   #强制:q！ #强制不保存退出，用于修改文件之后，不保存数据退出。:wq!   #强制保存退出，当文件的所有者或者 root 用户，对文件没有写权限的时候，强制写入数据使用\n\n\n2、命令模式操作2.1 移动光标1）上下左右移动光标↑、↓、←、→方向键        #移动光标H、j、k、l        #移动光标2）把光标移动到文件头或尾gg  #移动到文件头G   #移动到文件尾（shift+g）3）移动到行首或行尾^    #移动到行首$    #移动到行尾4） 移动到指定行:n    #移动到第几行这里n是数字，准备移动到第几行，就用哪个数字\n2.2 删除或剪切1）删除字母x     #删除单个字母nx    #删除n个字母n 是数字，如果打算从光标位置删除连续的10个字母，可以使用10x 即可。删除字母并不符合使用习惯，我们更习惯在编辑模式中，用Backspace键删除字母。2）删除整行或剪切dd       #删除单行ndd    #删除多行:nl,n2d   #删除指定范围的行  删除整行或多行，这是比较常用的删除方法。这里的 dd 快捷键既是删除，也是剪切。删除内容放入了剪切板，如果不粘贴就是删除，如果粘贴就是剪切。粘贴方法如下：p      #粘贴到光标后p（大）      #粘贴到光标前3）从光标所在行删除到文件尾一直有同学问超哥，是否可以删除整篇文档，vim 没有删除整篇文档的快捷键，但是可以这样：dG    #从光标所在行删除到文件尾d是删除行，C是文件尾，连起来就是从光标所在行删除到文件尾。如果把光标放在文件首，那么dG就变成了删除整篇文档了。\n2.3 复制yy    #复制单行nyy    #复制多行复制之后的粘贴，依然可以使用p键或P（大）键\n2.4 撤销u    #撤销ctrl+r   #反撤销u键能一直撤销到文件打开时的状态，类似 Windows 下 ctrl+z 键的作用。ctrl+r能一直反撤销到最后一次操作状态，类似Windows 下 ctrl+y 键的作用。 下\n2.5 替换Y   #替换光标所在处的字符R   #从光标所在处开始替换字符，按 ESC 结束r   #替换单一字符，不用进入输入模式，实际使用时，比进入输入模式删除后再修改，要方便。\n2.6 vim 配置文件这次末行模式参数设置，多数需要在 vim 中才能生效。\n\n\n\n设置参数\n含义\n\n\n\n:set nu:set nonu\n显示与取消行号。\n\n\n:syntax on:syntax off\n是否依据语法显示相关的颜色帮助。在 Vim 中修改相关的配置文件或Shell 脚本文件时（如前面示例的脚本/etc/init.d/sshd），默认会显示相应的颜色，用来帮助排错。如果觉得颜色产生了干扰，则可以取消此设置\n\n\n:set hlsearch\n设置是否将查找的字符串高亮显示。默认是 set hlsearch 高亮显示\n\n\n:set nohlsearch\n\n\n\n:set ruler:set noruler\n设置是否显示右下角的状态栏。默认是 set ruler 显示\n\n\n:set showmode:set noshowmode\n设置是否在左下角显示如”—INSERT—“ 之类的状态栏。默认是 set showmode 显示\n\n\n:set list:set nolist\n设置是否显示隐藏字符（Tab 键用^I表示，回车符用＄表示）。默认是 nolist 显示。如果使用 set list 显示隐藏字符，类似 cat -A 文件名。\n\n\nvim 支持更多的设置参数，可以通过:set all进行查看。大家会发现，这些设置参数都只是临时生效，一旦关闭文件再打开，又需要重新输入。如果想要永久生效，需要手工建立 vim 的配置文件“~/.vimrc”，把你需要的参数写入配置文件就永久生效了。补充：Windows下回车符在 Linux 中是用^M＄ 符号显示，而不是“＄” 符。这样会导致 Windows下编辑的程序脚本，无法在 Linux 中执行。这时可以通过命令dos2unix，把 windows 格式转为 Linux格式，当然反过来unix2dos命令就是把 Linux 格式转为 Windows 格式。这两个命令默认没有安装，需要手工安装才能使用。\n2.7 查找/查找内容      #从光标所在行向下查找?查找内容      #从光标所在行向上搜索n                   #下一个N                   #上一个\n2.8 替换:1,10s/old/new/g     #替换1到10 行的所有 old 为 new:%s/old/new/g          #替换整个文件的 old 为 new替换字符串，我举几个例子：在 shell 中“#”开头是注释，那我是否可以注释文件的前10 行呢？手工一个一个注释很麻烦，那么批量替换吧：:1,10s/^/#/g       #注释1到10行:1,10s/^#//g       #取消注释而在C语言，PHP 语言等大多数语言中，是使用“//” 开头作为注释的，我们当然可以用 vim 来写这些程序语言脚本，那么批量加入“//” 注释吧：:1,10s/^/\\/\\//g       #1到10 行，行首加入//:1,10s/^\\/\\///g         #取消1到10行行首的//\n三、vim 使用技巧1. 在vim 中导入其他文件内容或命令结果1.1 导入其他文件内容:r 文件名    #把文件内容导入光标位置可以把其他文件的内容导入到光标所在位置\n1.2 在vim 中执行系统命令:！命令   #在vim 中执行系统命令这里只是在 vim 中执行系统命令，但并不把系统命令的结果写入到文件中。主要用于在文件编辑中，查看系统信息，如时间。\n1.3 导入命令结果:r!命令    在vim 中执行系统命令，并把命令结果导入光标所在行在 vim 中执行系统命令，并把命令结果导入光标所在行。\n2.设定快捷键:map 快捷键  #快捷键执行的命令   自定义快捷键vim 允许自定义快捷键，常用的自定义快捷键如下：:map ^p  I#&lt;ESC&gt;    按”ctrl+p”时，在行首加入注释:map ^B ^x   按”ctrl+b”时，删除行首第一个字母（删除注释）注意：^P快捷键不能手工输入，需要执行 ctrl+V+P 来定义，或 ctrl+V，然后 ctrl+P。^B快捷键也是一样\n3.字符替换:ab 源字符  #替换为字符  字符替换在vim编辑中，有时候需要频繁输入某一个长字符串（比如邮箱），这时使用字符串替换，能增加输入效率，例如：:ab mynail shenchao@163. com   当碰到”mymail”时，转变为邮箱注意：“源字符”不应设置的太短，否则有可能影响输入。\n4.多文件打开在vin 中可以同时打开两个文件，只要执行如下命令：\n[root@localhost ~]# vim -o abc bcd\n[root@localhost ~]# vim -0 abc bcd\n#-o  小写o会上下分屏打开两个文件\n#-O  大写O会左右分屏打开两个文件\n这样可以同时打开两个文件，方便操作。如果是”-o”上下打开两个文件，可以通过先按”ctrl+w”，再按”上下箭头”的方式在两个文件之间切换。如果是“-O”左右打开两个文件，可以通过先按“ctrl+w”，再按“左右箭头”的方式在两个文件之间切换。\n","slug":"Linux/vim编辑器","date":"2023-01-04T12:46:00.000Z","categories_index":"Linux","tags_index":"Linux","author_index":"YimooRua"},{"id":"1632a637a5b83536ed0fd61b88270acb","title":"将Hexo部署到阿里云ECS服务器","content":"将Hexo部署到阿里云ECS服务器1.准备工作 在开始部署前，需要准备如下：   1.本地搭建完成的Hexo博客   2.已购买的一台ECS服务器  3.已拥有SSL证书（可以申请免费证书）   4.X-shell连接远程服务器的工具（Mac系统可以用ProtX）\n2.安装配置git2.1安装依赖工具包yum install -y curl-devel expat-devel gettext-devel openssl-devel zlib-devel \n2.2安装编译工具yum install -y gcc perl-ExtUtils-MakeMaker package\n2.3删除旧版gityum remove git -y\n2.4进入根目录cd \n2.5下载git到根目录鉴于下载地址的时效性，附上官网地址,后续git更新请去官网下载安装包。\nwget https://www.kernel.org/pub/software/scm/git/git-2.34.0.tar.gz --no-check-certificate\n如果提示没有wget命令，先安装：\nyum install wget -y\n2.6解压git文件tar -zxf git-2.34.0.tar.gz\n2.7安装git进入git目录下\ncd git-2.34.0\n编译\nmake all prefix=/usr/local/git\n安装git到/usr/local/git下\nmake install prefix=/usr/local/git\n2.8配置git环境变量将git加入PATH目录中\necho 'export PATH=$PATH:/usr/local/git/bin' >> /etc/bashrc\n让配置生效\nsource /etc/bashrc\n查看git是否安装成功\ngit --version\n3.创建用户并配置SSH免密登录3.1创建用户并设置密码这里的username改成你自己的用户名，并且为用户设置一个密码。\nadduser [username]\npasswd [username]\n3.2为用户分配权限把用户添加到wheel组\nusermod [username] -G wheel\n3.3本地创建密钥在本机电脑终端输入：\nssh-keygen -t rsa\n然后一直回车(不用输入)，新建一个密钥。\n一般来说在你创建的时候命令行会提示你密钥文件的路径，windows电脑一般是C:\\Users\\Administrator.ssh\n复制id_rsa.pub文件中的内容备用。\n3.4配置公钥回到服务器终端，切换用户\nsu - [username]\n创建.ssh文件夹\nmkdir .ssh\n新建authorized_keys\nvim .ssh/authorized_keys\n如果提示没有vim，则先安装：\nsudo yum install -y vim\n将刚刚id_rsa.pub公钥中的内容，复制粘贴到文件里，保存退出。\n4.git仓库配置退出用户登录\nexit\n此时应该是root用户，创建git目录，并修改目录的所有权和用户权限\nmkdir /home/git/\nchown -R [username]:[username] /home/git/\nchmod -R 755 /home/git/\n进入目录，建立git仓库，修改权限\ncd /home/git/\ngit init --bare blog.git\nchown [username]:[username] -R blog.git\n新建钩子文件post-receive\nvim /home/git/blog.git/hooks/post-receive\n进入文本编辑器，粘贴下面两行。\n#!/bin/bash\ngit --work-tree=/home/blog --git-dir=/home/git/blog.git checkout -f\n保存退出。然后修改文件权限\nchmod +x /home/git/blog.git/hooks/post-receive\n5.nginx配置首先创建blog目录用户nginx转发\nmkdir /home/blog/\nchown -R [username]:[username] /home/blog/\nchmod -R 755 /home/blog/\n5.1安装nginxyum安装nginx（可以使用安装包安装，这里就不写了）\nyum install -y nginx\n启动nginx\nsystemctl start nginx.service\n查看nginx服务状态，绿色的active说明启动成功\nsystemctl status nginx.service\n设置nginx开机启动\nsystemctl enable nginx.service\n重启服务器\nreboot\n重启后，查看nginx服务状态，绿色的active说明启动成功\nsystemctl status nginx.service\n5.2下载SSL证书打开阿里云控制台SSL证书界面，点击下载按钮选择Nginx版本下载得到.key和.pem两个文件在Nginx文件夹下创建cert文件夹\nmkdir cert\n通过X-shell将文件传入cert文件下\n5.3修改nginx转发配置（包含https）在浏览器中输入服务器公网ip地址，测试是否能打开。找到nginx的conf配置文件，我的是在/etc/nginx/nginx.conf修改配置文件\nvim /etc/nginx/nginx.conf\n找到server，修改如下\nserver &#123;\n          listen       443 ssl http2;\n          listen       [::]:443 ssl http2;\n          #域名\n          server_name  xxxxxx;\n          #博客根目录\n          root         /home/blog;\n\n          index index.html index.htm;\n          #pem文件地址\n          ssl_certificate /etc/nginx/cert/xxxxxxxxxxxx.pem;\n          #key文件地址\n          ssl_certificate_key /etc/nginx/cert/xxxxxxxxxxxx.key;\n          ssl_session_cache shared:SSL:1m;\n          ssl_session_timeout  10m;\n          #加密方式\n          ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:ECDHE:ECDH:AES:HIGH:!NULL:!aNULL:!MD5:!ADH:!RC4;\n          ssl_prefer_server_ciphers on;\n      \n          # Load configuration files for the default server block.\n          include /etc/nginx/default.d/*.conf;\n     \n          error_page 404 /404.html;\n              location = /40x.html &#123;\n          &#125;\n      \n          error_page 500 502 503 504 /50x.html;\n              location = /50x.html &#123;\n          &#125;\n      &#125;\n    #将请求转成https\n      server &#123;\n          listen 80;\n          #域名\n          server_name xxxxxxx;\n          rewrite ^(.*)$ https://$host$1 permanent;\n       &#125;\n重启nginx\nsystemctl restart nginx.service\n查看nginx状态，绿色表示成功！\nsystemctl status nginx.service\n6.在hexo站点配置文件中配置打开本地博客，找到_config.yml文件并打开，修改如下配置\ndeploy:\n  type: git\n  repository: [username]@100.0.0.100:/home/git/blog.git   #用户名@服务器Ip:git仓库位置\n  branch: master\n保存后，输入如下命令将本地博客部署到云服务器上\nhexo clean\nhexo g\nhexo d\n","slug":"Hexo/将Hexo部署到阿里云服务器","date":"2022-12-22T23:11:00.000Z","categories_index":"Hexo","tags_index":"Hexo","author_index":"YimooRua"},{"id":"90e0c478513c4a16991925aa88ef6f99","title":"Linux服务器管理建议","content":"给初学者的 Linux 服务器管理建议一、学习 Linux 的注意事项1. Linux 严格区分大小写Linux 是严格区分大小写的，这一点和 Windows 不一样，所以操作时要注意区分大小写的不同，包括文件名和目录名、命令、命令选项、配置文件设置选项等。\n2. Linux一切皆文件Linux 中所有内容都是以文件的形式保存和管理的，硬件设备也是文件，这和 Windows 完全不同，Windows 是通过设备管理器来管理硬件的。Linux 的设备文件保存在/dev/目录中，硬盘文件是/dev/sd[ a-p ]，光盘文件是/dev/hdc 等。\n3. Linux 不靠扩展名区分文件类型Windows 是依赖扩展名区分文件类型的，比如，“.txt”是文本文件、“.exe”是执行文件、“.ini”是配置文件、“.mp4”是小电影等。但 Linux 不是靠扩展名区分文件类型的，而是靠权限位标识来确定文件类型的，而且文件类型的种类也不像 Windows 下那么多，常见的文件类型只有普通文件、目录、链接文件、块设备文件、字符设备文件等几种。Linux 的可执行文件不过就是普通文件被赋予了可执行权限而已。但 Linux 中的一些特殊文件还是要求写“扩展名”的，但是大家小心，并不是 Linux 一定要靠扩展名来识别文件类型，写这些扩展名是为了帮助管理员来区分不同的文件类型。这样的文件扩展名主要有以下几种。  ⭕️压缩包：Linux下常见的压缩文件名有gZ、.bz2、zip、targz、*.tar.bzz、tgz 等。为什么压缩包一定要写扩展名呢？其实很好理解，如果不写清楚扩展名，那么管理员不容易判断压缩包的格式，虽然有命令可以帮助判断，但是直观一点更加方便。另外，就算没写扩展名，在 Linux 中一样可以解压缩，不影响使用。  ⭕️二进制软件包：Centos 中所使用的二进制安装包是 RPM 包，所有的 RPM 包都用“.rpm”扩展名结尾，目的同样是让管理员一目了然。  ⭕️程序文件：Shell 脚本一般用“.sh”扩展名结尾，其他还有用“*.c”扩展名结尾的C语言文件等。  ⭕️网页文件：网页文件一般使用“*.htm/w*.php”等结尾，不过这是网页服务器的要求，而不是 Linux的要求。\n4. Linux 中所有的存储设备都必须在挂载之后才能使用Linux 中所有的存储设备都有自己的设备文件名，这些设备文件必须在挂载之后才能使用，包括硬盘、U盘和光盘。挂载其实就是给这些存储设备分配盘符，只不过 Windows 中的盘符用英文字母表示,而 Linux中的盘符则是一个已经建立的空目录。我们把这些空目录叫作挂载点（可以理解为 Windows的盘符），把设备文件（如/dev/sdb）和挂载点（已经建立的空目录）连接的过程叫作挂载\n5. Windows 下的程序不能直接在 Linux 中使用Linux 和 Windows 是不同的操作系统，可以安装和使用的软件也是不同的，所以能够在 Windows中安装的软件是不能在 Linux 中安装的。有好处吗？当然有，那就是能够感染 Windows 的病毒和木马都对 Linux 无效。有坏处吗？也有，那就是所有的软件要想在 Linux 中安装，必须单独开发针对 Linux的版本，或者依赖模拟器软件运行。很多软件也会同时推出针对 Windows 和 Linux 的版本，如大家熟悉的即时通信软件 QQ。\n二、服务器管理建议1. 了解Linux目录结构\n\n\n目录名\n目录的作用\n\n\n\n/bin/\n存放系统命令的目录，普通用户和超级用户都可以执行。是/usr /bin/目录的软链接\n\n\n/sbin/\n存放系统命令的目录，只有超级用户才可以执行。是/usr/sbin/目录的软链接\n\n\n/usr/bin/\n存放系统命令的目录，普通用户和超级用户都可以执行\n\n\n/usr/sbin/\n存放系统命令的目录，只有超级用户才可以执行\n\n\n/boot/\n系统启动目录，保存与系统启动相关的文件，如内核文件和启动引导程序(grub)文件等\n\n\n/dev/\n设备文件保存位置\n\n\n/etc/\n配置文件保存位置。系统内所有采用默认安装方式（rpm 安装）的服务配置文件全部保存在此目录中，如用户信息、服务的启动脚本、常用服务的配置文件等\n\n\n/home/\n普通用户的家目录。在创建用户时，每个用户要有一个默认登录和保存自己数据的位置，就是用户的家目录，所有普通用户的宿主目录是在/home/下建立一个和用户名相同的目录。如用户 user1 的家目录就是/home/user1/\n\n\n/lib/\n系统调用的函数库保存位置。是/usr/lib/的软链接\n\n\n/lib64/\n64 位函数库保存位置。是/usr/lib64/的软链接\n\n\n/lost+found/\n当系统意外崩溃或机器意外关机，而产生一些文件碎片放在这里。当系统启动的过程中 fsck 工具会检查这里，并修复己经损坏的文件系统。这个目录只在每个分区中出现，例如/ost+found 就是根分区的备份恢复目录，/boot/lost+found 就是/boot 分区的备份恢复目录\n\n\n/media/\n挂载目录。系统建议是用来挂载媒体设备的，如软盘和光盘\n\n\n/misc/\n挂载目录。系统建议用来挂载 NFS 服务的共享目录。我们在刚刚己经解释了挂载，童鞋们应该知道只要是一个已经建立的空目录就可以作为挂载点。那么系统虽然淮备了三个默认挂载目录/media、/mnt、/misc，但是到底在哪个目录中挂载什么设备都可以由管理员自己决定。例如我刚接触 Linux 的时候，默认挂载目录只有/mnt 一个，所以养成了在/mnt 下建立不同目录挂载不同设备的习惯。如/mnt/cdrom 挂载光盘，/mnt/usb 挂载 U盘，这都是可以的\n\n\n/mnt/\n挂载目录。早期 Linux 中只有这一个挂载目录，并没有细分。现在系统建议这个目录用来挂载额外的设备，如U盘、移动硬盘和其他操作系统的分区\n\n\n/opt/\n第三方安装的软件保存位置。这个目录是放置和安装其他软件的位置，手工安裝的源码包软件都可以安装到这个目录中。不过我还是习惯把软件放到/usr/local/目录中，也就是说，/usr/local/目录也可以用来安装软件\n\n\n/proc/\n虚拟文件系统。该目录中的数据并不保存在硬盘上，而是保存到内存中。主要保存系统的内核、进程、外部设备状态和网络状态等。如/proc/cpuinfo是保存 CPU信息的，/proc/devices 是保存设备驱动的列表的，/proc/filesystems 是保存文件系统列表的，/proc/net 是保存网络协议信息的\n\n\n/sys/\n虚拟文件系统。和/proc/目录相似，该目录中的数据都保存在内存中，主要保存与内核相关的信息\n\n\n/root/\nroot 的宿主目录。普通用户宿主目录在/home/下，root 宿主目录直接在“/”下\n\n\n/run/\n系统运行时产生的数据，如 ssid，pid 等相关数据。/var/run/是此目录的软链接\n\n\n/srv/\n服务数据目录。一些系统服务启动之后，可以在这个目录中保存所需要的数据\n\n\n/tmp/\n临时目录。系统存放临时文件的目录，在该目录下，所有用户都可以访问和写入。\n\n\n/usr/\n我们建议此目录中不能保存重要数据，最好每次开机都把该目录清空系统软件资源目录。注意 usr 不是 user 的缩写，而是“UNIX Software Resource*”的缩写，所以不是存放用户数据的目录，而是存放系统软件资源的目录。系统中安装的软件大多数保存在这里\n\n\n/usr/lib/\n应用程序调用的函数库保存位置\n\n\n/usr/local/\n手工安装的软件保存位置。我们一般建议源码包软件安装在这个位置\n\n\n/usr/share/\n应用程序的资源文件保存位置，如帮助文档、说明文档和字体目录\n\n\n/usr/src/\n源码包保存位置。我们手工下载的源码包和内核源码包都可以保存到这里。不过我更习惯把手工下载的源码包保存到/usr/local/src/目录中，把内核源码保存到/usr/src/kernels/目录中\n\n\n/usr/src/kernels/\n内核源码保存位置\n\n\n/var/\n动态数据保存位置。主要保存缓存、日志以及软件运行所产生的文件\n\n\n/var/www/html/\nRPM 包安装的 Apache 的网页主目录\n\n\n/var/lib/\n程序运行中需要调用或改变的数据保存位置。如 MysQL 的数据库保存在/var/lib/mysql/目录中\n\n\n/var/log/\n系统日志保存位置\n\n\n/var/run/\n一些服务和程序运行后，它们的 PID（进程ID） 保存位置。是/run/目录的软链接\n\n\n/var/spool/\n放置队列数据的目录。就是排队等待其他程序使用的数据，比如邮件队列和打印队列\n\n\n/var/spool/mail/\n新收到的邮件队列保存位置。系统新收到的邮件会保存在此目录中\n\n\n/var/spool/mail/\n系统的定时任务队列保存位置。系统的计划任务会保存在这里\n\n\n2. 远程服务器关机及重启时的注意事项为什么远程服务器不能关机呢？很简单，远程服务器没有放置在本地，关机后，谁可以帮你按开机电源键启动服务器？虽然计算机技术日新月异，但是像插入电源和开机这样的工作还是需要手工进行的。如果服务器在远程，一旦关机，就只能求助托管机房的管理人员帮你开机了。远程服务器重启时需要注意两点。\n2.1 远程服务器在重启前，要中止正在执行的服务计算机的硬盘最怕在高速存储时断电或重启，非常容易造成硬盘损坏。所以，在重启前先中止你的服务，甚至可以考虑暂时断开对外提供服务的网络。可能你会觉得服务器有这么娇贵吗？我的笔记本电脑经常强行关机，也没有发现硬盘损坏啊？这是因为你的个人计算机没有很多人访问，强制断电时硬盘并没有进行数据交换。小心驶得万年船！\n2.2 重启命令的选用Linux 可以识别的重启命令有很多条，但是建议大家使用 “shutdown -r now” 命令重启。这条命令在重启时会正常保存和中止服务器中正在运行的程序，是安全重启命令。而且最好在重启前执行几次“sync” 命令，这条命令是数据同步命令，可以让暂时保存在内存中的数据同步到硬盘上。\n3.不要在服务器访问高峰运行高负载命令这一点大家很好理解，在服务器访问高峰，如果使用一些对服务器压力较大的命令，则有可能会造成服务器响应缓慢甚至死机。哪些命令是高负载命令呢？其实，如果 大家使用过 Windows 操作系统，则也会留意到一些操作会给计算机带来较大的运算压力，道理都是一样的，如复制大量的数据、压缩或者解压缩大文件、大范围的硬盘搜索等。什么时间算作访问高峰期呢？我们一般认为 17:00—24:00 算作访问高峰期。当然，每台服务器具体提供的服务不同，访问高峰期有时也会有所出入。比如，服务器主要是供美国人民访问的，那就要考虑时差的问题；或者服务器提供的服务很特殊，访问高峰期可能也不同。一般我们建议在凌晨4:00—5:00执行这些命令。那是不是说我们需要在凌晨上班？当然不是，这谁受得了啊？我们可以使用系统的计划任务，让操作自动在指定的时间段执行。\n4. 远程配置防火墙时不要把自己踢出服务器简单来讲，防火墙就是根据数据包自身的参数来判断是否允许数据包通过的网络设备。我们的服务器要想在公网中安全地使用，就需要使用防火墙过滤有害的数据包。但是在配置防火墙时，如果管理员对防火墙不是很熟悉，则有可能把自己的正常访问数据包和有害数据包全部过滤掉，导致自己也无法正常登录服务器，如防火墙关闭了远程连接的 SSH 服务的端口。防火墙配置完全是靠手工命令完成的，配置规则和配置命令相对也比较复杂，万一设置的时候心不在焉，悲剧就发生了。如何避免这种尴尬的情况发生呢？最好的方法当然是在服务器本地配置防火墙，这样就算不小心把自己的远程登录给过滤了，还可以通过本机登录来进行恢复。如果服务器已经在远程登录了，要配置防火墙，那么最好在本地测试完善后再进行上传，这样会把发生故障的概率降到最低。虽然在本地测试好了，但是传到远程服务器上时仍有可能发生问题。于是我想到一个笨办法：如果需要远程配置防火墙，那么先写一个系统定时任务，让它每5分钟清空一下防火墙规则，就算写错了也还有反悔的机会，等测试没有问题了再删除这个系统定时任务\n5. 指定合理的密码规范并定期更新前面我们介绍了设置密码需要遵守复杂性、易记忆性和时效性的三原则，这里就不再重复解释了。\n6. 合理分配权限服务器管理有一个最简单的原则：给子用户最小的权限。\n7.定期备份重要数据和日志备份的基本原则：不要把鸡蛋放在同一个篮子里\n","slug":"Linux/Linux服务器管理建议","date":"2022-12-22T09:00:00.000Z","categories_index":"Linux","tags_index":"Linux","author_index":"YimooRua"},{"id":"95e120b1454847e4d8ec9eb3b97066cd","title":"Java集合学习笔记","content":"一、Java 集合框架概述1.一方面，而向对象语言对事物的体现都是以对象的形式，为了方便对多个对象的操作，就要对对象进行存储。另一方而，使用Array存储对象方面具有一些弊端，而Java 集合就像一种容器，可以动态地把多个对象的引用放入容器中。＞数组在内存存储方面的特点：数组初始化以后，长度就确定了。数组声明的类型，就决定了进行元素初始化时的类型＞数组在存储数据方面的弊端：数组初始化以后，长度就不可变了，不便于扩展数組中提供的属性和方法少，不便于进行添加、删除、插入等操作，且效率不高，同时无法自接获取存储元素的个数数组存储的数据是有序的、可以重复的。—&gt;存储数据的特点单一2.Java 集合类可以用于存储数量不等的多个对象，还可用于保存具有映射关系的关联数组。\n二、Java集合框架1.Java 集合可分为 Collection 和 Map 两种体系Collection接口：单列数据，定义了存取一组对象的方法的集合  List：元素有序、可重复的集合  Set：元素无序、不可重复的集合Map接口：双列数据，保存具有映射关系“key-value对”的集合\n2.Collection接口继承树\n|—-ColLlection接口：学列案合，用来存储一个一个的对家           |—-List接口：存储有序的、可重复的数据。–&gt;“动态”数组           |—-Set接口：存储无序的、不可更友的数捂–＞高中讲的”集合“\n \n3.Map接口继承树\n|—-Map 供口：双列集台，用来存储一对(key - vaLue)一对的数据 –&gt;高中函数：y=f(x)\n \n三、Collection接口中常用的方法常用方法1：add()添加元素到集合中常用方法2：size()集合长度常用方法3：addAll()添加集合的元素到集合中常用方法4：isEmpty()判断当前元素是否为空！常用方法5：clear()清空元素常用方法6：contains(Object object):判断当前集合中是否包含obj;常用方法7：containsAll()判断形参collection中的所有元素是否都存在于当前集合中常用方法8：remove()移除对象，返回true和false常用方法9：removeAll()从当前集合移除另一个集合中相同的所有元素，求差集常用方法10：retainAll()求交集常用方法11：equals() 一个一个元素的比较，ArrayList是顺序比较常用方法12：hashCode():返回当前对象的哈希值常用方法13：toArray()把集合变成数组常用方法14：数组转换成集合\n@Test\n    public void test1() &#123;\n        //声明一个ArrayList()集合\n        Collection collection = new ArrayList&lt;>();\n        //常用方法1：add()添加元素到集合中\n        collection.add(\"AA\");\n        collection.add(\"BB\");\n        collection.add(123);\n        collection.add(new Date());\n        //常用方法：size()集合长度\n        System.out.println(collection.size());//4\n        Collection collection1 = new ArrayList();\n        collection1.add(\"DD\");\n        //常用方法3：addAll()添加集合的元素到集合中\n        collection1.addAll(collection);\n        System.out.println(collection1.size());//5\n        System.out.println(collection1);//[DD, AA, BB, 123, Mon Aug 15 18:50:35 CST 2022]\n        //常用方法4：isEmpty()判断当前元素是否为空！\n        System.out.println(collection.isEmpty());//false\n        //常用方法5：clear()清空元素\n        collection.clear();\n        System.out.println(collection.isEmpty());\n        System.out.println(collection.size());\n    &#125;\n\n    @Test\n    public void test2() &#123;\n        Collection collection = new ArrayList();\n        collection.add(123);\n        collection.add(456);\n        collection.add(new String(\"Tom\"));\n        collection.add(false);\n        Person person = new Person(\"yimoo\", 25);\n        collection.add(person);\n        collection.add(new Person(\"yimoo\", 25));\n        //常用方法6：contains(Object object):判断当前集合中是否包含obj;\n        //向Collection接口的实现类的对象中添加数据obj时，要求obj所在的类要重写equals();\n        boolean flag = collection.contains(false);\n        System.out.println(flag);//true\n        //比较的是对象里的内容\n        System.out.println(collection.contains(new String(\"Tom\")));//true\n        System.out.println(collection.contains(person));//true\n        //常用方法7：containsAll()判断形参collection中的所有元素是否都存在于当前集合中\n        Collection collection1 = Arrays.asList(123, 456);//快速创建集合\n        System.out.println(collection.containsAll(collection1));//true\n        //常用方法8：remove()移除对象，返回true和false\n        System.out.println(collection.remove(123));//true,会调用equals方法判断对象是否存在\n        //常用方法9：removeAll()从当前集合移除另一个集合中相同的所有元素，求差集\n        Collection collection2 = Arrays.asList(456, 789);\n        collection.removeAll(collection2);\n        System.out.println(collection);//[Tom, false, Person&#123;name='yimoo', age=25&#125;, Person&#123;name='yimoo', age=25&#125;]\n    &#125;\n\n    @Test\n    public void test3() &#123;\n        Collection collection = new ArrayList();\n        collection.add(123);\n        collection.add(456);\n        collection.add(new String(\"Tom\"));\n        collection.add(false);\n        Collection collection1 = Arrays.asList(123, 456, 789);\n        //常用方法10：retainAll()求交集\n        collection.retainAll(collection1);\n        System.out.println(collection);//[123, 456]\n        //常用方法11：equals() 一个一个元素的比较，ArrayList是顺序比较\n        Collection collection2 = Arrays.asList(456, false);\n        System.out.println(collection.equals(collection2));//false\n    &#125;\n\n    @Test\n    public void test4() &#123;\n        Collection collection = new ArrayList();\n        collection.add(123);\n        collection.add(456);\n        collection.add(new String(\"Tom\"));\n        collection.add(false);\n        //常用方法12：hashCode():返回当前对象的哈希值\n        System.out.println(collection.hashCode());//7639761\n        //常用方法13：toArray()把集合变成数组\n        Object[] arrs = collection.toArray();\n        for (int i = 0; i &lt; arrs.length; i++) &#123;\n            System.out.print(arrs[i] + \" \");//123 456 Tom false\n        &#125;\n        System.out.println();\n        //常用方法14：数组转换成集合\n        List list = Arrays.asList(arrs);\n        System.out.println(list);\n        //注意以下情况：如果将int类型数组转换为集合，直接放值即可或者使用Integer包装类\n        List arr1 = Arrays.asList(new int[]&#123;123, 456&#125;);\n        System.out.println(arr1.size());//1\n        List arr2 = Arrays.asList(123, 456);\n        System.out.println(arr2.size());//2\n        List arr3 = Arrays.asList(new Integer[]&#123;123, 456&#125;);\n        System.out.println(arr3.size());//2\n\n    &#125;\n\n四、使用 Iterator 接门遍历集合元素\nIterator对象称为迭代器(设计模式的一种)，主要用于遍历 Collection 集合中的元素。\nGOF给迭代器模式的定义为：捉供一种方法访问一个容器(container)对象中各个元素，而又不需暴露该对象的内部细节。迭代器模式，就是为容器而生。类似于“公交车上的售票员”、“火车上的乘务员”、“空姐”\nCollection接口继承了java.lang.Iterable 接口，该接口有一个iterator()方法，那么所有实现了 Collection接口的集合类都有一个iterator()方法，用以返回一个实现了Iterator接口的对象。\nIterator 仅用于遍历集合，Iterator 本身并不提供承装对象的能力。如果需要创建Iterator 对象，则必须有一个被迭代的集合。\n集合对象每次调用iterator()方法都得到一个全新的迭代器对象，默认游标都在集合的第一个元素之前。\nhasNext()、next()、remove()三种常用方法\n\n@Test\npublic void test() &#123;\n    Collection collection = new ArrayList();\n    collection.add(123);\n    collection.add(456);\n    collection.add(new String(\"Tom\"));\n    collection.add(false);\n    //创建iterator对象，不是容器\n    Iterator iterator = collection.iterator();\n    //遍历集合元素方式一：\n    //System.out.println(iterator.next());//123\n    //System.out.println(iterator.next());//456\n    //遍历集合元素方式二：\n    //hasNext()判断是否还有下一个元素\n    while (iterator.hasNext()) &#123;\n      //next() ①指针下移 ②将下移以后的集合位置上的元素返回\n        System.out.println(iterator.next());\n    &#125;\n&#125;\n\n//remove()删除集合中的一个元素\nwhile(iterator.hasNext())&#123;\n    Object o=iterator.next();\n    if(\"Tom\".equals(o))&#123;\n        iterator.remove();\n    &#125;\n&#125;\nSystem.out.println(collection.size());//3\n\n五、Collection子接口之一：List接口List接口概述\n\n 鉴于Java中数组用来存储数据的局限性，我们通常使用List替代数组\n List集合类中元素有序、且可重复，集合中的每个元素都有其对应的顺序索引。\n List容器中的元素都对应一个整数型的序号记载其在容器中的位置，可以根据序号存取容器中的元素。\n JDK API中List接口的实现类常用的有：ArrayList、 LinkedList利Vector。\n\n面试题：\nArrayList、 LinkedList、 Vector三者的异同？\n同：三个类都是实现了List接口，存储数据的特点相同：存储有序的、可重复的数据\n异：① ArrayList：作为List接口的主要实现类；线程不安全的，效率高；底层使用object[] elementData 存储\n​        ② LinkedList：对于频繁的插入，删除操作，使用此类效率比ArrayList高；底层使用双向链表存储\n​        ③ Vector：作为List接口的古老实现类；线程安全的，效率低；底层使用Object[] elementData存储\n1.ArrayList的源码分折jdk 7情况下\n\nArrayList List = new Arraylist();//底层创建了长度是10的object[]数组elementData\nList.add(123);//elementData[0] = new Integer (123)；\n…\nList.add(11);//如果此次的添加导致底层elementData数组容量不够，则扩容。\n默认情况下，扩容为原来的容量的1.5倍，同时需要将原有数组中的数据复制到新的数组中。\n\n结论：建议开发中使用带参的构造器：ArrayList list = new ArrayList(int capacity)\njdk 8 中ArrayList的变化：\n\nArrayList list = new ArrayList(); //底层object[] eLementData初始化为{}.并没有创建长度为10的数组\n\nList.add(123);//第一次调用add()时，底层才创建了长度10的数组，并将数据123添加到elementData[0]\n\n…后续的添加和扩容操作与jdk 7无异。\n==小结：jdk7中的ArrayList的对象的创建类似于单例的饿汉式，而jdk8中的ArrayList的对象的创建类似于单例的懒汉式，延迟了数组的创建，节省内存。==\n\n\n2.LinkedList源码分析LinkedList List = new Linkedlist()；內部声明了Node 类型的first和Last属性，默认值为nullList.add(123)；//将123封装到Node中，创建了Node 对象。\n其中，Node 定义为：体现了LinkedList的双向链表的说法\nprivate static class Node&lt;E> &#123;\n    E item;\n    Node&lt;E> next;\n    Node&lt;E> prev;\n\nNode (Node&lt;E> prev, E element, Node&lt;E〉 next) &#123;\nthis.item = element;\nthis.next = next;\nthis.prev = prev;\n&#125;\n\n \n3.Vector的源码分折jdk7利jdk8中通过Vector()构造器创建对象时，底层都创建了长度为10的数组.\n在扩容方面，默以扩容为原来的数组长度的2倍。\nList集合中常用的方法1.void add(int index, Object ele)：在index位置插入ele元素2.boolean addALL(int index, CoLLection eles)：从index位置开始将eLes 中的所有元素添加进来3.Object get(int index)：获取指定index 位置的元素4.int indexof (Object obj)：返回obj在集合中首次出现的位置5.int LastIndexof(Object obj)：返回obj在当前集合中末次出现的位置6.Object remove(int index)：移除指定index位置的元素，并返回此元素7.Object set(int index, Object ele)：设置指定index位置的元素为ele8.List subList(int fromIndex, int toIndex)：返回从fromIndex到toIndex位置的子集合\n总结常用方法    增：add()、、删：remove() / removeAll()、改：set()、查：get()、插：add(int index,Object ele)、\n长度：size()、遍历：①Iterator迭代器方式 ②增强for循环 ③普通的循环、\n @Test\n    public void test() &#123;\n        ArrayList arrayList = new ArrayList();\n        arrayList.add(123);\n        arrayList.add(456);\n        arrayList.add(\"AA\");\n        arrayList.add(new Person(\"Tom\", 12));\n        arrayList.add(456);\n        System.out.println(arrayList);//[123, 456, AA, Person&#123;name='Tom', age=12&#125;, 456]\n        System.out.println(\"**********************************\");\n//        void add(int index, Object ele)：在index位置插入ele元素\n        arrayList.add(2, \"Yimoo\");\n        System.out.println(arrayList);//[123, 456, Yimoo, AA, Person&#123;name='Tom', age=12&#125;, 456]\n        System.out.println(\"**********************************\");\n//        boolean addALL(int index, CoLLection eles)：从index位置开始将eLes 中的所有元素添加进来\n        Collection collection = Arrays.asList(\"杨皓\", \"穷逼\");\n        boolean flag = arrayList.addAll(collection);\n        if (flag) &#123;\n            System.out.println(\"插入成功！\\n\" + arrayList);\n          //插入成功！[123, 456, Yimoo, AA, Person&#123;name='Tom', age=12&#125;, 456, 杨皓, 穷逼]\n        &#125;\n        System.out.println(\"**********************************\");\n//        Object get(int index)：获取指定index 位置的元素\n        System.out.println(arrayList.get(3));//AA\n        System.out.println(\"**********************************\");\n//        int indexof (Object obj)：返回obj在集合中首次出现的位置\n        System.out.println(arrayList.indexOf(\"杨皓\"));//6\n        System.out.println(\"**********************************\");\n//        int LastIndexof(Object obj)：返回obj在当前集合中末次出现的位置\n        System.out.println(arrayList.lastIndexOf(\"456\"));//-1\n        System.out.println(\"**********************************\");\n//        Object remove(int index)：移除指定index位置的元素，并返回此元素\n        System.out.println(arrayList.remove(1));//456\n        System.out.println(arrayList);\n      //[123, Yimoo, AA, Person&#123;name='Tom', age=12&#125;, 456, 杨皓, 穷逼]\n        System.out.println(\"**********************************\");\n//        Object set(int index, Object ele)：设置指定index位置的元素为ele\n        arrayList.set(6, \"高富帅\");\n        System.out.println(arrayList);\n      //[123, Yimoo, AA, Person&#123;name='Tom', age=12&#125;, 456, 杨皓, 高富帅]\n        System.out.println(\"**********************************\");\n//        List subList(int fromIndex, int toIndex)：返回从fromIndex到toIndex位置的子集合\n        System.out.println(arrayList.subList(2, 4));//[AA, Person&#123;name='Tom', age=12&#125;]\n    &#125;\n\n六、Collection子接口之二：Set 接口\nSet接口是Collection的子接口，set接口没有提供额外的方法\nSet 集合不允许包含相同的元素，如果试把两个相同的元素加入同一个Set 集合中，则添加操作失败。\nSet 判断两个对象是否相同不是使用三元运算符，而是根据 equals() 方法\n\nSet：存储无序的、不可重复的数据以HashSet 为例说明：1.无序性：不等于随机性。存储的数据在底层数组中并非按照数组索引的顺序添加，而是根据数据的哈希值决定\n2.不可重复性：保证添加的元素按照equals()判断时，不能返回true.即：相同的元系只能添加一个。\nSet接口的实现类：\nHashSetHashSet：作为Set接口的主要实现类；线程不安全的；可以存储null值；\n\nHashset 是 Set 接口的典型实现，大多数时候使用 Set 集合时都使用这个买现类。\n\nHashSet 按 Hash 算法来行储集合中的元东，因此具有很好的存取、查找、删除性能。\n\nHashSet 具有以下特点：   ＞不能保证元素的排列顺序   ＞HashSet 不是线程安全的   ＞集合元素可以是 null\n\nHashSet 集合判断两个元素相等的标准：两个对象通过 hashCode() 方法比较相等，并且两个对象的 equals() 方法返回值也相等。\n\n对于存放在Set容器中的对象，对应的类一定要重写equals()和hashCode(Object obj)方法，以实现对象相等规则。即：“相等的对象必须具有相等的散列码”\n\n二、添加元素的过程：\n\n\n\n\n\n\n\n\n\n以HashSet为例：我们向HashSet 中添加元素a，首先调用元素a所在类的hashCode() 方法，计算元素a的哈希值，此哈希值接着通过某种算法计算出在HashSet 底层数组中的存放位置（即为：素引位置），判断数组此位置上是否已经有元素：如果此位置上没有其他元素，则元素a添加成功。—&gt;情况1如果此位置上有其他元素b(或以链表形式存在的多个元素），则比较元素a与元素b的hash值：如果hash值不相同，则元素a添加成功。—＞情况2如果hash值相同，进而需要调用元素a所在类equlas()方法：equals()返回true，元素a添加失败equals()返回false，刚元素添加成功。—&gt;情况2对于添加成功的情况2和情况3而言：元素a与己经存在指定索引位置上数据以链表的方式存储。jdk 7:元素放到数组中，指向原来的元素，jdk 8：原来的元素在数组中，指向元素a总结：七上八才\n\n\n 以Eclipse/IDEA为例，在自定义类中可以调用工具自动重写equals利hashCode。 问题：为什么用Eclipse/IDEA复写hashsode方法，有31这个数字？\n\n\n\n\n\n\n\n\n\n选择系数的时候要选择尽量大的系数。因为如果计算出来的hash地址越大，所谓的“冲突”就越少，查找起来效率也会提高。（减少冲突）并且31只占用5bits,相乘造成数据溢出的概率较小。31可以由*31==(1&lt;&lt;5)-1来表示,现在很多虚拟机里面都有做相关优化。（提高算法效率）31是一个素数，素数作用就是如果我用一个数字来乘以这个素数，那么最终出来的结果只能被素数本身和被乘数还有1来整除！（减少冲突）\nLinkedHashSetLinkedHashSet：作为HashSet的子类；遍历其内部数据时，可以按照添加的顺序遍历；\n对于频繁的遍历操作，LinkedHashSet效率高于HashSet\nTreeSet（了解）TreeSet：可以按照添加对象的指定属性，进行排序。\n两种排序方式：自然排序（实现Comparable接口）和定制排序\n自然排序中，比较两个对象是否相同的标准为：compareTo(）返回0.不再是equals(）。\n定制排序中，比较两个对象是否相同的标准为：compare(）返回0.不再是equals().\n练习\npublic static List duplicateList(List list) &#123;\n    HashSet set = new HashSet();\n    set.addAll(list);\n    return new ArrayList(set);\n&#125;\n\n//练习1：在list內去除重复数字值，要求尽量简单\n@Test\npublic void test2() &#123;\n    List list = new ArrayList();\n    list.add(new Integer(1));\n    list.add(new Integer(1));\n    list.add(new Integer(2));\n    list.add(new Integer(2));\n    list.add(new Integer(3));\n    list.add(new Integer(4));\n    list.add(new Integer(5));\n    list.add(new Integer(5));\n    List list1 = duplicateList(list);\n    for (Object integer : list1) &#123;\n        System.out.println(integer);\n    &#125;\n&#125;\n\n//面试题:说说以下的输出\n//其中Person类中重写了hashCode()和equal()方法\n@Test\npublic void test3()&#123;\n    HashSet set = new HashSet();\n    Person p1 = new Person(1001,\"AA\");\n    Person p2 = new Person(1002,\"BB\");\n    set.add(p1);\n    set.add(p2);\n    System.out.println(set);//[Person&#123;num=1002, grade='BB'&#125;, Person&#123;num=1001, grade='AA'&#125;]\n    p1.setGrade(\"CC\");\n    set.remove(p1);\n    System.out.println(set);//[Person&#123;num=1002, grade='BB'&#125;, Person&#123;num=1001, grade='CC'&#125;]\n    set.add(new Person(1001,\"CC\"));\n     System.out.println(set);//[Person&#123;num=1002, grade='BB'&#125;, Person&#123;num=1001, grade='CC'&#125;, Person&#123;num=1001, grade='CC'&#125;]\n    set.add(new Person(1001,\"AA\"));\n    System.out.println(set);//[Person&#123;num=1002, grade='BB'&#125;, Person&#123;num=1001, grade='CC'&#125;, Person&#123;num=1001, grade='CC'&#125;, Person&#123;num=1001, grade='AA'&#125;]\n&#125;\n\n七、Map接口各实现类的特点Map：双列数据，存儲key-value对的数格 类似于高中的函数：y=f(x）\n**HashMap:**作为Map的主要实现类：线程不安全的，效率高；可以存储null 的key和vaLue。HashMap 的底层：数组+链表 （jdk7及之前）数组+ 链表+红黑树 (jdk 8)\n**LinkedHashMap:**保证在遍历map 元素时，可以按照添加的顺序实现遍历。原因：在原有的HashNap底层结构基磁上，添加了一对指针，指向前一个和后一个元素。对于频繁的遍历操作，此类执行效率高于HashMap。\n TreeMap：保证按照添加的key-vaLue对进行排序，实现排序遍历，此时考虑key的自然排序和定制排序 ，底层使用红黑树\nProperties:常用来处理配置文件。key 和value都是String类型\n面试题：\n1.HashMap的底层实现原理？（高频）以jdk7为例说明：\nHashMap map = new HashMap();在实例化以后，底层创建了长度是16的一维数组Entry[] table.…可能已经执行过多次put…map.put (key1, value1)：首先，调用key1所在类的hashCode()计算key1哈希值，此哈希值经过其种算法计算以后，得到在Entry数组中的存放位置。如果此位置上的数据为空，此时的key1-value1添加成功。—-情况1如果此位置上的数据不为空，（意味着此位置上存在一个或多个数据(以链表形式存在)，比较key1和己经存在的一个或多个數据的哈希值：如果key1的哈希值与已经存在的数据的哈希值都不相同，此时key1-value1添加成功。—-情况2如果key1的哈希值和己经存在的某一个数据(key2-value2)的哈希值相同，继续比较：调用key1 所在类的equals(key2).如果equals()返回false：此ikey1-value1 添加成功。—- 情况3如果equals()返回true：使用value1替换value2。(put()不仅有添加的功能还有替换的功能)\n补充：关于情况2和情况3：此的key1-value1 和原来的数据以链表的方式存储。\n在不断的添加过程中，会涉及到扩容问题，默认的扩容方式：扩容为原来容量的2倍，并将原有的数据复制过来。\njdk8 相较于jdk7在底层实现方面的不同：1.new HashMap()：底层没有创建一个长度为16的数组2.jdk 8底层的效组是：Nodel].而非Entry[]3.首次调用put(）方法时，底层创建长度为16的数组4.jdk7底层结构只有：数组+链表。jdk8中底层结肉：数绍+链表+红票树。    当数组的某一个索引位置上的元素以链表形式存在的数据个数＞8 且当前数組的长度＞64时，    此时此索引位置上的所有数据改为便用红黑树存储。\n2.谈谈你对HashMap中put/get方法的认识？如果了解再谈谈HashMap的扩容机制？默认大小是多少？什么是负载因子(或填充比)？什么是吞吐临界值(或闵值、threshold)?\n3.HashMap与Hashtable的异同？（低频）\n4.CurrentHashMap与Hashtable的异同？（后续）\nMap结构的理解\nMap中的key:无序的、不可重复的，使用Set存储所有的key；key 所在的类要重写equals() 和HashCode() ( 以HashMap为例）\nMap中的value：无序的、可重复的，便用collection存储所有vaLue  –&gt;vaLue 所在的类要重写equals()\n一个键值对：key-value组成了一个Entry 对象；\nMap中的entry：无序的、不可重复的，使用Set存储所有的entry\n\n \nHashMap源码中的重要常量DEFAULT INITIAL CAPACITY:HashMap的默认容量，16MAXIMUM CAPACITYHashMap的最大支持容量，2^30DEFAULT LOAD FACTOR: HashMap的默认加载因子TREEIFY_ THRESHOLD：Bucket中链表长度大于该默认值，转化为红黑树UNTREEIFY THRESHOLD：Bucket中红黑树存储的Node小于该默认值，转化为链表MIN_TREEIFY_CAPACITY：桶中的Node被树化时最小的hash表容量。（当桶中Node的数量大到需要变红黑树时，若hash表容量小于MIN_TREEIFY_CAPACITY时，此时应执行resize扩容操作这个MIN_TREEIFY_CAPACITY的值至少是TREEIFY_THRESHOLD的4倍。）table：存储元素的数组，总是2的n次幂entrySet：存储具体元素的集size：HashMap中存储的键值对的数量modCount: HashMap扩容和结构改变的次数。threshold：扩容的临界值，=容量*填充因子loadFactor：填充因子\nLinkedHashMap的底层实现原理（了解）源码中：static class Entry&lt;K, V&gt; extends HashMap. Node&lt;K, V&gt; {Entry&lt;K, V&gt;  before, after;//能够记录添加的元素的先后顺序Entry(int hash, K key, V value, Node&lt;K, V&gt; next) {     super(hash, key, value, next)；  }}\nMap接口：常用方法\n添加、删除、修改操作：Object put(Object key,Object value)：将指定key-value添加到(或修改）当前map对象中void putAl(Map m):将m中的所有key-value对存放到当前map中Object remove(Object key)：移除指定key的key-value对，并返回valuevoid clear：清空当前map中的所有数据\n元素查询的操作：Object get(Object key)：获取指定key对应的valueboolean containsKey(Object key)：是否包含指定的keyboolean contains Value(Object value)：是否包含指定的valueint size()：返回map中key-value对的个数boolean isEmpty()：判断当前map是否为空boolean equals(Object obj)：判断当前map和参数对象obj是否相等\n元视图操作的方法：Set keySet(：返回所有key构成的Set集合Collection values()：返回所有value构成的Collection集合Set entrySetl：返回所有key-value对构成的Set集合\n\n//遍历操作的几种方式\n@Test\npublic void test() &#123;\n    Map hashMap = new HashMap();\n    hashMap.put(\"AA\", 123);\n    hashMap.put(45, 1234);\n    hashMap.put(\"bb\", 56);\n    //遍历所有的key集：keySet()\n    Set set = hashMap.keySet();\n    Iterator iterator = set.iterator();\n    while (iterator.hasNext()) &#123;\n        System.out.print(iterator.next() + \" \");//AA bb 45\n    &#125;\n    System.out.println(\"\\n*****************************\");\n    //遍历所有的value集合:values()\n    Collection collection = hashMap.values();\n    for (Object obj : collection) &#123;\n        System.out.print(obj + \" \");//123 56 1234\n    &#125;\n    System.out.println(\"\\n*****************************\");\n    //方式一：遍历所有的key-value:entrySet()\n    Set entrySet = hashMap.entrySet();\n    Iterator iterator1 = entrySet.iterator();\n    while (iterator1.hasNext()) &#123;\n        Object obj = iterator1.next();\n        //entrySet集合中的元素都是entry\n        Map.Entry entry = (Map.Entry) obj;\n        System.out.print(\"(\" + entry.getKey() + \",\" + entry.getValue() + \") \");\n      //(AA,123) (bb,56) (45,1234)\n    &#125;\n    System.out.println(\"\\n*****************************\");\n    //方式二：遍历所有的key-value\n    Set keySet = hashMap.keySet();\n    Iterator iterator2 = keySet.iterator();\n    while (iterator2.hasNext()) &#123;\n        Object key = iterator2.next();//key\n        Object value = hashMap.get(key);//value\n        System.out.print(\"(\" + key + \",\" + value + \") \");//(AA,123) (bb,56) (45,1234)\n    &#125;\n&#125;\n\n//向TreeMap中添加key-value，要求key必须是由同一个类创建的对象\n    //因为要按照key进行排序：自然排序、定制排序\n    //不能按照value排\n   class User&#123;\n    ...\n    //按照姓名从大到小排列，年龄从小到大排列\n    @Override\n    public int compareTo(Object o) &#123;\n        if(o instanceof User)&#123;\n            User user=(User)o;\n            int compare=-this.name.compareTo(user.name);\n            if(compare !=0)&#123;\n                return compare;\n            &#125;else &#123;\n                return Integer.compare(this.age,user.age);\n            &#125;\n        &#125;else &#123;\n            throw new RuntimeException(\"输入类型不匹配！\");\n        &#125;\n    &#125;\n   &#125;\n    @Test\n    public void TreeMapTest() &#123;  //自然排序：按照名字大小排序\n        TreeMap map = new TreeMap();\n        User user1 = new User(\"u1\", 23);\n        User user2 = new User(\"u2\", 45);\n        User user3 = new User(\"u3\", 11);\n        User user4 = new User(\"u4\", 33);\n        map.put(user1, 98);\n        map.put(user2, 39);\n        map.put(user3, 76);\n        map.put(user4, 100);\n        Set entrySet = map.entrySet();\n        Iterator iterator = entrySet.iterator();\n        while (iterator.hasNext()) &#123;\n            Object obj = iterator.next();\n            Map.Entry entry = (Map.Entry) obj;\n            System.out.println(\"(\" + entry.getKey() + \",\" + entry.getValue() + \") \");\n            //(User&#123;name='u4', age=33&#125;,100)\n            // (User&#123;name='u3', age=11&#125;,76)\n            // (User&#123;name='u2', age=45&#125;,39)\n            // (User&#123;name='u1', age=23&#125;,98)\n        &#125;\n    &#125;\n\n    @Test\n    public void TreeMapTest1() &#123; //定制排序：按照年龄大小排序\n        TreeMap map = new TreeMap(new Comparator() &#123;\n            @Override\n            public int compare(Object o1, Object o2) &#123;\n                if(o1 instanceof User &amp;&amp; o2 instanceof User)&#123;\n                    User u1=(User)o1;\n                    User u2=(User)o2;\n                    return Integer.compare(u1.getAge(),u2.getAge());\n                &#125;\n                throw new RuntimeException(\"输入的类型不匹配!\");\n            &#125;\n        &#125;);\n        User user1 = new User(\"u1\", 23);\n        User user2 = new User(\"u2\", 45);\n        User user3 = new User(\"u3\", 11);\n        User user4 = new User(\"u4\", 33);\n        map.put(user1, 98);\n        map.put(user2, 39);\n        map.put(user3, 76);\n        map.put(user4, 100);\n        Set entrySet=map.entrySet();\n        Iterator iterator=entrySet.iterator();\n        while (iterator.hasNext())&#123;\n            Object obj=iterator.next();\n            Map.Entry entry=(Map.Entry) obj;\n            System.out.println(\"(\" + entry.getKey() + \",\" + entry.getValue() + \") \");\n//            (User&#123;name='u3', age=11&#125;,76)\n//            (User&#123;name='u1', age=23&#125;,98)\n//            (User&#123;name='u4', age=33&#125;,100)\n//            (User&#123;name='u2', age=45&#125;,39)\n        &#125;\n    &#125;\n\nPropertiesMap子类之五， Properties 类是 Hashtable 的子类，该对象用于处理属性文件 由于属性文件里的 key、value 都是字符中类型，所以 Properties 里的 key和 value 都是字符串类型 存取数据时，建议使用setProperty(String key,String value)方法和getProperty(String key)方法\n\n\n\n\n\n\n\n\n\nProperties pros = new Properties()；pros. load (new FileInputStream(“jdbc.properties”));String user=pros.getProperty(“user”)；System.out.println(user);\n//Properties:常用来处理配置文件。key和value都是String类型\n@Test\npublic void test() &#123;\n    Properties properties = new Properties();\n    FileInputStream fileInputStream = null;\n    try &#123;\n        fileInputStream = new FileInputStream(\"jdbc.properties\");\n        properties.load(fileInputStream);//加载流文件\n        String name = properties.getProperty(\"name\");\n        String password = properties.getProperty(\"password\");\n        System.out.println(name + \":\" + password);\n    &#125; catch (Exception e) &#123;\n        e.printStackTrace();\n    &#125; finally &#123;\n        if(fileInputStream!=null) &#123;\n            fileInputStream.close();\n        &#125;\n    &#125;\n&#125;\n\n八、Collections工具类\n操作数组的工具类：Arrays\nCollections 是一个操作 Set、 List 和 Map 等集合的工具类\nCollections 中提供了一系列静态的方法对集合元素进行排序、查询和修改等操作，还提供了对集合对象设置不可变、对朱合对象     实现同步控制等方法\n排序操作：（均为static方法）\n\n\n\n\n\n\n\n\n\n\nreverse(List)：反转 List 中元素的顺序shuffle(List)：对 List 集合元素进行隨机排序sort(List)：根据元素的自然顺序对指定 List 集合元素按升序排序sort(List, Comparator)：根据指定的 Comparator 产生的顺序对 List 集合元素进行排序swap(List, int, int)：将指定 list 集合中的i处元素和j处元素进行交换\n面试题\nCollection和Collections的区别：\nCollection是接口，Collections是操作Collection的工具类。\nCollections工具类的常用方法&#x2F;&#x2F;    reverse(List)：反转List中元素的顺序\n&#x2F;&#x2F;    shuffle(List)：对List集合元素进行随机排序\n&#x2F;&#x2F;    sort(List)：跟据元素的自然顺序对指定 List 集合元素按升序排序\n&#x2F;&#x2F;    sort(List, Comparator)：根据造定的 Comparator 产生的顺序对 List 集合元素进行排序\n&#x2F;&#x2F;    swap(List, int i, int j)：将指定 List 集合中的i处元素和j处元素进行交换\n&#x2F;&#x2F;    Object max(Collection)：根据元素的自然顺序，返回给定集合中的最大元素\n&#x2F;&#x2F;    Object max(Collection, Comparator)：根据 Comparator 指定的顺序，返回给定集合中的最大值\n&#x2F;&#x2F;    Object min(Collection)：根据元素的自然顺序，返回给定集合中的最小元素\n&#x2F;&#x2F;    Object min(Collection, Comparator)：根据 Comparator 指定的顺序，返回给定集合中的最小值\n&#x2F;&#x2F;    int frequency(Collection, Object)：返回指定集合中指定元素的出现次数\n&#x2F;&#x2F;    void copy(List dest, List src): 将src 中的內容复制到dest中（注意）\n @Test\n    public void test()&#123;\n        List list&#x3D;new ArrayList();\n        list.add(123);\n        list.add(43);\n        list.add(765);\n        list.add(-97);\n        list.add(0);\n        &#x2F;&#x2F;利用如下方法将dest集合撑开，\n        &#x2F;&#x2F; 不然会报异常：IndexOutOfBoundsException(&quot;Source does not fit in dest&quot;)\n        List dest&#x3D; Arrays.asList(new Object[list.size()]);\n        Collections.copy(dest,list);\n        System.out.println(dest);\n    &#125;\n&#x2F;&#x2F;    boolean replaceALL(List list, Object oldVal, Object newVaL)：使用新值集合 List替换\n\nCollections 常用方法：同步控制Collections 类中提供了多个 synchronizedXxx()方法，该方法可使将指定集合包装成线程同步的集合，从而可以解决多线程并发访问集合时的线程安全问题\n//例\n@Test\npublic void test()&#123;\n    List list=new ArrayList();\n    list.add(123);\n    list.add(43);\n    list.add(765);\n    list.add(-97);\n    list.add(0);\n    //返回list1即为线程安全的集合\n    List list1=Collections.synchronizedList(list);\n    System.out.println(list1);\n&#125;\n\n","slug":"Java/集合","date":"2022-11-27T04:33:12.000Z","categories_index":"Java","tags_index":"Java","author_index":"YimooRua"},{"id":"c3659a2e604acbd60b38edfe2c810249","title":"回文数","content":"回文数⭐️难度：简单\n给你一个整数 x ，如果 x 是一个回文整数，返回 true ；否则，返回 false 。\n回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。\n例如，121 是回文，而 123 不是。\n示例 1：\n输入：x &#x3D; 121\n输出：true\n示例 2：\n输入： x &#x3D; -121\n输出：false\n解释：从左向右读, 为 -121 。 从右向左读, 为 121- 。因此它不是一个回文数。\n示例 3：\n输入：x &#x3D; 10\n输出：false\n解释：从右向左读, 为 01 。因此它不是一个回文数。\n\n提示：\n\n-231 &lt;= x &lt;= 231 - 1\n\n进阶：你能不将整数转为字符串来解决这个问题吗？\nclass Solution &#123;\n    public boolean isPalindrome(int x) &#123;\n        // 特殊情况：\n        // 如上所述，当 x &lt; 0 时，x 不是回文数。\n        // 同样地，如果数字的最后一位是 0，为了使该数字为回文，\n        // 则其第一位数字也应该是 0\n        // 只有 0 满足这一属性\n        if (x &lt; 0 || (x % 10 == 0 &amp;&amp; x != 0)) &#123;\n            return false;\n        &#125;\n\n        int revertedNumber = 0;\n        while (x > revertedNumber) &#123;\n            revertedNumber = revertedNumber * 10 + x % 10;\n            x /= 10;\n        &#125;\n\n        // 当数字长度为奇数时，我们可以通过 revertedNumber/10 去除处于中位的数字。\n        // 例如，当输入为 12321 时，在 while 循环的末尾我们可以得到 x = 12，revertedNumber = 123，\n        // 由于处于中位的数字不影响回文（它总是与自己相等），所以我们可以简单地将其去除。\n        return x == revertedNumber || x == revertedNumber / 10;\n    &#125;\n&#125;","slug":"Others/leetcode-回文数","date":"2022-11-18T09:00:00.000Z","categories_index":"Others","tags_index":"Others","author_index":"YimooRua"},{"id":"596309cd0250881615133cb44c237a29","title":"Linux常用命令","content":"第一章：Linux常用命令一、命令的基本格式1. 命令的提示符[root@localhost ~]#\n[]：这是提示符的分隔符号，没有特殊含义。\nroot：显示的是当前的登录用户，现在使用的是 root 用户登录。\n@：分隔符号，没有特殊含义。\nlocalhost： 当前系统的简写主机名（完整主机名是 localhost.localdomain)\n~：代表用户当前所在的目录，此例中用户当前所在的目录是家目录。\n#：命令提示符。超级用户是#，普通用户是＄  \n2. 命令的基本格式[rootelocalhost ~]#命令 [选项] [参数]\n※ ls 是最常见的目录操作命令，主要作用是显示目录下的内容。⭕️ 命令名称：ls。⭕️ 英文原意：list。⭕️ 所在路径：/bin/ls。⭕️ 执行权限：所有用户。⭕️ 功能描述：显示目录下的内容。\n[rootelocalhost ~]# ls [选项] [文件名或目录名]\n选项：\n-a：显示所有文件\n--color=when：支持颜色输出，when 的值默认是 always（总显示颜色），也可以是never：（从不显示颜色）和 auto（自动）\n-d：显示目录信息，而不是目录下的文件\n-h：人性化显示，按照我们习惯的单位显示文件大小\n-i：显示文件的i节点号\n-l：长格式显示\n\n 举几个例子：\n[root @localhost ~]# 1s -1\n总用量 44\n1 root root 1207 1月 14 18:18 anaconda-ks.cfg\n#权限 引用计数 所有者所属组 大小文件修改时间文件名\n\n我们己经知道“-1”选项用于显示文件的详细信息，那么“-”选项显示的这7列分别是什么含义？\n⭕️ 第一列：权限。具体权限的含义将在4.5节中讲解。⭕️ 第二列：引用计数。文件的引用计数代表该文件的硬链接个数，而目录的引用计数代表该目录⭕️ 有多少个一级子目录。⭕️ 第三列：所有者，也就是这个文件属于哪个用户。默认所有者是文件的建立用户⭕️ 第四列：所属组。默认所属组是文件建立用户的有效组，一般情况下就是建立用户的所在组。⭕️ 第五列：大小。默认单位是字节。⭕️ 第六列：文件修改时间。文件状态修改时间或文件数据修改时间都会更改这个时间，注意这个时间不是文件的创建时间。⭕️ 第七列：文件名。\n选项：是用于调整命令的功能的。参数：是命令的操作对象，如果省略参数，是因为有默认参数\n二、目录操作命令1. ls命令见前一小节的内容。\n2. cd 命令cd 是切换所在目录的命令，这个命令的基本信息如下。⭕️ 命令名称：cd。⭕️ 英文原意：change directory。⭕️ 所在路径：Shell 内置命令。⭕️ 执行权限：所有用户。⭕️ 功能描述：切换所在目录。\n2.1 cd命令的简化用法\n\n\n特殊符号\n作用\n\n\n\n~\n代表用户的家目录\n\n\n-\n代表上次所在目录\n\n\n.\n代表当前目录\n\n\n..\n代表上级目录\n\n\n2.2 绝对路径和相对路径绝对路径：以跟目录为参照物，从根目录开始，一级一级进入目录相对路径：以当前目录作为参照物，进行目录查找\n3.pwd命令pwd 命令是查询所在目录的命令，基本信息如下：⭕️ 命令名称：pwd⭕️ 英文原意：print name of current/working directory⭕️ 所在路径：/bin/pwd⭕️ 执行权限：所有用户。⭕️ 功能描述：查询所在的工作目录。\n4.mkdir命令mkdir 是创建目录的命令，其基本信息如下。⭕️ 命令名称：mkdir。⭕️ 英文原意：make directories。⭕️ 所在路径：/bin/mkdir。⭕️ 执行权限：所有用户。⭕️ 功能描述：创建空目录。命令格式\n[root@localhost ~]# mkdir [选项] 目录名\n选项： -p：递归建立所需目录\n5. rmdir命令既然有建立目录的命令，就一定会有删除目录的命令 rmdir，其基本信息如下。⭕️ 命令名称：rmdir。⭕️ 英文原意：remove empty directories。⭕️ 所在路径：/bin/rmdir。⭕️ 执行权限：所有用户。⭕️ 功能描述：删除空目录。\n命令格式\n[root@localhost ~] # rmdir [选项] 目录名\n选项：-p：递归删除目录\n\nrmdir 命令的作用十分有限，因为只能删除空目录，所以一旦目录中有内容，就会报错。这个命令比较“笨”，所以我们不太常用。后续我们不论删除的是文件还是目录，都会使用rm命令\n三、文件操作命令1.touch 命令创建空文件或修改文件时间，这个命令的基本信息如下。⭕️ 命令名称：touch。⭕️ 英文原意：change file timestamps。⭕️ 所在路径：/bin/touch。⭕️ 执行权限：所有用户。⭕️ 功能描述：修改文件的时间戳。\n2.stat 命令stat 是查看文件详细信息的命念，而且可以看到文件的这三个时间，其基本信息如下。⭕️命令名称：stat。⭕️英文原意：display file or file system status。⭕️所在路径：/usr/bin/stat。⭕️执行权限：所有用户。功能描述：显示文件或文件系统的详细信息。\n[root@localhost ~]# stat anaconda-ks . cfg\n文件：\"anaconda-ks.cfg\"\n大小：1453        块：8          IO 块：4096           普通文件\n设备：803h/2051dInode：33574991 硬链接：1\n权限：(0600/-rw-------）uid：（    0/       root)       Gid：(    0/     root)\n环境：system_u:object_r：admin _home_t:s0\n最近访问：2018-11-06 23:22:23.409038121 +0800\n最近更改：2018-10-24 00:53:08.760018638 +0800           #数据修改时间\n最近改动：2018-10-24 00:53:08.760018638 +0800           #状态修改时间\n创建时间：-\n\n3.cat 命令cat 命令用来查看文件内容。这个命令的基本信息如下。⭕️命令名称：cat。⭕️英文原意：concatenate files and print on the standard output。⭕️所在路径：/bin/cat。⭕️执行权限：所有用户。功能描述：合并文件并打印输出到标准输出\n命令格式\n[root@localhost ~]# cat [选项]  文件名\n选项：\n-A：相当于-vET 选项的整合，用于列出所有隐藏符号\n-E：列出每行结尾的回车符$\n-n：显示行号\n-T：把 Tab 键用 ^I 显示出来\n-v：列出特殊字符\n\n4.more 命令more 是分屏显示文件的命令，其基本信息如下。⭕️命令名称：more。⭕️英文原意：file perusal filter for crt vie win。⭕️所在路径：/bin/more。⭕️执行权限：所有用户。⭕️功能描述：分屏显示文件内容。\nmore 命令比较简单，一般不用什么选项，命令会打开一个交互界面，可以识别一些交互命令。常用的交互命令如下。⭕️空格键：向下翻页。⭕️b：向上翻页。⭕️回车键：向下滚动一行。⭕️/字符串：搜索指定的字符串。⭕️q：退出。\n5.less 命令less 命令和 more 命令类似，只是 more 是分屏显示命令，而 less 是分行显示命令，其基本信息如下。⭕️命令名称：less。⭕️英文原意：opposite of more。⭕️所在路径：/usr/bin/less。⭕️执行权限：所有用户。⭕️功能描述：分行显示文件内容。\n6. head 命令head 是用来显示文件开头的命令，其基本信息如下。⭕️命令名称：head。⭕️英文原意：output the first part of files。⭕️所在路径：/usr/bin/head。⭕️执行权限：所有用户。⭕️功能描述：显示文件开头的内容。\n命令格式\n[root @localhost ~]# head [选项]  文件名\n选项：-n 行数：从文件头开始，显示指定行数\n-v：显示文件名\n\n7.tail 命令既然有显示文件开头的命令，就会有显示文件结尾的命令。tail 命令的基本信息如下。⭕️命令名称：tail。⭕️英文原意：output the last part of files.⭕️所在路径：/usr/bin/tail。⭕️执行权限：所有用户。⭕️功能描述：显示文件结尾的内容。\n命令格式\n[root @localhost ~]#  tail [选项]  文件名\n选项：-n  行数：从文件结尾开始，显示指定行数\n-f：监听文件的新增内容\n\n8.In 命令我们来看看 In 命令的基本信息。⭕️命令名称：In。⭕️英文原意：make links between file。⭕️所在路径：/bin/In。⭕️执行权限：所有用户。⭕️功能描述：在文件之间建立链接。\n8.1 ln命令的基本格式[root@localhost ~]# ln [选项]  源文件目标文件\n选项：\n-s：建立软链接文件。如果不加\"-s\"选项，则建立硬链接文件\n-f：强制。如果目标文件已经存在，则删除目标文件后再建立链接文件\n\n如果创建硬链接：\n[root@localhost ~]# touch cangls\n[root@localhost ~]# ln  /root/cangls  /tmp/\n#建立硬进接文件，目标文件没有写文件名，会和原名一致\n#也就是/root/cangls 利/tmp/cangls 是硬链接文件\n\n 如果创建软链接：\n[root@localhost ~]# touch bols\n[root@localhost ~]# ln -s /root/bols /tmp/\n#建立软链接文件\n\n8.2 硬链接与软连接的特征\n硬链接特征：\n源文件和硬链接文件拥有相同的 Inode 和 Block\n修改任意一个文件，另一个都改变\n删除任意一个文件，另一个都能使用\n硬链接标记不清，很难确认硬链接文件位置，不建议使用\n硬链接不能链接目录\n硬链接不能跨分区\n\n\n软链接特征：\n软链接和源文件拥有不同的 Inode 和 Block\n两个文件修改任意一个，另一个都改变\n删除软链接，源文件不受影响；删除源文件，软链接不能使用\n软链接没有实际数据，只保存源文件的 Inode，不论源文件多大，软链接大小不变\n软链接的权限是最大权限 lrwxtwxtwx.，但是由于没有实际数据，最终访问时需要参考源文件权限\n软链接可以链接目录\n软链接可以跨分区\n软链接特征明显，建议使用软连接\n\n\n\n四、目录和文件都能操作的命令1.rm 命令rm 是强大的删除命令，不仅可以删除文件，也可以删除目录。这个命令的基本信息如下。⭕️命令名称：rm。⭕️英文原意：remove files or directories。⭕️所在路径：/bin/rm。⭕️执行权限：所有用户。⭕️功能描述：删除文件或目录。命令格式\n[root@localhost ~]# rm[选项] 文件或目录\n选项：-f：强制删除(force)\n-i：交互删除，在删除之前会询问用户\n-r：递归删除，可以删除目录 (recursive)\n\n2.cp 命令cp 是用于复制的命令，其基本信息如下：⭕️命令名称：cp。⭕️英文原意：copy files and directories。⭕️所在路径：/bin/cp。⭕️执行权限：所有用户。⭕️功能描述：复制文件和目录。命令格式\n[root@localhost ~]＃ cp [选项] 源文件 目标文件\n选项：\n-a：相当于-dpr 选项的集合，这几个选项我们一一介绍\n-d：如果源文件为软链接（对硬链接无效），则复制出的目标文件也为软链接\n-i：询问，如果目标文件已经存在，则会询问是否覆盖\n-p：复制后目标文件保留源文件的属性（包括所有者、所属组、权限和时间）\n-r：递归复制，用于复制目录\n\n3.mv命令mv是用来剪切的命令，其基本信息如下。⭕️命令名称：mv。⭕️英文原意：move (rename) files。⭕️所在路径：/bin/mv。⭕️执行权限：所有用户。⭕️功能描述：移动文件或改名。命令格式\n[root@localhost ~]# mv [选项] 源文件 目标文件\n选项：\n-f：强制覆盖，如果目标文件已经存在，则不询问，直接强制覆盖\n-i：交互移动，如果目标文件已经存在，则询问用户是否覆盖（默认选项）\n-v：显示详细信息\n\n五、基本权限管理1.权限的介绍权限位的含义前面讲解ls 命令时，我们己经知道长格式显示的第一列就是文件的权限，例如：\n[root@localhost ~]# ls -l install.log\n-rw-r--r--. 1 root root 24772 1月 14 18:17 install.log\n第一列的权限位如果不计算最后的”.”（这个点的含义我们在后面解释），则共有10位，这10位权限位的含义如下图所示。\n \n\n第1位代表文件类型。Linux 不像 Windows 使用扩展名表示文件类型，而是使用权限位的第1位表示文件类型。虽然 Linux 文件的种类不像 Windows 中那么多，但是分类也不少，详细情况可以使用“info ls”命令查看。这里只讲一些常见的文件类型。-：普通文件。b：块设备文件。这是一种特殊设备文件，存储设备都是这种文件，如分区文件/dev/sda 1就是这种文件。e：字符设备文件。这也是特殊设备文件，输入设备一般都是这种文件，如鼠标、键盘等。d：目录文件。Linux 中一切皆文件，所以目录也是文件的一种。l：软链接文件。p：管道符文件。这是一种非常少见的特殊设备文件。s：套接字文件。这也是一种特殊设备文件，一些服务支持 Socket 访问，就会产生这样的文件。\n第2～4位代表文件所有者的权限。-r：代表 read，是读取权限。-w：代表 write，是写权限。-x：代表 execute，是执行权限。如果有字母，则代表拥有对应的权限；如果是-，则代表没有对应的权限。\n第5～7位代表文件所属组的权限，同样拥有rwx权限。\n第8～10位代表其他人的权限，同样拥有rwx权限。\n\n2.基本权限命令首先来看修改权限的命令 chmod，其基本信息如下。⭕️命令名称：chmod。⭕️英文原意：change file mode bits。⭕️所在路径：/bin/chmod。⭕️执行权限：所有用户。⭕️功能描述：修改文件的权限模式。\n2.1 命令格式[root@localhost ~]# chmod[选项] 权限模式 文件名\n选项：\n-R：递归设置权限，也就是给子目录中的所有文件设定权限\n\n2.2 权限模式chmod 命令的权限模式的格式是[ugoa][[+-=][perms]]，也就是[用户身份][赋予方式][权限]的格式，我们来解释一下。\n\n用户身份。-u：代表所有者(user）-g： 代表所属组(group)-o：代表其他人(other)-a：代表全部身份(all)\n赋予方式。+：加入权限。-：减去权限。=：设置权限。\n权限。r： 读取权限(read)w：写权限(write）x：执行权限(execute)\n\n2.3 数字权限数字权限的赋子方式是最简单的，但是不如之前的字母权限好记、直观。我们来看看这些数字权限的含义。4：代表r权限。2：代表w权限。1：代表x权限。\n2.4 常用权限数字权限的赋予方式更加简单，但是需要用户对这几个数字更加熟悉。其实常用权限也并不多，只有如下几个。644：这是文件的基本权限，代表所有者拥有读、写权限，而所属组和其他人拥有只读权限。755：这是文件的执行权限和目录的基本权限，代表所有者拥有读、写和执行权限，而所属组和其他人拥有读和执行权限。777：这是最大权限。在实际的生产服务器中，要尽力避免给文件或目录赋予这样的权限，这会造成一定的安全隐患。\n3.基本权限的作用3.1 权限含义的解释首先，读、写、执行权限对文件和目录的作用是不同的。\n\n权限对文件的作用。\n读（r)：对文件有读（r）权限，代表可以读取文件中的数据。如果把权限对应到命令上，那么一旦对文件有读（r）权限，就可以对文件执行 cat、 more、 less、 head、 tail 等文件查看命令。\n写（w）：对文件有写（w）权限，代表可以修改文件中的数据。如果把权限对应到命令上，那么一旦对文件有写（w）权限，就可以对文件执行 vim、 echo 等修改文件数据的命令。注意：对文件有写权限，是不能删除文件本身的，只能修改文件中的数据。如果要想删除文件，则需要对文件的上级目录拥有写权限。\n执行（x）：对文件有执行（x）权限，代表文件拥有了执行权限，可以运行。在Linux 中，只要文件有执行（x）权限，这个文件就是执行文件了。只是这个文件到底能不能正确执行，不仅需要执行（x）权限，还要看文件中的代码是不是正确的语言代码。对文件来说，执行（x）权限是最高权限。\n\n\n权限对目录的作用。\n读（r）：对目录有读（T）权限，代表可以查看目录下的内容，也就是可以查看目录下有哪些子文件和子目录。如果把权限对应到命令上，那么一旦对目录拥有了读（r）权限，就可以在目录下执行ls命令，查看目录下的内容了。\n写（w）：对目录有写（r）权限，代表可以修改目录下的数据，也就是可以在目录中新建、删除、复制、剪切子文件或子目录。如果把权限对应到命令上，那么一旦对目录拥有了写（w）权限，就可以在目录下执行 touch、 rm、 ep、my 命令。对目录来说，写（w）权限是最高权限。\n执行（x）：目录是不能运行的，那么对目录拥有执行（x）权限，代表可以进入目录。如果把权限对应到命令上，那么一旦对目录拥有了执行（x）权限，就可以对目录执行 cd 命令，进入目录。\n\n\n\n3.2 目录的可用权限目录的可用权限其实只有以下几个。0：任何权限都不赋予。5：基本的目录浏览和进入权限。7：完全权限。\n4.所有者和所属组命令4.1 chown 命令chown 是修改文件和目录的所有者和所属组的命令，其基本信息如下。⭕️命令名称：chown。⭕️英文原意：change file owner and group。⭕️所在路径：/bin/chown。⭕️执行权限：所有用户。⭕️功能描述：修改文件和目录的所有者和所属组。\n命令格式\n[root@localhost ~]# chown [选项] 所有者：所属组 文件或目录\n选项：\n-R：递归设置权限，也就是给子目录中的所有文件设置权限\n普通用户不能修改文件的所有者，哪怕自己是这个文件的所有者也不行。普通用户可以修改所有者是自己的文件的权限。\n4.2 chgrp 命令chgrp 是修改文件和目录的所属组的命令，其基本信息如下。⭕️命令名称：chgrp。⭕️英文原意：change group ownership。⭕️所在路径：/bin/chgrp。⭕️执行权限：所有用户。⭕️功能描述：修改文件和目录的所属组。\n5.umask 默认权限5.1 查看系统的 umask 权限[root@localhost ~]# umask\n0022\n#用八进制数值显示 umask 权限\n[root@localhost ~]＃ umask -S\nu=rwx,g=rx,o=rx\n#用字母表示文件和目录的初始权限\n5.2 umask 权限的计算方法我们需要先了解一下新建文件和目录的默认最大权限。\n\n对文件来讲，新建文件的默认最大权限是 666，没有执行（x）权限。这是因为执行权限对文件来讲比较危险，不能在新建文件的时候默认赋予，而必须通过用户手工赋予。\n对目录来讲，新建目录的默认最大权限是777。这是因为对目录而言，执行（x）权限仅仅代表进入目录，所以即使建立新文件时直接默认赋子，也没有什么危险。\n\n按照官方的标准算法，umask 默认权限需要使用二进制进行逻辑与和逻辑非联合运算才可以得到正确的新建文件和目录的默认权限。这种方法既不好计算，也不好理解，并不推荐。我们在这里还是按照权限字母来讲解 umask 权限的计算方法。我们就按照默认的 umask 值是022来分别计算一下新建文件和目录的默认权限吧。\n\n文件的默认权限最大只能是666，而 umask 的值是 022 “-rw-rw-rw-”减去“W–W-” 等于“-rw-r–r—”\n\n目录的默认权限最大可以是777，而 umask 的值是 022 “drwxrwxrwx”减去“d—-w–w-” 等于 “drwx-r-xr-x”注意：umask 默认权限的计算绝不是数字直接相减。\n例如 umask 是 033呢？\n\n文件的默认权限最大只能是 666，而 umask 的值是033 “-rw-rw-rw-” 减去“—–wx-wx”等于 “-rw-r–r—”\n\n\n\n六、帮助命令1.man 命令man 是最常见的帮助命令，也是 Linux 最主要的帮助命令，其基本信息如下。⭕️命令名称：man。⭕️英文原意：format and display the on-line manual pages。⭕️所在路径：/usr/bin/man.⭕️执行权限：所有用户。⭕️功能描述：显示联机帮助手册。\n1.1命令格式[root@localhost ~]# man [选项] 命令\n选项：\n-f 查看命令拥有哪个级别的帮助\n-k 查看和命令相关的所有帮助\n\n1.2 man命令的快捷键\n\n\n快捷键\n作用\n\n\n\n上箭头\n向上移动一行\n\n\n下箭头\n向下移动一行\n\n\nPgUp\n向上翻一页\n\n\nPgDn\n向下翻一页\n\n\ng\n移动到第一页\n\n\nG\n移动到最后一页\n\n\nq\n退出\n\n\n/字符串\n从当前页向下搜索字符串\n\n\n?字符串\n从当前页向上搜索字符串\n\n\nn\n当搜索字符串时，可以使用 n 键找到下一个字符串\n\n\nN\n当搜索字符串时，使用 N键反向查询字符串。也就是说，如果使用“/字符串”方式搜索，则N键\n\n\nN\n表示向上搜索字符串：如果使用“?字符串”方式搜素，则N键表示向下搜索字符串\n\n\n1.3 man命令的帮助级别\n\n\n级别\n作用\n\n\n\n1\n普通用户可以执行的系统命令和可执行文件的帮助\n\n\n2\n內核可以调用的函数和工具的帮助\n\n\n3\nC语言函数的帮助\n\n\n4\n设备和特殊文件的帮助\n\n\n5\n配置文件的帮助\n\n\n6\n游戏的帮助（个人版的 Linux 中是有游戏的）\n\n\n7\n杂项的帮助\n\n\n8\n超级用户可以执行的系统命令的帮助\n\n\n9\n内核的帮助\n\n\n\n\n\n\n\n\n\n\n\nman -f 命令或 whatis命令#查看命令拥有哪个级别的帮助man -k 命令或 apropos 命令#查看和命令相关的所有帮助\n2.info 命令info 命令的帮助信息是一套完整的资料，每个单独命令的帮助信息只是这套完整资料中的某一个小章节。\n\n\n\n快捷键\n作用\n\n\n\n上箭头\n向上移动一行\n\n\n下箭头\n向下移动一行\n\n\nPgUp\n向上翻一页\n\n\nPgDn\n向下翻一页\n\n\nTab\n在有*符号的节点间进行切换\n\n\n回车\n进入有*符号的子页面，查看详细帮助信息\n\n\nu\n进入上一层信息（回车是进入下一层信息）\n\n\nn\n进入下一小节信息\n\n\nP\n进入上一小节信息\n\n\n？\n查看帮助信息\n\n\nq\n退出 info 信息\n\n\n3.help 命令help 只能获取 Shell 内置命令的帮助help 命令的基本信息如下。⭕️命令名称：help。⭕️英文原意：help。⭕️所在路径：Shell 内置命令。⭕️执行权限：所有用户。⭕️功能描述：显示 Shell 内置命令的帮助。可以使用 type 命令来区分内置命令与外部命令，shell 是 Linux 的命令解释器。\n4.- -help 选项绝大多数命令都可以使用“- -help”选项来查看帮助，这也是一种获取帮助的方法。例如：\n[root@localhost ~]# ls --help\n这种方法非常简单，输出的帮助信息基本上是 man 命令的信息简要版。对于这4种常见的获取帮助的方法，大家可以按照自己的习惯任意使用。\n七、搜索命令1.whereis 命令whereis 是搜索系统命令的命令（像绕口令一样），也就是说，whereis 命令不能搜索普通文件，而只能搜索系统命令。whereis 命令的基本信息如下。⭕️命令名称： whereis。⭕️英文原意：locate the binary, source, and manual page files for a command。⭕️所在路径：/usr/bin/whereis。⭕️执行权限：所有用户。⭕️功能描述：查找二进制命令、源文件和帮助文档的命令。\n2.which 命令which 也是搜索系统命令的命令。和 whereis 命令的区别在于：\n\nwhereis 命令可以在查找到二进制命令的同时，查找到帮助文档的位置；\n而 which 命令在查找到二进制命令的同时，如果这个命令有别名，则还可以找到别名命令。\n\nwhich 命令的基本信息如下。\n⭕️命令名称：which。⭕️英文原意：shows the full path of (shell) commands。⭕️所在路径：/usr/bin/which。⭕️执行权限：所有用户。⭕️功能描述：列出命令的所在路径。\n3.locate 命令3.1基本用法locate 命令才是可以按照文件名搜索普通文件的命令。\n\n优点：按照数据库搜索，搜索速度快，消耗资源小。数据库位置/var/lib/mlocate/mlocate.db，可以使用 updatedb 命令强制更新数据库。\n\n缺点：只能按照文件名来搜索文件，而不能执行更复杂的搜索，比如按照权限、大小、修改时间等搜索文件。\n\n\nlocate 命令的基本信息如下。  ⭕️命令名称：locate。  ⭕️英文原意：find files by name。  ⭕️所在路径：/usr/bin/locate。  ⭕️执行权限：所有用户。  ⭕️功能描述：按照文件名搜索文件。\n3.2 配置文件[root@localhost ~]# vi /etc/updatedb.conf\nPRUNE_BIND_MOUNTS = \"yes\"\n#开启搜索限制，也就是让这个配置文件生效\nPRUNEFS = \".....\"\n#在 locate 执行搜索时，禁止搜索这些文伴系统类型\nPRUNENAMES = \".....\"\n#在 locate 执行搜索时，禁止搜索带有这些扩展名的文件\nPRUNEPATHS = \".....\"\n#在locate 执行搜索时，禁止搜索这些系统目录\n\n4.find 命令find 命令的基本信息如下。⭕️命令名称：find。⭕️英文原意：search for files in a directory hierarchy。⭕️所在路径：/bin/find。⭕️执行权限：所有用户。⭕️功能描述：在目录中搜索文件。\n4.1 按照文件名搜索[root@localhost ~]# find 搜索路径 [选项] 搜索内容\n选项：\n-name：按照文件名搜索\n-iname：按照文件名搜索，不区分文件名大小写\n-inum：按照 inode 号搜索\n\n4.2. 按照文件大小搜索[root@localhost ~]# find 搜索路径 [选项] 搜索内容\n选项：\n-size [+ | -]大小：按照指定大小搜索文件\n这里的+的意思是搜索比指定大小还要大的文件，的意思是搜索比指定大小还要小的文件。\nfind 命令的单位：\n[root@localhost ~]# man find\n-size n[cwbkMG]\nFile uses n units of space. The following suffixes can be used:\n\"b\"  for 512-byte blocks (this is the default if no suffix is used)\n#这是默认单位，如果单位为b或不写单位，则按照 512 Byte 搜索\n\"c\"  for bytes\n#搜索单位是c，按照字节搜索\n\"w\"  for two-byte words\n#搜索单位是w，按照双字节（中文）搜索\n\"k\"  for Kilobytes (units of 1024 bytes)\n#按照KB单位搜索，必须是小写的k\n\"M\"  for Megabytes (units of 1048576 bytes)\n#按照MB单位搜索，必须是大写的M\n\"G\"  for Gigabytes (units of 1073741824 bytes)\n#按照GB单位搜索，必须是大写的G\n\n4.3 按照修改时间搜索Linux 中的文件有访问时间（atime）、数据修改时间（mtime）、状态修改时间 (ctime）这三个时间，我们也可以按照时间来搜索文件。\n[root@localhost ~]# find 搜索路径 [选项] 搜索内容\n选项：\n-atime [+|-]时间：按照文件访问时间搜索\n-mtime [+|-]时间：按照文件数据修改时间搜索\n-ctime【+|-]时间：按照文件状态修改时间搜索\n\n这三个时间的区别我们在 stat 命令中己经解释过了，这里用 mtime 数据修改时间来举例，重点说说[+]时间的含义。\n\n-5：代表5天内修改的文件。\n5：代表前5~6 天那一天修改的文件。\n+5：代表6 天前修改的文件。我们画一个时间轴，来解释一下，如下图所示。\n\n \n4.4 按照权限搜索命令格式。\n[root@localhost ~]# find 搜索路径 [选项] 搜索内容\n选项：\n-perm 权限模式：查找文件权限刚好等于\"权限模式\"的文件\n-perm -权限模式：查找文件权限全部包含\"权限模式\"的文件\n-perm +权限模式：查找文件权限包含\"权限模式\"的任意一个权限的文件\n\n4.5 按照所有者和所属组搜索[root@localhost ~]# find 搜索路径 [选项] 搜索内容\n选项：\n-uid 用户ID：按照用户ID 查找所有者是指定ID的文件\n-gid 组ID：按照用户组ID 查找所属组是指定ID的文件\n-user 用户名：按照用户名查找所有者是指定用户的文件\n-group 组名：按照组名查找所属组是指定用户组的文件\n-nouser：查找没有所有者的文件\n按照所有者和所属组搜索时，-nouser选项比较常用，主要用于查找垃圾文件。只有一种情况例外，那就是外来文件。比如光盘和 U盘中的文件如果是由 Windows 复制的，在Linux 中查看就是没有所有者的文件：再比如手工源码包安装的文件，也有可能没有所有者。\n4.6 按照文件类型搜索[root@localhost ~]# find 搜索路径 [选项] 搜索内容\n选项：\n-type d：查找目录\n-type f：查找普通文件\n-type 1：查找软链接文件\n\n4.7 逻辑运算符[root@localhost ~]# find 搜索路径 [选项] 搜索内容\n选项：\n-a：and 逻辑与\n-o：or 逻辑或\n-not：not 逻辑非\n\n① -a： and 逻辑与find 命令也支持逻辑运算符选项，其中-a代表逻辑与运算，也就是-a 的两个条件都成立，find 搜索的结果才成立。举个例子：\n[root@localhost ~]# find . -size +2k -a -type f\n#在当前目灵下搜索大于2KB，并且文件类型是普通文件的文件\n\n② -o：or逻辑或-o选项代表逻辑或运算，也就是-o的两个条件只要其中一个成立，find命令就可以找到结果。例如：\nIroot @localhost ~]# find -name cangls -o -name bols\n./cangls\n./bols\n#在当前目录下搜索文件名要么是cangls 的文件，要么是bols的文件\n③ -not：not逻辑非-not 是逻辑非，也就是取反的意思。举个例子：\n[root@localhost ~]# find . -not -name cangls\n#在当前目录下搜索文件名不是cangls的文件\n\n4.8 其他选项①-exec 选项这里我们主要讲解两个选项-exec和-ok，这两个选项的基本作用非常相似。我们先来看看-exec选项的格式。\n[root@localhost ~]# find 搜索路径 [选项] 搜索内容 -exec 命令2 &#123;&#125; \\;\n其次，这个选项的作用其实是把 find 命令的结果交给由-exec 调用的命令2来处理。号就代表 find 命令的查找结果。②-ok选项-ok选项和-exec选项的作用基本一致，区别在于：-exec的命令2会直接处理，而不询问：-ok的命令2在处理前会先询问用户是否这样处理，在得到确认命令后，才会执行。\n5.grep 命令：补充命令grep 的作用是在文件中提取和匹配符合条件的字符串行。命令格式如下：\n[root@localhost ~]# grep [选项] \"搜索内容\" 文件名\n选项：\n-i：忽略大小写\n-n：输出行号\n-V：反向查找\n--color=auto：搜索出的关键字用颜色显示\n\nfind 也是搜索命令，那么 find 命令和 grep 命令有什么区别呢？\n\nfind 命令find 命令用于在系统中搜索符合条件的文件名，如果需要模糊查询，则使用通配符进行匹配，通配符是完全匹配（find 命令可以通过-regex选项，把匹配规则转为正则表达式规则，但是不建议如此）。\n\ngrep 命令grep 命令用于在文件中搜索符合条件的字符串，如果需要模糊查询，则使用正则表达式进行匹配，正则表达式是包含匹配。\n\n\n\n通配符与正则表达式的区别通配符：用于匹配文件名，完全匹配\n\n\n\n\n通配符\n作用\n\n\n\n？\n匹配一个任意字符\n\n\n*\n匹配0个或任意多个任意字符，也就是可以匹配任何内容\n\n\n[]\n匹配中括号中任意一个字符。例如，[abc]代表一定匹配一个字符，或者是 a，或者是b，或者是c\n\n\n[-]\n匹配中括号中任意一个字符，-代表一个范围。例如，[a-z]代表匹配一个小写字母\n\n\n[ ^ ]\n逻辑非，表示匹配不是中括号内的一个字符。例如，[ ^0-9]代表匹配一个不是数字的字符\n\n\n正则表达式：用于匹配字符串，包含匹配\n\n\n\n正则表达式\n作用\n\n\n\n?\n匹配前一个字符重复0次，或1次（?是扩展正则，需要使用egrep 命令)\n\n\n*\n匹配前一个字符重复0次，或任意多次\n\n\n[]\n匹配中括号中任意一个字符。例如，[abc]代表一定匹配一个字符，或者是 a，或者是b，或者是c\n\n\n[-]\n匹配中括号中任意一个字符，-代表一个范围。例如，[a-z]代表匹配一个小写字母\n\n\n[ ^ ]\n逻辑非，表示匹配不是中括号内的一个字符。例如，[ ^0-9]代表匹配一个不是数字的字符\n\n\n^\n匹配行首\n\n\n$\n匹配行尾\n\n\n6.管道符：补充命令命令格式：命令1 | 命令2命令1的正确输出作为命令2的操作对象\n1） 例子1：举个例子，我们经常需要使用ll命令查看文件的长格式，不过在有些目录中文件众多，比如/etc/目录，使用1命令显示的内容就会非常多，只能看到最后的内容，而不能看到前面输出的内容。这时我们马上想到 more 命令可以分屏显示文件内容，可是怎么让 more 命令分屏显示命令的输出呢？我想到了一种笨办法：\n[root@localhost ~]# ll -a /etc/ > /root /testfile\n#用输出重定向，把ll命分的输出保存到/root/testfile 文件中\n[root@localhost ~]# more / root /testfile\n#既然 testfile 是文件，当然可以用 more 命分分屏显示了\n总用量 1784\ndrwxx-xr-x. 105 root root 12288 10 月 21 12:49\ndr-xr-xr-x. 26 root root 4096 6月 5 19:06\n...省略部分输出...\n1 root root 687 6月 22 2012 auto.smb\n--More--(7%)\n可是这样操作实在不方便，这时就可以利用管道符了。命令如下：\n[root@localhost ~]# ll -a /etc/ | more\n2）例子 2：我想在命令ll  /etc/的结果中搜索 yum 的文件名，应该使用 find 命令？还是 grep 命令？\n[root@localhost ~]# ll -a /etc/ | grep yum\n\n3） 例子 3:netstat 命令(Centos 7中，需要安装 net-snmp.x86_64， net-tools.x86_64 两个包才有此命令。7.5系统中己经自动安装）格式如下：\n[root@localhost ~]# netstat [选项]\n选项：\n-a：列出所有网络状态，包括 Socket 程序\n-c 秒数：指定每隔几秒刷新一次网络状态\n-n：使用IE 地址和端口号显示，不使用域名与服务名\n-P：显示 PID 和程序名\n-t：显示使用 TCE 协议端口的连接状况\n-u：显示使用 UDE 协议端口的连接状况\n-1：仅显示监听状态的连接\n-X：显示路由表\n\n[root@localhost ~]# netstat -an | grep \"ESTABLISHED\" | wc -l\n#如果想知道具体的网络连接数量，就可以再使用 wc 命分统计行数\n\n统计正在连接的网络连接数量\n7.命令的别名：补充命令命令的别名，就是命令的小名，主要是用于照顾管理员使用习惯的。命令格式：\n[root@localhost ~]# alias\n#查询命令别名\n[root@localhost ~]# alias 别名=\"原命令\"\n#设定命令别名\n例如：\n[root@localhost ~]# alias ser=\"service network restart\"\n#用 ser 别名，替代 service ne twork restart 命令\n用命令定义的别名，是临时生效的，要想永久生效，需要写入环境变量配置文件~/.bashrc\n8.常用快捷键：补充命令\n\n\n快捷键\n作用\n\n\n\nTab键\n命令或文件补全\n\n\nctrl+A\n把光标移动到命令行开头。如果我们输入的命令过长，想要把光标移\n\n\nctrl+E\n动到命令行开头时使用。\n\n\nctrl+C\n把光标移动到命令行结尾。\n\n\nctrl+L\n强制终止当前的命令。清屏，相当于 clear命令。\n\n\nctrl+U\n删除或剪切光标之前的命令。我输入了一行很长的命令，不用使用退格键一个一个字符的删除，使用这个快捷键会更加方便\n\n\nctrl+Y\n粘贴 ctrl+U 剪切的内容。\n\n\n八、压缩和解压缩命令在 Linux 中可以识别的常见压缩格式有十几种，比如.zip .gz .bz .tar .tar.gz .tar.bz2等。\n1.“.zip”格式.zip是 Windows 中最常用的压缩格式，Linux 也可以正确识别”zip”格式，这可以方便地和Windows 系统通用压缩文件。\n1.1. “.zip”格式的压缩命令压缩命令就是 zip，其基本信息如下。⭕️命令名称：zip。⭕️英文原意：package and compress (archive) files。⭕️所在路径：/usr/bin/zip。⭕️执行权限：所有用户。⭕️功能描述：压缩文件或目录。\n命令格式如下：\n[root@localhost ~]# zip[选项] 压缩包名 源文件或源目录\n选项：\n-r：压缩目录\n例如：\n[root@localhost ~]# zip ana.zip anaconda-ks.cfg\n1.2 “.zip”格式的解压缩命令“.zip”格式的解压缩命令是 unzip, 其基本信息如下。⭕️命令名称：unzip。⭕️英文原意：list, test and extract compressed files in a ZIP archive。⭕️所在路径：/usr/bin/unzip。⭕️执行权限：所有用户。⭕️功能描述：列表、测试和提取压缩文件中的文件。\n命令格式如下：\n[root@localhost ~]# unzip [选项] 压缩包名\n选项：\n-d：指定解压缩位置\n例如：\n[root@localhost ~]# unzip -d /tmp/ ana.zip\n#把压缩包解压到指定位置\n\n2.“.g2”格式2.1 “gz”格式的压缩命令“.gz”格式是 Linux 中最常用的压缩格式，使用 gzip 命令进行压缩，其基本信息如下。⭕️命令名称：gzip。⭕️英文原意：compress or expand files。⭕️所在路径：/bin/gzip。⭕️执行权限：所有用户。⭕️功能描述：压缩文件或目录。\n这个命令的格式如下：\n[root@localhost ~]# gzip[选项] 源文件\n选项：\n-c：将压缩数据输出到标准输出中，可以用于保留源文件\n-d：解压缩\n-r：压缩目录\n[root @localhost ~]# gzip -c anaconda-ks .cfg > anaconda-ks. cfg.gz\n#使用-c选顶，但是不让压缩数据输出到屏慕上，而是重定向到压缩文件中\n#这样可以在压缩文件的同时不册除源文件\n2.2.“.gz”格式的解压缩命令如果要解压缩“.gz”格式，那么使用gzip -d 压缩包和gunzip 压缩包命令都可以。我们先看看 gunzip 命令的基本信息。⭕️命令名称：gunzip。⭕️英文原意：compress or expand files。⭕️所在路径：/bin/gunzip。⭕️执行权限：所有用户。⭕️功能描述：解压缩文件或目录。例如：\n[root @localhost ~]# gunzip instal1.1og.gz\n[root @localhost ~]# gzip -d anaconda-ks .cfg.gz\n两个命令都可以解压缩.g2格式\n3.“.bz2”格式3.1 “.bz2”格式的压缩命令“.bz2”格式是 Linux 的另一种压缩格式，从理论上来讲，“-bz2” 格式的算法更先进、压缩比更好：而“.gz”格式相对来讲压缩的时间更快。“.bz2” 格式的压缩命令是 bzip2，我们来看看这个命令的基本信息。⭕️命令名称：bzip2。⭕️英文原意：a block-sorting file compressor。⭕️所在路径：/usr/bin/bzip2。⭕️执行权限：所有用户。⭕️功能描述：.bz2 格式的压缩命令。\n来看看 bzip2 命令的格式。\n[root@localhost ~]# bzip2 [选项] 源文件\n选项：\n-d：解压缩\n-k：压缩时，保留源文件\n-v：显示压缩的详细信息\n例如：\n[root@localhost ~]# bzip2 anaconda-ks .cfg\n#压缩成.bz2 格式\n[root@localhost ~]# bzip2 -k install.1og.syslog\n#保留源文件压缩\n\n3.2 “.bz2”格式的解压缩命令“.bz2”格式可以使用bzip2 -d 压缩包名命令来进行解压缩，也可以使用bunzip2 压缩包名命令来进行解压缩。先看看 bunzip2 命令的基本信息。⭕️命令名称： bunzip2。⭕️英文原意：a block-sorting file compressor。⭕️所在路径：/usr/bin/bunzip2。⭕️执行权限：所有用户。⭕️功能描述：“.bz2”格式的解压缩命令。\n[root @localhost ~]# bunzip2 anaconda-ks .cfg.bz2\n[root @localhost ~]# bzip2\ninstall.1og.syslog.bz2\n#两个命令都可以解压缩\n\n4.“.tar”格式（打包不会压缩）4.1 “.tar”格式的打包命令“.tar”格式的打包和解打包都使用 tar 命令，区别只是选项不同。我们先看看 tar 命令的基本信息。⭕️命令名称：tar。⭕️英文原意：tar。⭕️所在路径：/bin/tar。⭕️执行权限：所有用户。⭕️功能描述：打包与解打包命令。命令的基本格式如下：\n[root@localhost ~]# tar [选项] [-f 压缩包名] 源文件或目录\n选项：\n-c：打包\n-f：指定压缩包的文件名。压缩包的扩展名是用来给管理员识别格式的，所以一定要正确指定扩展名\n-v：显示打包文件过程\n[root@localhost ~]# tar -cvf anaconda-ks.cfg.tar anaconda-ks.cfg\n#打包，不会压缩\n\n4.2 “.tar”格式的解打包命令“.tar”格式的解打包也需要使用 tar 命令，但是选项不太一样。命令格式如下：\n[root@localhost ~]# tar[选项] 压缩包\n选项：\n-x：解打包\n-f：指定压缩包的文件名\n-v：显示解打包文件过程\n-t：测试，就是不解打包，只是查看包中有哪些文件\n-c(大)目录：指定解打包位置\n#例如\n[root@localhost ~]# tar -xvf anaconda-ks.cfg.tar\n#解打包到当前目录下\n\n5.“.tar.gz” 和“.tar.bz2”格式使用 tar 命令直接打包压缩。命令格式如下：\n[root@localhost ~]# tar[选项] 压缩包 源文件或目录\n选项：\n-z：压缩和解压缩\".tar.gz\"格式\n-j：压缩和解压缩\".tar.bz2\"格式\n#例如：.tar.gz 格式\n[root@localhost ~]# tar -zcvf tmp.tar.gz /tmp/\n#把/tmp/目录直接打包压缩为\"tar.gz\"格式\n[root@localhost ~]# tar -zxvf tmp.tar.gz\n#解压缩与解打包\".tar.g2\"格式\n#例如：.tar.bz2 格式\n[root@localhost ~]# tar -jcvf tmp.tar.bz2 /tmp/\n#打包压缩为\"tar.bz2\"格式，注意压缩包文件名\n[root@localhost ~]# tar -jxvf tmp.tar.bz2\n#解压缩与解打包\"tar.bz2\"格式\n\n#再举几个例子：\n[root@localhost ~]# mkdir test\n[root@localhost ~]# touch\ntest /abc\n[root@localhost ~]# touch\ntest /bcd\n[root@localhost ~]# touch\ntest /cde\n#建立测试目录和测试文件\n[root@localhost ~]# tar -zcvf\ntest .tar .gz test/\n#压缩\n[root@localhost ~]# tar -ztvf test.tar.gz\n#只查看，不解压\n[root@localhost ~]# tar -ZxVf test.tar.gz -C /tmp\n#解压缩到指定位置\n[root@localhost ~]# tar -zxvf test.tar.gz -C /tmp test/cde\n#只解压压缩包中的特定文件，到指定位置\n\n九、关机和重启命令1.sync 数据同步sync 命令的基本信息如下。⭕️命令名称：sync。⭕️英文原意：flush file system buffers。⭕️所在路径：/bin/sync。⭕️执行权限：所有用户。⭕️功能描述：刷新文件系统缓冲区。\n2.shutdown 命令 shutdown 命令的基本信息如下。⭕️命令名称：shutdown。⭕️英文原意：bring the system down。⭕️所在路径：/sbin/shutdown。⭕️执行权限：超级用户。⭕️功能描述：关机和重启命令的基本格式如下：\n[root@localhost ~]# shutdown [选项] 时间 [警告信息]\n选项：\n-c：取消己经执行的 shutdown 命令\n-h：关机\n-r：重启\n\n3.reboot 命令在现在的系统中，reboot 命令也是安全的，而且不需要加入过多的选项。\n[root@localhost ~]# reboot\n#重启\n4.halt 和 poweroff 命令这两个都是关机命令，直接执行即可。这两个命令不会完整关闭和保存系统的服务，不建议使用。\n[root@localhost ~]# halt\n#关机\n[root@localhost ~]# poweroff\n#关机\n\n5.init 命令init 是修改 Linux 运行级别的命令，也可以用于关机和重启。这个命令并不安全，不建议使用。\n[root@localhost ~]# init 0\n#关机，也就是调用系统的0级别\n[root@localhost ~]# init 6\n#重启，也就是调用系统的6级别\n\n十、常用网络命令1.配置IP地址1.1 配置IP地址IP 地址是计算机在互联网中唯一的地址编码。每台计算机如果需要接入网络和其他计算机进行数据通信，就必须配置唯一的公网IP 地址。配置IP 地址有两种方法：\n\nsetup 工具\nvi /etc/sysconfig/network-scripts/ifcfg-eth0手动修改配置文件1.2 重启网络服务[root@localhost ~]# service network restart\n#重启网络服务\n1.3 虚拟机需要桥接到有线网卡，并重启网络服务\n\n1.4 复制镜像有可能需要重置 UUID（唯一识别符）[root@localhost ~]# vi /etc/sysconfig/network-scripts/ifcfg-eth0\n#删除 MAC 地址行\nIroot@localhost ~]# rm -rf /etc/udev/rules.d/70-persistent-net .rules\n#删除 Mac 地址和 UUID 绑定文件\n[root@localhost ~]# reboot\n#重启 Linux\n\n2.ifconfig 命令⭕️命令名称：ifconfig。⭕️英文原意：configure a network inter face。⭕️所在路径：/sbin/ifconfig。⭕️执行权限：超级用户。⭕️功能描述：配置网络接口。\nifconfig 命令最主要的作用就是查看 IP 地址的信息，直接输入 ifconfig 命令即可。\n[root@localhost ~]# ifconfig\neth0: flags=4163&lt;UP, BROADCAST, RUNNING, MULTICAST> mtu 1500\n      #标志                                          最大传输单元\n      inet 192.168.252.20 netmask 255.255.255.0 broadcast 192.168.252.255\n      #IP 地址                     子网掩码                 广播地址\n      inet6 fe80: :546e :994b: 30c: e2f7 prefixlen 64 scopeid 0x20&lt;link>\n      #IPV6 地址（目前没有生效） \n      ether 00: 0c:29:aa: d2:96 txqueuelen 1000 (Ethernet)\n      #MAC 地址\n      RX packets 3728 bytes 310958 (303.6 KiB)\n      RX errors O dropped 0 overruns 0 frame 0\n      #接收的数据包情况\n      TX packets 3051 bytes 1495119 (1.4 MiB)\n      TX errors 0 dropped 0 overruns 0 carrier 0 collisions 0\n      #发送的数据包情况\nlo: flags=73&lt;UP, LOOPBACK, RUNNING> mtu 65536\n#本地回环网卡\n      inet 127.0.0.1 netmask 255.0.0.0\n      inet6::1 prefixlen 128 scopeid 0x10&lt;host>\n      1oop txqueuelen 1000 (Local Loopback) \n      RX packets 8 bytes 696 (696.0 B)\n      RX errors 0 dropped 0 overruns 0 frame 0\n      TX packets 8 bytes 696 (696.0 B)\n      TX errors 0 dropped 0 overruns 0 carrier 0 collisions 0\n\n3.ping 命令ping 是常用的网络命令，主要通过 ICMP 协议进行网络探测，测试网络中主机的通信情况。ping命令的基本信息如下。⭕️命令名称：ping。⭕️英文原意：send ICMP ECHO REQUEST to network hosts。⭕️所在路径：/bin/ping。⭕️执行权限：所有用户。⭕️功能描述：向网络主机发送 ICMP 请求。\n命令的基本格式如下：\n[root@localhost ~]# ping [选项] IE\n选项：\n-b：后面加入广播地址，用于对整个网段进行探测\n-c 次数：用于指定 ping 的次数\n-s 字节：指定探测包的大小\n例子：探测网段中的可用主机在 ping 命令中，可以使用-b选项，后面加入广播地址，探测整个网段。我们可以使用这个选项知道整个网络中有多少主机是可以和我们通信的，而不用一个一个I 地址地进行探测。例如：\n[root@localhost ~]# ping -b -c 3 192.168.103.255\nWARNING: pinging broadcast address\nPING 192.168.103.255 （192.168.103.255) 56(84) bytes of data.\n64 bytes from 192.168.103.199: icmp seq=1 tt1=64 time=1.95 ms\n64 bytes from 192.168.103.168: icmpseq=1 tt1=64 time=1.97 ms (DUP!)\n64 bytes from 192.168.103.252: icmp seg=1 tt1=64 time=2.29 mS\n(DUP!)\n…省略部分内容..\n探测192.168.103.0/24 网段中有多少可以通信的主机\n4.netstat 命令netstat 是网络状态查看命令，既可以查看到本机开启的端口，也可以查看有哪些客户端连接。在 Centos 7.x 中 netstat 命令默认没有安裝，如果需要使用，需要安装 net-snmp 和 net-tools 软件包。netstat命令的基本信息如下。⭕️命令名称：netstat。⭕️英文原意：Print network connections, routing tables, interface statistics, masquerade connections,and multicast memberships。⭕️所在路径：/bin/netstat。⭕️执行权限：所有用户。⭕️功能描述：输出网络连接、路由表、接口统计、伪装连接和组播成员。\n命令格式如下：\n[root@localhost ~]# netstat [选项]\n选项：\n-a：列出所有网络状态，包括 Socket 程序\n-c 秒数：指定每隔几秒刷新一次网络状态\n-n：使用IP 地址和端口号显示，不使用域名与服务名\n-p：显示 PID 和程序名\n-t：显示使用 TCP 协议端口的连接状况\n-u：显示使用 UDP 协议端口的连接状况\n-l：仅显示监听状态的连接\n-r：显示路由表\n\n例子1：查看本机开启的端口这是本机最常用的方式，使用选项-tuln。因为使用了-1选项，所以只能看到监听状态的连接，而不能看到己经建立连接状态的连接。例如：\n[root@localhost ~]# netstat -tuln\nActive Internet connections (only servers)\nProto    Recv-Q   Send-Q     Local Address        Foreign Address                  State\ntcp        0      0          0.0.0.0:3306         0.0.0.0:*                        LISTEN\ntcp        0      0          0.0.0.0:11211        0.0.0.0:*                        LISTEN\ntcp        0      0          0.0.0.0.0:22         0.0.0.0:*                        LISTEN\ntcp        0      0          :::11211             :::*                             LISTEN\ntcp        0      0          :::80                :::*                             LISTEN\ntcp        0      0          :::22                :::*                             LISTEN\nudp        0      0          0.0.0.0:11211        0.0.0.0:*\nudp        0      0          :::11211             :::*\n#协议    接收队列 发送队列      本机的IP地址及端口号    远程主机的IP地址及端口号               状态\n\n这个命令的输出较多。\n\nProto：网络连接的协议， 一般就是 TCP 协议或者 UDP 协议。\nRecv-Q：表示接收到的数据，已经在本地的缓冲中，但是还没有被进程取走。\nSend-Q：表示从本机发送，对方还没有收到的数据，依然在本地的缓冲中，一般是不具备ACK标志的数据包。\nLocal Address： 本机的 IP 地址和端口号。\nForeign Address：远程主机的 IP 地址和端口号。\nState：状态。常见的状态主要有以下几种。\nLISTEN: 监听状态，只有TCP 协议需要监听，而 UDP 协议不需要监听。\nESTABLISHED：已经建立连接的状态。如果使用-选项，则看不到己经建立连接的状态。\nSYNSENT: SYN 发起包，就是主动发起连接的数据包。\nSYN RECV：接收到主动连接的数据包。\nFIN WAIT1：正在中断的连接。\nFIN WAIT2：已经中断的连接，但是正在等待对方主机进行确认。\nTIME WAIT：连接已经中断，但是套接字依然在网络中等待结束。\nCLOSED：套接字没有被使用。\n\n在这些状态中，我们最常用的就是 LISTEN 和 ESTABLISHED 状态，一种代表正在监听，另一种代表已经建立连接。\n例子2：查看本机有哪些程序开启的端口如果使用-p选项，则可以查看到是哪个程序占用了端口，并且可以知道这个程序的 PID。例如：\n[root@localhost ~]# netstat -tulnp\nActive Internet connections (only servers)\nProto   Recv-Q   Send-Q    Local Address   Foreign Address    State      PID/Program name\ntcp      0          0       0.0.0.0:3306    0.0.0.0:*        LISTEN      2359/mysqld\ntcp      0          0       0.0.0.0:11211   0.0.0.0:*        LISTEN      1563/memcached\ntcp      0          0       0.0.0.0:22      0.0.0.0:*        LISTEN      1490/sshd\ntcp      0          0       :::11211        :::*             LISTEN      1563/memcached\ntcp      0          0       :::80           :::*             LISTEN      21025/httpd\ntcp      0          0       :::22           :::*             LISTEN      1490/sshd\nudp      0          0       0.0.0.0:11211   0.0.0.0:*                    1563/memcached\nudp      0          0       :::11211        :::*                         1563 / memcached\n#比之前的命分多了一个\"-p\"选顶，结果多了\"PID/程序名\"，可以知道是哪个程序占用了端口\n\n例子3：查看所有连接使用选项-an可以查看所有连接，包括监听状态的连接(LISTEN）、己经建立连接状态的连接（ESTABLISHED)、Socket 程序连接等。因为连接较多，所以输出的内容有很多。例如：\n[root@localhost ~]# netstat -an\nActive Internet connections (servers and established)\nProto     Recv-Q     Send-Q      Local Address           Foreign Address     State\ntcp       0          0           0.0.0.0:3306            0.0.0.0:*           LISTEN\ntcp       0          0           0.0.0.0:11211           0.0.0.0:*           LISTEN\ntcp       0          0           117.79.130.170:80       78.46.174.55:58815  SYN_RECV\ntcp       0          0           0.0.0.0:22              0.0.0.0:*           LISTEN\ntcp       0          0           117.79.130.170:22       124.205.129.99:10379 ESTABLISHED\ntcp       0          0           117.79.130.170:22       124.205.129.99:11811 FSTABLISHED\n…省略部分内容…\nudp       0          0           0.0.0.0:11211           0.0.0.0:*\nudp       0          0           0:::11211               ::*\nActive UNIX doma in sockets (servers and estab lished)\nProto RefCnt Flags Type  State     I-Node Path\nunix: 2    [ACC]  STREAM LISTENING 9761   @/var/run/hald/dbus-fr41wkQn1c\n…省略部分内容…\n从 “Active UNIX domain sockets” 开始，之后的内容就是 Socket 程序产生的连接，之前的内容都是网络服务产生的连接。我们可以在-an选项的输出中看到各种网络连接状态，而之前的-tuln选项则只能看到监听状态。\n5.write 命令write 命令的基本信息如下。⭕️命令名称：write。⭕️英文原意：send a message to another user。⭕️所在路径：/usr/bin/write。⭕️执行权限：所有用户。⭕️功能描述：向其他用户发送信息。\n[root@localhost ~]#write user1 pts/1\nhello\nI will be in 5 minutes to restart, please save your data\n#向在pts/11远程终端1）登录的 user1 用户发送信息，使用\"ctr1+D\"快捷健保存发送的数据\n\n6.wall 命令write 命令用于给指定用户发送信息，而 wall 命会用于给所有登录用户发送信息，包括你自己。执行时，在 wall 命令后加入需要发送的信息即可，例如：\n[root@localhost ~]# wa11 \"I will be in 5 minutes to restart, please save your data\"\n7.mail 命令mail 是 Linux 的邮件客户端命令，可以利用这个命令给其他用户发送邮件。mail 命令的基本信息如下。⭕️命令名称：mail。⭕️英文原意：send and receive Internet mail。⭕️所在路径：/bin/mail。⭕️执行权限：所有用户。⭕️功能描述：发送和接收电子邮件。\n例子1：发送邮件如果我们想要给其他用户发送邮件，则可以执行如下命令：\n[root@localhost ~]# mail user1\nSubject： hello    &lt;-邮件标题\nNice to meet you!  &lt;-邮件具体內容\n.                  &lt;-使用\".\"来结束邮件输入\n#发送邮件给 user1 用户\n我们接收到的邮件都保存在/var/spool/mail/用户名中，每个用户都有一个以自己的用户名命名的邮箱。例子2：发送文件内容如果我们想把某个文件的内容发送给指定用户，则可以执行如下命令：\n[root@localhost ~]# mail -s \"test mail\" root ＜ /root/anaconda-ks.cfg\n选项：\n-s：指定邮件标题\n#把/root/anaconda-ks.cfg 文件的内容发送给 root 用户\n我们在写脚本时，有时需要脚本自动发送一些信息给指定用户，把要发送的信息预先写到文件中，是一个非常不错的选择。\n例子3：查看己经接收的邮件我们可以直接在命令行中执行 mail 命令，进入 mail 的交互命令中， 可以在这里查看己经接收到的邮件。例如：\n[root@localhost ~]# mail\nHeirloom Mail vers ion 12.4 7/29/08. Type ? for help.\n\"/var/spool/mail/root\"：1 message 1 new\n>N 1 root Mon Dec 5 22:45 68/1777 \"test mail\"  &lt;-之前收到的邮件\n>N 2 root Mon Dec 5 23:08 18/602  \"hello\"\n#未阅读 编号 发件人 时间 标题\n&amp;                                   &lt;-等待用户输入命令\n\n可以看到己经接收到的邮件列表，“N”代表未读邮件，如果是己经阅读过的邮件，则前面是不会有这个”N”的；之后的数字是邮件的编号，我们主要通过这个编号来进行邮件的操作。如果我们想要查看第一封邮件，则只需输入邮件的编号“1”就可以了。在交互命令中执行“？”，可以查看这个交互界面支持的命令。例如：\n&amp; ?         &lt;-输入命分\nmail commands\ntype&lt;message list>     type messages\nnext   goto and type next message\nfrom&lt;message list>    give head lines of messages\nheaders       print out active message headers       \ndelete&lt;message 1ist>     delete messages     \nundelete&lt;message 1ist>   undelete mes sages\nsave&lt;message list> folder   append messages to folder and mark as saved\ncopy&lt;message 1ist> folder   append messages to folder without marking them\nwrite&lt;message 1ist> file    append mes sage texts to file, save attachments\npreserve&lt;message 1ist>      keep incoming me ssages in mailbox even if saved\nReply &lt;message 1ist>    reply to mes sage senders\nreply&lt;message 1ist>     reply to message senders and all recipients\nmail addres ses         mail to specific recipients\nfile folder          change to another folder\nquit                 quit and apply changes to folder\nxit                  quit and discard changes made to folder\n!                   shell escape\ncd&lt;directory>       chdir to directory or home if none given\n1ist        1ist names of all availab le commands\n\n这些交互命令是可以简化输入的，比如“headers” 命令，就可以直接输入“h”，这是列出邮件标题列表的命令。我们解释一下常用的交互命令。\n\nheaders：列出邮件标题列表，直接输入h命令即可。\ndelete：删除指定邮件。比如想要删除第二封邮件，可以输入d 2\nsave：保存邮件。可以把指定邮件保存成文件，如s2/tmpftest.mail\nquit：退出，并把己经操作过的邮件进行保存。比如移除已删除邮件、保存已阅读邮件等。\nexit：退出，但是不保存任何操作。\n\n十一、系统痕迹命令系统中有一些重要的痕迹日志文件，如/var/log/wtmp、 /var/run/utmp、 /var/log/btmp、/var/log/lastlog 等日志文件，如果你用 vim 打开这些文件，你会发现这些文件是二进制乱码。这是由于这些日志中保存的是系统的重要登录痕迹，包括某个用户何时登录了系统，何时退出了系统，错误登录等重要的系统信息。这些信息要是可以通过 vim 打开，就能编辑，这样痕迹信息就不准确，所以这些重要的痕迹日志，只能通过对应的命令来进行查看。\n1.w命令w命令是显示系统中正在登陆的用户信息的命令，这个命令查看的痕迹日志是/var/run/utmp。这个命令的基本信息如下：⭕️命令名称：w⭕️英文原意：Show who is logged on and what they are doing.⭕️所在路径：/usr/bin/w⭕️执行权限：所有用户。⭕️功能描述：显示灯用户，和他正在做什么。例如：\n[root@localhost ~] # W\n00:06:11 up 5:47， 2 users,load average: 0.00, 0.01,0.05\n#系统时间 持续开机时间 登陆用户 系统在1分钟，5分钟，15 分钟前的平均负载\nUSER   TTY   FROM   LOGIN@   IDLE    JCPU    PCPU WHAT\nroot   tty1  23:59  7:07     0.08s   0.08s -bash\nroot   pts/2 192.168.252.1 23:42 3.00s 0.44s 0.06s w\n第一行信息，内容如下：\n\n\n\n内容\n说明\n\n\n\n12:26:46\n系统当前时间\n\n\nup 1 day, 13:32\n系统的运行时间，本机已经运行1天13小时32分钟\n\n\n2 users\n当前登录了两个用户\n\n\nload average: 0.00, 0.00, 0.00\n系统在之前1分钟、5分钟、15分钟的平均负载。如果 CPU 是单核的，则这个数值超过1 就是高负载;如果 CPU 是四核的，则这个数值超过4就是高负载(这个平均负载完全是依据个人经验来进行判断的，一般认为不应该超过服务器 CPU的核数）\n\n\n第二行信息，内容如下：\n\n\n\n内容\n说明\n\n\n\nUSER\n当前登陆的用户\n\n\nTTY\n登陆的终端：tty1-6：本地字符终端 (alt+F1-6切换）tty7：本地图形终端 (ctrl+alt+F7 切换，必须安装启动图形界面）pts/0-255:远程终端\n\n\nFROM\n登陆的IP 地址，如果是本地终端，则是空\n\n\nLOGIN@\n登陆时间\n\n\nIDLE\n用户闲置时间\n\n\nJCPU\n所有的进程占用的 CPU 时间\n\n\nPCPU\n当前进程占用的 CPU时间\n\n\nWHAT\n用户正在进行的操作\n\n\n2.who 命令who 命令和 w 命令类似，用于查看正在登陆的用户，但是显示的内容更加简单，也是查看/var/run/utmp日志。\n[root@localhost ~]# who\nroot  tty1  2022-11-12 23:59\nroot  pts/2 2022-11-12 23:42（192.168.252.1)\n#用户名 登陆终端  登陆时间（来源 IP)\n3. last 命令  last 命令是查看系统所有登陆过的用户信息的，包括正在登陆的用户和之前登陆的用户。这个命令查看的是/var/log/wtmp 痕迹日志文件。\n[root@localhost ~]# last\nroot   ttyl                  Mon Nov 12 23:59        still logged in\nroot   pts/2  192.168.252.1  Mon Nov 12 23:42        still logged in\nroot   pts/1  192.168.252.1  Mon Nov 12 23:37-23:59  (00:22)\nroot   ttyl                  Mon Nov 12 19:17-23:58  (04:41)\nroot   pts/0  192.168.252.1  Mon Nov 12 18:20-23:52  (05:32)\nreboot system boot 3.10.0-862.e17.x Mon Nov 12 18:18-00:22 (06:03）\n#系统重启信息记录\nroot   pts/1  192.168.252.1  Mon Nov 12 08:48-down   (01:29)\nroot   pts/1  192.168.252.1  Thu Nov  8 21:04-22:29  (01:25)\n#用户名 终端号  来源IP地址      登陆时间     -  退出时间\n\n4.lastlog 命令lastlog 命令是查看系统中所有用户最后一次的登陆时间的命令，他查看的日志是/var/log/lastlog文件。\n[root@localhost ~]# lastlog\nUsername    Port    From    Latest  \nroot        tty1            Mon Nov 12 23:59:03 +0800 2018\nbin                         **Never 1ogged in**\ndaemon                      **Never 1ogged in**\nadm                         **Never logged in**\n1p                          ** Never 1ogged in**\nsync                        **Never logged in**\n...省略部分内容...\n#用户名       终端    来源IP    登陆时间\n\n5.lastb 命令lastb 命令是查看错误登陆的信息的，查看的是/var/log/btmp痕迹日志：\n[root@localhost ~]# lastb\n(unknown tty1 Mon Nov 12 23:58 - 23:58 (00:00）\nroot  ttyl  Mon Nov 12 23:58 - 23:58  (00:00)\n#错误登陆用户 终端  尝试登陆的时间\n\n十二、挂载命令1.mount 命令基本格式linux 所有存储设备都必须挂载使用，包括硬盘⭕️命令名称：mount⭕️命令所在路径：/bin/mount⭕️执行权限：所有用户命令的具体格式如下：\n[root@localhost ~]# mount [-1]\n#查询系统中己经挂我的设备，-1会品示卷标名称\n[root@localhost ]# mount -a\n#依据配置文件/ete/fstab的內容，自动挂载\n[root@localhost ~]# mount [-t 文件系统] [-L 卷标名] [-o 特殊选项]  \\\n设备文件名 挂载点\n#\\代表这一行没有写完，换行\n选项：\n  -t 文件系统：加入文件系统类型来指定挂载的类型，可以 ext3、 ext4、 iso9660\n             等文件系统。\n  -L 卷标名： 挂载指定卷标的分区，而不是安装设备文件名挂载\n  -o 特殊选项：可以指定挂载的额外选项，比如读写权限、同步异步等，如果不指定则默认值生效。具体的特殊选项\n\n\n\n\n参数\n说明\n\n\n\natime/noatime\n更新访问时间/不更新访问时间。访问分区文件时，是否更新文件的访问时间，默认为更新\n\n\nasync/sync\n异步/同步，默认为异步\n\n\nauto/ noauto\n自动/手动，mount -a 命令执行时，是否会自动安裝/etc/fstab 文件内容挂载，默认为自动\n\n\ndefaults\n定义默认值，相当于 Iw, suid, dev, exec, auto, nouser, async 这七个选项\n\n\nexec/ noexec\n执行/不执行，设定是否允许在文件系统中执行可执行文件，默认是 exec允许\n\n\nremount\n重新挂载已经挂载的文件系统，一般用于指定修改特殊权限\n\n\nrw/ro\n读写/只读，文件系统挂载时，是否具有读写权限，默认是 rw\n\n\nsuid/ nosuid\n具有/不具有 SUID 权限，设定文件系统是否具有 SUID 和SGID 的权限，默认是具有\n\n\nuser/nouser\n允许/不允许普通用户挂载，设定文件系统是否允许普通用户挂载，默认是不允许，只有 root 可以挂载分区\n\n\nusrquota\n写入代表文件系统支持用户磁盘配额，默认不支持\n\n\ngrpquota\n写入代表文件系统支持组磁盘配额，默认不支持\n\n\n举例例1：\n[root@localhost ~]# mount\n#查看系统中己经挂载的文件系统，注意有虚拟文件系统\n/dev/sda3 on / type ext4 (rw)\nproc on /proc type proc (rw)\nsysfs on /sys type sysfs (rw)\ndevpts on / dev/pts type devpts (rw, gid=5, mode=620)\ntmpfs on /dev/shm type tmpfs (rw)\n/dev/sdal on /boot type ext4 (rw)\nnone on /proc/ sys/fs/binfnt_mise type binfmt_mise (rw)\nsunrpe on /var/lib/nfs/rpe_pipefs type rpe_pipefs (rw)\n#命公结果是代表：/der/sda3 分区挂载到/目录， 文件系统是 ext4，权限是读写\n例2：修改特殊权限\n[root@localhost ~]# mount\n#我们查看到/boot 分区己经被佳我，而且采用的 defaul ts 选项，那么我们重新挂我分区，并采用 noexec\n#权限禁止执行文件执行，看看会出现什么情况（注意不要用/分区做试验，#不然系统命令也不能执行了）。\n...省略部分输出...\n/dev/sdal on /boot type ext4 (rw)\n...省略部分输出...\n[root@localhost ~]# mount -o remount, noexec /boot\n#重新挂载 /boot 分区，并使用 noexec 权限\n[root@localhost sh] # cd /boot/\n[root@localhost boot]# vi hello.sh\n#写个shell吧\n#!/bin/bash\necho \"hello!!\"\n[root@localhost boot]# chmod 755 hello.sh\n[root@localhost boot]# ./hello.sh\n-bash: ./hello.sh：权限不够\n#虽然赋子了 hello.sh 执行权限，但是任然无法执行\n[root@localhost boot]# mount -o remount, exec /boot\n#记得改回来啊，要不会影啊系统启动的\n\n如果我们做试验修改了特殊选项，一定要记得住，而且确定需要修改，否则非常容易出现系统问题，而且还找不到哪里出现了问题。例3： 挂载分区\n[root@localhost ~]# mkdir /mnt/disk1\n#建立挂载点目录\n[root@localhost ~]# mount /dev/sdb1 /mnt/disk1\n#挂载分区\n\n2.光盘挂载光盘挂载的前提依然是指定光盘的设备文件名，不同版本的 Linux，设备文件名并不相同：Centos 5.x 以前的系统，光盘设备文件名是/dev/hdcCentos 6.x 以后的系统，光盘设备文件名是/dev/sr0不论哪个系统都有软连接/dev/cdrom，与可以作为光盘的设备文件名\n[root@localhost ~]# mount -t iso9660 /dev/cdrom /mnt/cdrom/\n#挂载光盘\n用完之后记得卸载：\n[root@localhost ~]# umount /dev/sr0\n[root@localhost ~]# umount /mnt/cdrom\n#因为设备文件名和挂载点已经连接到一起，卸载哪一个都可以\n注意：卸载的时候需要退出光盘目录，才能正常卸载\n3.挂载U盘U盘会和硬盘共用设备文件名，所以U盘的设备文件名不是固定的，需要手工查询，查询命令：\n[root@localhost ~]# fdisk\n#查询硬盘\n然后就是挂载了，挂载命令如下：\n[root@localhost ~]# mount -t vfat /dev/sdb1 /mnt/usb/\n#挂载u盘。因为是 Windows 分区，所以是 vfat 文件系统格式\n如果U盘中有中文，会发现中文是乱码。Linux 要想正常显示中文，需要两个条件：1.安装了中文编码和中文字体2.操作终端需要支持中文显示（纯字符终端，是不支持中文编码的）而我们当前系统是安装了中文编码和字体，而 xshell 远程终端是 Windows 下的程序，当然是支持中文显示的。那之所以挂载 U盘还出现乱码，是需要在挂载的时候，手工指定中文编码，例如：\n[root@localhost ~]# mount -t vfat -o iocharset=utf8 /dev/sdb1 /mnt/usb/\n#挂载口盘，指定中文编码格式为UTF-8\n#如果需要卸载，可以执行以下命令：\n[root@localhost ~]# umount /mnt/usb/\n\n4.挂载 NTFS 分区4.1 Linux 的驱动加载顺序：\n驱动直接放入系统内核之中。这种驱动主要是系统启动加载必须的驱动，数量较少。\n驱动以模块的形式放入硬盘。大多数驱动都已这种方式保存，保存位置在/ib/modules/3.10.0-862.el7.x86_64/kernel/中。\n驱动可以被 Linux 识别，但是系统认为这种驱动一般不常用，默认不加载。如果需要加载这种驱动，需要重新编译内核，而 NTFS 文件系统的驱动就属于这种情况。\n硬件不能被 Linux 内核识别，需要手工安装驱动。当然前提是厂商提供了该硬件针对 Linux的驱动，否则就需要自己开发驱动了。\n\n4.2 使用 NTFS-3G 安装 NTFS 文件系统模块\n下载 NTFS-3G 插件我们从网站 http://www.tuxera.com/community/ntfs-3g-download/ 下载 NTFS-3G 插件到 Linux服务器上。\n安装 NTFS-3G 插件在编译安裝 NTFS-3G 插件之前，要保证 gcc编译器已经安裝。具体安装命令如下：[root@localhost ~]# tar -zxvf ntfs-3g_ntfsprogs-2013.1.13.tgz\n#解压\n[root@localhost ~]# cd ntfs-3g_ntfsprogs-2013.1.13\n#进入解压目录\n[root@localhost ntfs-3g_ntfsprogs-2013.1.13]# ./configure\n#编译器准备。没有指定安装目录，安装到默认位置中\n[root@localhost ntfs-3g_ntfsprog s-2013.1.13]# make\n#编译\n[root@localhost ntfs-3g_ntfsprogS-2013.1.13]# make install\n#编译安装\n安装就完成了，已经可以挂载和使用 Windows 的 NTFS 分区了。不过需要注意挂载分区时的文件系统不是 ntfs，而是 ntfs-3g。挂载命令如下：[root@localhost ~]# mount -t ntfs-3g 分区设备文件名挂载点\n例如：\n[root@localhost ~]# mount -t ntfs-3g /dev/sdb1 / mnt/win\n\n\n","slug":"Linux/Linux常用命令","date":"2022-11-18T09:00:00.000Z","categories_index":"Linux","tags_index":"Linux","author_index":"YimooRua"},{"id":"5d27f50fa4c0422c709b72db5e188a60","title":"两数之和","content":"两数之和⭐️难度：简单\n给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 target 的那 两个 整数，并返回它们的数组下标。你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。你可以按任意顺序返回答案。\n示例 1：\n输入：nums &#x3D; [2,7,11,15], target &#x3D; 9\n输出：[0,1]\n解释：因为 nums[0] + nums[1] &#x3D;&#x3D; 9 ，返回 [0, 1] 。\n\n示例 2：\n输入：nums &#x3D; [3,2,4], target &#x3D; 6\n输出：[1,2]\n\n示例 3：\n输入：nums &#x3D; [3,3], target &#x3D; 6\n输出：[0,1]\n\n提示：\n\n2 &lt;= nums.length &lt;= 104\n-109 &lt;= nums[i] &lt;= 109\n-109 &lt;= target &lt;= 109\n只会存在一个有效答案进阶：你可以想出一个时间复杂度小于 O(n2) 的算法吗？\n\n答案：\nclass Solution &#123;\n    public int[] twoSum(int[] nums, int target) &#123;\n           int n=nums.length;\n           for(int i=0;i&lt;n;i++)&#123;\n               for(int j=i+1;j&lt;n;j++)&#123;\n                   if(nums[i]+nums[j]==target)&#123;\n                        return new int[]&#123;i,j&#125;;\n                        &#125;\n               &#125;\n          &#125;\n           return new int[]&#123;0&#125;;\n    &#125;\n&#125;\n","slug":"Others/leetcode-两数之和","date":"2022-11-17T09:00:00.000Z","categories_index":"Others","tags_index":"Others","author_index":"YimooRua"},{"id":"5a3620dc0ed1ed2321d682ea496911bb","title":"Mybatis学习笔记","content":"尚硅谷版Mybatis学习笔记一、Mybatis介绍什么是Mybatis答：1、Mybatis是一个半ORM（对象关系映射）框架，它内部封装了JDBC，开发时只需要关注SQL语句本身，不需要花费精力去处理加载驱动、创建连接、创建statement等繁杂的过程。程序员直接编写原生态sql，可以严格控制sql执行性能，灵活度高。\n2、MyBatis可以使用XML或注解来配置和映射原生信息，将POJO映射成数据库中的记录，避免了几乎所有的JDBC代码和手动设置参数以及获取结果集。\n3、通过xml文件或注解的方式将要执行的各种statement配置起来，并通过java对象和statement中sql的动态参数进行映射生成最终执行的sql语句，最后由mybatis框架执行sql并将结果映射为java对象并返回。（从执行sql到返回result的过程）。\nMybatis与Hibernate的区别答：1、Mybatis和hibernate不同，它不完全是一个ORM框架，因为MyBatis需要程序员自己编写Sql语句。\n2、Mybatis直接编写原生态sql，可以严格控制sql执行性能，灵活度高，非常适合对关系数据模型要求不高的软件开发，因为这类软件需求变化频繁，一但需求变化要求迅速输出成果。但是灵活的前提是mybatis无法做到数据库无关性，如果需要实现支持多种数据库的软件，则需要自定义多套sql映射文件，工作量大。\n3、Hibernate对象/关系映射能力强，数据库无关性好，对于关系模型要求高的软件，如果用hibernate开发可以节省很多代码，提高效率。\n为什么使用Mybatis答：1、基于SQL语句编程，相当灵活，不会对应用程序或者数据库的现有设计造成任何影响，SQL写在XML里，解除sql与程序代码的耦合，便于统一管理；提供XML标签，支持编写动态SQL语句，并可重用。\n2、与JDBC相比，减少了50%以上的代码量，消除了JDBC大量冗余的代码，不需要手动开关连接；\n3、很好的与各种数据库兼容（因为 MyBatis 使用 JDBC 来连接数据库，所以只要JDBC支持的数据库MyBatis都支持）。\n4、能够与Spring很好的集成；\n5、提供映射标签，支持对象与数据库的ORM字段关系映射；提供对象关系映射标签，支持对象关系组件维护。\nMybatis下载地址URL:Https://github.com/mybatis/mybatis-3\n二、Mybatis测试使用按官方文档简单使用Mybatis流程1.导入jar包：mybatis-3.4.1.jar &amp; mysql-connector-java.jar &amp; log4j.jar\n2.创建与数据表字段名对应的实体类\npublic class Goods &#123;\nprivate Integer goodsId;\nprivate String title;\nprivate String subTitle;\nprivate Float originalCost;\nprivate Float currentPrice;\nprivate Float discount;\nprivate Integer isFreeDelivery;\nprivate Integer categoryId;\n...\n&#125;\n\n3.创建全局配置文件Mybatis-Config.xml\n&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot; ?&gt;\n&lt;!DOCTYPE configuration\n        PUBLIC &quot;-&#x2F;&#x2F;mybatis.org&#x2F;&#x2F;DTD Config 3.0&#x2F;&#x2F;EN&quot;\n        &quot;http:&#x2F;&#x2F;mybatis.org&#x2F;dtd&#x2F;mybatis-3-config.dtd&quot;&gt;\n&lt;configuration&gt;\n    &lt;environments default&#x3D;&quot;development&quot;&gt;\n        &lt;environment id&#x3D;&quot;development&quot;&gt;\n            &lt;transactionManager type&#x3D;&quot;JDBC&quot;&#x2F;&gt;\n            &lt;dataSource type&#x3D;&quot;POOLED&quot;&gt;\n                &lt;property name&#x3D;&quot;driver&quot; value&#x3D;&quot;com.mysql.jdbc.Driver&quot;&#x2F;&gt;\n                &lt;property name&#x3D;&quot;url&quot; value&#x3D;&quot;jdbc:mysql:&#x2F;&#x2F;localhost:3306&#x2F;babytun?useUnicode&#x3D;true&amp;characterEncoding&#x3D;utf-8&quot;&#x2F;&gt;\n                &lt;property name&#x3D;&quot;username&quot; value&#x3D;&quot;root&quot;&#x2F;&gt;\n                &lt;property name&#x3D;&quot;password&quot; value&#x3D;&quot;1234567890&quot;&#x2F;&gt;\n            &lt;&#x2F;dataSource&gt;\n        &lt;&#x2F;environment&gt;\n    &lt;&#x2F;environments&gt;\n    &lt;mappers&gt;\n        &lt;!-- 将我们写好的sql映射文件（GoodsMapper.xml）一定要注册到全局配置文件（Mybatis-Config.xml）中 --&gt;\n        &lt;mapper resource&#x3D;&quot;Mapper&#x2F;GoodsMapper.xml&quot;&#x2F;&gt;\n    &lt;&#x2F;mappers&gt;\n&lt;&#x2F;configuration&gt;\n\n4.创建Mapper映射文件\n&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot; ?&gt;\n&lt;!DOCTYPE mapper\n        PUBLIC &quot;-&#x2F;&#x2F;mybatis.org&#x2F;&#x2F;DTD Mapper 3.0&#x2F;&#x2F;EN&quot;\n        &quot;http:&#x2F;&#x2F;mybatis.org&#x2F;dtd&#x2F;mybatis-3-mapper.dtd&quot;&gt;\n&lt;mapper namespace&#x3D;&quot;com.imooc.POJO.GoodsMapper&quot;&gt;\n    &lt;!--\n     接口式编程：\n     namespace:名称空间;指定为接口的全类名\n     id：唯一标识\n     resultType：返回值类型\n     #&#123;id&#125;：从传递过来的参数中取出id值\n--&gt;\n    &lt;select id&#x3D;&quot;selectGoods&quot; resultType&#x3D;&quot;com.imooc.POJO.Goods&quot;&gt;\n        select goods_id goodsId,title title,sub_title subTitle,original_cost originalCost,current_price currentPrice,discount discount,is_free_delivery isFreeDelivery,category_id categoryId\n        from t_goods\n        where goods_id &#x3D; #&#123;id&#125;\n    &lt;&#x2F;select&gt;\n&lt;&#x2F;mapper&gt;\n\n4.创建测试类（1.Mapper命名空间+id值；2.接口式编程（推荐））\n/**\n * 1、接口式编程\n *     原生：       Dao       ====>  DaoImpl\n *     mybatis：   Mapper ====>  xxMapper.xml\n *\n * 2、SqlSession代表和数据库的一次会话；用完必须关闭；\n * 3、SqlSession和connection一样她都是非线程安全。每次使用都应该去获取新的对象。\n * 4、mapper接口没有实现类，但是mybatis会为这个接口生成一个代理对象。\n *        （将接口和xml进行绑定）\n *        EmployeeMapper empMapper = sqlSession.getMapper(EmployeeMapper.class);\n * 5、两个重要的配置文件：\n *        mybatis的全局配置文件：包含数据库连接池信息，事务管理器信息等...系统运行环境信息\n *        sql映射文件：保存了每一个sql语句的映射信息：\n *                 将sql抽取出来。\n *\n *\n * @author Yimoo\n *\n */\npublic class mybatisTest &#123;\n    public SqlSessionFactory getSqlSessionFactory() throws IOException&#123;\n        String resource=\"Mybatis-Config.xml\";\n        InputStream inputStream=Resources.getResourceAsStream(resource);\n        return new SqlSessionFactoryBuilder().build(inputStream);\n    &#125;\n\n    /**\n     * 1、根据xml配置文件（全局配置文件）创建一个SqlSessionFactory对象 有数据源一些运行环境信息\n     * 2、sql映射文件；配置了每一个sql，以及sql的封装规则等。\n     * 3、将sql映射文件注册在全局配置文件中\n     * 4、写代码：\n     *        1）、根据全局配置文件得到SqlSessionFactory；\n     *        2）、使用sqlSession工厂，获取到sqlSession对象使用他来执行增删改查\n     *           一个sqlSession就是代表和数据库的一次会话，用完关闭\n     *        3）、使用sql的唯一标志来告诉MyBatis执行哪个sql。sql都是保存在sql映射文件中的。\n     *\n     * @throws IOException\n     *\n     */\n    @Test\n    public void demo1() throws IOException &#123;\n        // 2、获取sqlSession实例，能直接执行已经映射的sql语句\n        // sql的唯一标识：statement Unique identifier matching the statement to use.\n        // 执行sql要用的参数：parameter A parameter object to pass to the statement.\n        SqlSessionFactory sqlSessionFactory=getSqlSessionFactory();\n        SqlSession sqlSession=sqlSessionFactory.openSession();\n         try&#123;\n             Goods goods=sqlSession.selectOne(\"com.imooc.POJO.GoodsMapper.selectGoods\",800);\n             System.out.println(goods);\n         &#125;finally &#123;\n             sqlSession.close();\n         &#125;\n    &#125;\n  \n  @Test\n    public void demo2() throws IOException &#123;\n        SqlSessionFactory sqlSessionFactory=getSqlSessionFactory();\n        SqlSession sqlSession=sqlSessionFactory.openSession();\n        try&#123;\n            // 3、获取接口的实现类对象\n            //会为接口自动的创建一个代理对象，代理对象去执行增删改查方法\n            GoodsMapper goodsMapper=sqlSession.getMapper(GoodsMapper.class);\n            Goods goods=goodsMapper.selectGoods(900);\n            System.out.println(goods);\n          //输出：Goods&#123;goodsId=900, title='三星 2016版 Galaxy On7（G6100）全网通4G 3GB+32G 钛岩黑 手机',          subTitle='美囤自营，品质保证！5.5英寸屏，3GB+32GB，双账户应用工作生活两不误！', originalCost=1799.0, currentPrice=1299.0, discount=0.722068, isFreeDelivery=1, categoryId=30&#125;\n            //自动创建代理\n            System.out.println(goodsMapper.getClass());//输出：class com.sun.proxy.$Proxy6\n        &#125;finally &#123;\n            sqlSession.close();\n        &#125;\n    &#125;\n&#125;\n\n如何让实体类的属性名与数据库字段名一一对应1.在mapper文件中sql语句处为字段名设置别名，别名为实体类的属性名\n&lt;select id=\"selectGoods\" resultType=\"com.imooc.POJO.Goods\">\n    select goods_id goodsId,title title,sub_title subTitle,original_cost originalCost,current_price currentPrice,discount discount,is_free_delivery isFreeDelivery,category_id categoryId\n    from t_goods\n    where goods_id = #&#123;id&#125;\n&lt;/select>\n\n2.在全局配置文件中配置mapUndertocamleCase=true，前提是必须属性名与字段名为驼峰命名关系\n&lt;settings>\n    &lt;setting name=\"mapUnderScoretoCamleCase\" value=\"\"/>\n&lt;/settings>\n\n三、全局配置文件的标签configuration mybatis-3.5.9.pdf官方文档 \n• properties• settings• typeAliases• typeHandlers• objectFactory（了解）• plugins• environments      • environment           • transactionManager               • dataSource               • databaseIdProvider• mappers\nproperties属性（属性文件）&lt;!--\n\t\t1、mybatis可以使用properties来引入外部properties配置文件的内容；\n\t\tresource：引入类路径下的资源\n\t\turl：引入网络路径或者磁盘路径下的资源\n\t  -->\n\t&lt;properties resource=\"dbconfig.properties\">&lt;/properties>\n\ndbconfig.properties文件\njdbc.driver=com.mysql.jdbc.Driver\njdbc.url=jdbc:mysql://localhost:3306/babytun?useUnicode=true&amp;amp;characterEncoding=utf-8\njdbc.username=root\njdbc.password=1234567890\n\norcl.driver=oracle.jdbc.OracleDriver\norcl.url=jdbc:oracle:thin:@localhost:1521:orcl\norcl.username=scott\norcl.password=123456\n\n修改environment标签下的properties的value值\n&lt;property name=\"driver\" value=\"$&#123;jdbc.driver&#125;\"/>\n&lt;property name=\"url\" value=\"$&#123;jdbc.url&#125;\"/>\n&lt;property name=\"username\" value=\"$&#123;jdbc.username&#125;\"/>\n&lt;property name=\"password\" value=\"$&#123;jdbc.password&#125;\"/>\n\nsettings设置（自动开启驼峰命名规则）这是Mybatis中极为重要的调整设置，它们会改变Mybatis的运行时行为\nmapUnderscoreToCamelCase：是否开启自动驼峰命名规则映射，即从经典数据库列名A_COLUMN到经典Java属性名aColumn的类似映射\n&lt;settings>\n    &lt;setting name=\"mapUnderscoreToCamelCase\" value=\"true\"/>\n&lt;/settings>\n\ntypeAliases别名处理器（java类型起别名）类型别名是为Java类型设置一个短的名字，方便我们引用某个类\n&lt;typeAliases>\n&lt;typeAlias type=\"com.imooc.POJO.Goods\" alias=\"goods\"/>\n&lt;/typeAliases>\n\n类很多的情况下，可以批量设置这个包下的每一个类创建一个默认的别名，就是简单类名小写。\n&lt;typeAliases>\n&lt;!--        别名不区分大小写-->\n        &lt;package name=\"com.imooc.POJO\"/>\n    &lt;/typeAliases>\n\n也可以使用注解@Alias注解为其指定一个别名（注意只有使用批量起别名时，才可以使用注解起别名）\n&lt;typeAliases>\n&lt;!--        别名不区分大小写-->\n        &lt;package name=\"com.imooc.POJO\"/>\n    &lt;/typeAliases>\n\n@Alias(\"goods\")\npublic class Goods &#123;\n...\n&#125;\n\nMyBatis已经为许多常见的 Java 类型内建了相应的类型别名。它们都是大小写不敏感的，我们在起别名的时候千万不要占用已有的别名\n\n\n\n别名\n映射的类型\n别名\n映射的类型\n别名\n映射的类型\n\n\n\n_byte\nbyte\nstring\nString\ndate\nDate\n\n\n_long\nlong\nbyte\nByte\ndecimal\nBigDecimal\n\n\n_short\nshort\nlong\nLong\nbigdecimal\nBigDecimal\n\n\n_int\nint\nshort\nShort\nobject\nObject\n\n\n_integer\nint\nint\nInteger\nmap\nMap\n\n\n_double\ndouble\ndouble\nDouble\nhashmap\nHashMap\n\n\n_float\nfloat\nfloat\nFloat\nlist\nList\n\n\n_boolean\nboolean\nboolean\nBoolean\narraylist\nArrayList\n\n\n\n\n\n\ncollection\nCollection\n\n\n\n\n\n\niterator\nIterator\n\n\ntypeHandlers类型处理器无论是 MyBatis 在预处理语句（PreparedStatement）中设置一个参数时，还是从结果集中取出一个值时， 都会用类型处理器将获取的值以合适的方式转换成 Java 类型。\n\n\n\n类型处理器\nJava 类型\nJDBC 类型\n\n\n\nBooleanTypeHandler\njava.lang.Boolean, boolean\n数据库兼容的 BOOLEAN\n\n\nByteTypeHandler\njava.lang.Byte, byte\n数据库兼容的 NUMERIC 或 BYTE\n\n\nShortTypeHandler\njava.lang.Short, short\n数据库兼容的 NUMERIC 或 SHORT INTEGER\n\n\nIntegerTypeHandler\njava.lang.Integer, int\n数据库兼容的 NUMERIC 或 INTEGER\n\n\nLongTypeHandler\njava.lang.Long, long\n数据库兼容的 NUMERIC 或 LONG INTEGER\n\n\nFloatTypeHandler\njava.lang.Float, float\n数据库兼容的 NUMERIC 或 FLOAT\n\n\nDoubleTypeHandler\njava.lang.Double, double\n数据库兼容的 NUMERIC 或 DOUBLE\n\n\nBigDecimalTypeHandler\njava.math.BigDecimal\n数据库兼容的 NUMERIC 或 DECIMAL\n\n\nStringTypeHandler\njava.lang.String\nCHAR, VARCHAR\n\n\n日期类型的处理1、日期和时间的处理，JDK1.8以前一直是个头疼的问题。我们通常使用JSR310规范领导者Stephen Colebourne创建的Joda-Time来操作。1.8已经实现全部的JSR310规范了。2、日期时间处理上，我们可以使用MyBatis基于JSR310（Date and Time API）编写的各种日期时间类型处理器。3、MyBatis3.4以前的版本需要我们手动注册这些处理器，以后的版本都是自动注册的。\n自定义类型处理器我们可以重写类型处理器或创建自己的类型处理器来处理不支持的或非标准的类型。步骤：1）、实现org.apache.ibatis.type.TypeHandler接口或者继承org.apache.ibatis.type.BaseTypeHandler2）、指定其映射某个JDBC类型（可选操作）3）、在mybatis全局配置文件中注册\nplugins插件（先学习Mybatis工作原理才能理解）插件是MyBatis提供的一个非常强大的机制，我们可以通过插件来修改MyBatis的一些核心行为。插件通过动态代理机制，可以介入四大对象的任何一个方法的执行。后面会有专门的章节我们来介绍mybatis运行原理以及插件\n四大对象\n• Executor (update, query, flushStatements, commit, rollback, getTransaction, close, isClosed)\n• ParameterHandler (getParameterObject, setParameters) \n• ResultSetHandler (handleResultSets, handleOutputParameters) \n• StatementHandler (prepare, parameterize, batch, update, query) \nenvironments环境&lt;environments default=\"\">\n    &lt;environment id=\"\">\n        &lt;transactionManager type=\"\"/>\n        &lt;dataSource type=\"\">\n            &lt;property name=\"driver\" value=\"\"/>\n            &lt;property name=\"url\" value=\"\"/>\n            &lt;property name=\"username\" value=\"\"/>\n            &lt;property name=\"password\" value=\"\"/>\n        &lt;/dataSource>\n    &lt;/environment>\n&lt;/environments>\n\n1、&lt;environments default=&quot;&quot;/&gt;\n• MyBatis可以配置多种环境，比如开发、测试和生产环境需要有不同的配置。 \n• 每种环境使用一个environment标签进行配置并指定唯一标识符\n• 可以通过environments标签中的default属性指定一个环境的标识符来快速的切换环境\n2、&lt;environment id=&quot;”&gt;&lt;transactionManager type=&quot;&quot;/&gt;&lt;dataSource type=&quot;&quot;&gt;&lt;/dataSource&gt;&lt;/environment&gt;\n• id：指定当前环境的唯一标识\n• transactionManager、和dataSource都必须有\n3、&lt;transactionManager type=&quot;JDBC|MANAGED|自定义&quot;&gt;\n• JDBC：使用了 JDBC 的提交和回滚设置，依赖于从数据源得到的连接来管理事务范围。JdbcTransactionFactory\n• MANAGED：不提交或回滚一个连接、让容器来管理事务的整个生命周期（比如 JEE 应用服务器的上下文）。 ManagedTransactionFactory\n• 自定义：实现TransactionFactory接口，type=全类名/别名\n4、&lt;dataSource type=&quot;UPOOLED|POOLED|JNDI|自定义&quot;&gt;...&lt;/dataSource&gt;\n• UNPOOLED：不使用连接池，UnpooledDataSourceFactory\n• POOLED：使用连接池， PooledDataSourceFactory\n• JNDI： 在EJB 或应用服务器这类容器中查找指定的数据源\n• 自定义：实现DataSourceFactory接口，定义数据源的获取方式。\n• 实际开发中我们使用Spring管理数据源，并进行事务控制的配置来覆盖上述配置\ndatabaseIdProvider环境（数据库的移植性）MyBatis 可以根据不同的数据库厂商执行不同的语句。 \n• Type： DB_VENDOR\n– 使用MyBatis提供的VendorDatabaseIdProvider解析数据库厂商标识。也可以实现DatabaseIdProvider接口来自定义。 \n• Property-name：数据库厂商标识\n• Property-value：为标识起一个别名，方便SQL语句使用databaseId属性引用\nDB_VENDOR\n– 会通过 DatabaseMetaData#getDatabaseProductName() 返回的字符串进行设置。由于通常情况下这个字符串都非常长而且相同产品的不同版本会返回不同的值，所以最好通过设置属性别名来使其变短 \n• MyBatis匹配规则如下：\n1、如果没有配置databaseIdProvider标签，那么databaseId=null\n2、如果配置了databaseIdProvider标签，使用标签配置的name去匹配数据库信息，匹配上设置databaseId=配置指定的值，否则依旧为null\n3、如果databaseId不为null，他只会找到配置databaseId的sql语句\n4、MyBatis 会加载不带 databaseId 属性和带有匹配当前数据库databaseId 属性的所有语句。如果同时找到带有 databaseId 和不带databaseId 的相同语句，则后者会被舍弃。\nmapper映射（将sql映射注册到全局配置中）&lt;mappers>\n    &lt;!--resource：引用类路径下的sql映射文件-->\n    &lt;mapper resource=\"Mapper/GoodsMapper.xml\"/>\n    &lt;!--url：引用网络路径或者磁盘路径下的sql映射文件-->\n    &lt;mapper url=\"file://D://GoodsMapper.xml\"/>\n    &lt;!--class：引用（注册）接口\n        1、有sql映射文件，映射文件名必须和接口同名，并且放在与接口同一目录下\n        2、没有sql映射文件，所有sql都是利用注解写在接口上\n        推荐：比较重要的DAO接口我们写sql映射文件\n             不重要，简答的DAO接口为了快速开发可以使用注解-->\n    &lt;mapper class=\"com.imooc.DAO.GoodsMapper\"/>\n    &lt;!--package：批量注解，自动扫描包下映射文件-->\n    &lt;package name=\"com.imooc.DAO\"/>\n&lt;/mappers>\n\n四、Mybatis映射文件映射文件指导着MyBatis如何进行数据库增删改查，有着非常重要的意义；\n映射文件的元素，如下：\n•cache –命名空间的二级缓存配置•cache-ref – 其他命名空间缓存配置的引用。•resultMap – 自定义结果集映射•parameterMap – 已废弃！老式风格的参数映射•sql –抽取可重用语句块。•insert – 映射插入语句•update – 映射更新语句•delete – 映射删除语句•select – 映射查询语句\ninsert、update、delete元素测试增删改\n1、parameterType：参数类型，可以省略\n2、mybatis允许增删改直接定义以下类型返回值\nInteger、long、Boolean、void\n3、需要手动提交commit\n手动提交：sqlSessionFactory,openSession();\n自动提交：sqlSessionFactory.openSession(true);\n主键生成方式1、mysql支持自增主键，自增主键值的获取，mybatis是利用statement.getGenreatedKeys()；\nuseGeneratedKeys=”true”：使用自增主键获取主键值策略\nkeyProperty：指定对应的主键属性（对应的JavaBean的属性名），也就是mybatis获取到主键值以后，将这个值封装给javaBean的对应的属性\n&lt;insert id=\"insertGoods\" useGeneratedKeys=\"true\" keyProperty=\"goodsId\" databaseId=\"mysql\">\n    insert into t_goods(title,sub_title,original_cost,current_price,discount,is_free_delivery,category_id)\n    values (#&#123;title&#125;,#&#123;subTitle&#125;,#&#123;originalCost&#125;,#&#123;currentPrice&#125;,#&#123;discount&#125;,#&#123;isFreeDelivery&#125;,#&#123;categoryId&#125;)\n&lt;/insert>\n\n 2、oracle不支持自增主键，它使用的是序列来模拟自增，每次插入数据的主键是从序列中拿到的值。\n获取主键值可以使用 selectKey 子元素：selectKey 元素将会首先运行，id 会被设置，然后插入语句会被调用\nOrder=”BEFORE”：当前sql在插入sql之前运行\n&lt;insert id=\"insertEmployee\" databaseId=\"oracle\">\n    &lt;selectKey keyProperty=\"id\" order=\"BEFORE\" resultType=\"Integer\">\n        select EMPLOYEES_SEQ.nextval from dual\n    &lt;/selectKey>\n    insert into employee(EMPLOYEE_ID,LAST_NAME,EMAIL)\n    values (#&#123;id&#125;,#&#123;lastName&#125;,#&#123;email&#125;)\n&lt;/insert>\n\n执行流程：\n先运行selectKey查询id的sql，查出id值封装给javaBean的id属性\n在运行插入的sql；就可以取出id属性对应的值\nselectKey标签中各属性的作用：\n参数处理1、单参数：没有限制，通过接口方法直接传参2、多个参数：mybatis会做特殊处理，多个参数被封装成一个map三种方法：• 使用#{param1},#{param2}…\n• （命名参数）在接口方法参数前指定(@Param(“属性名”) Object 属性名,@Param(“属性名”) Object 属性名…)多个参数会封装成map，key==》@param(“属性名”)，value ==》方法参数值\n• 如果多个参数正好是我们逻辑业务的数据模型，我们可以直接传入POJO#{属性名}：取出传入的POJO的属性值\n• 如果多个参数不是业务模型中的数据，没有对应的POJO，不经常使用为了方便，也可以传入map#{key}：取出map中对应的值如果多个参数不是业务模型中的数据，但经常使用，推荐来编写一个TO（Transfer Object）数据传输\n Page{Int index;int size;}\n========================思考================================public Employee getEmp(@Param(“id”)Integer id,String lastName);    取值：id==&gt;#{id/param1}   lastName==&gt;#{param2}\npublic Employee getEmp(Integer id,@Param(“e”)Employee emp);    取值：id==&gt;#{param1}    lastName===&gt;#{param2.lastName/e.lastName}\n##特别注意：如果是Collection（List、Set）类型或者是数组，         也会特殊处理。也是把传入的list或者数组封装在map中。            key：Collection（collection）,如果是List还可以使用这个key(list)                数组(array)public Employee getEmpById(List ids);    取值：取出第一个id的值：   #{list[0]}\n========================结合源码，mybatis怎么处理参数======================总结：参数多时会封装map，为了不混乱，我们可以使用@Param来指定封装时使用的key；#{key}就可以取出map中的值；\n(@Param(“id”)Integer id,@Param(“lastName”)String lastName);ParamNameResolver解析参数封装map的；//1、names：{0=id, 1=lastName}；构造器的时候就确定好了      1.获取每个标了param注解的参数的@param的值：id，lastName，赋值给name;      2.每次解析一个参数给map中保存信息：（key：参数索引，value：name的值）                name的值：                   标注了param注解：注解的值                    没有标注：                        1.全局配置：useActualParamName（jdk1.8）：name=参数名                        2.name=map.size();相当于当前的元素的索引                        {0=id,1=lastName,2=2}\n#{}与${}的区别相同点：都可以获取map中的值或者pojo对象的属性的值\n不同点：1.取值：#{}会用占位符预编译PreparedStatement到SQL中，${}会用字符串拼接SQL2.安全性：#{}能预防SQL注入\n${}的用处：原生jdbc不支持占位符的地方我们就可以使用${}进行取值比如分表、排序…：按照年份分表拆分             select * from ${year}_salary where xxx;             select *  from tbl_employee order by ${f_name} ${order}\n#{}其他用法：   规定一些参数的规则：   javaType、==jdbctype==、mode（存储过程）、numericScale、resultType、typeHandler、jdbcTypeName、expression（未来准备支持的功能）\n   jdbcType通常需要在某种特定的条件下被设置：   在我们数据为null的时候，有些数据库可能不能被识别mybatis对null的默认处理。比如Oracle（报错）；   JdbcType OTHER：无效的类型；因为mybatis对所有的null都映射的是原生Jdbc的OTHER类型，orcal不认识   由于全局配置：jdbcTypeForNull=OTHER；oracle不支持；两种解决办法：   1、在对应sql参数中书写#{email,jdbcType=OTHER}   2、在全局配置中设置                     \nselect元素Select元素来定义查询操作。\n• Id：唯一标识符。– 用来引用这条语句，需要和接口的方法名一致\n• parameterType：参数类型。 – 可以不传，MyBatis会根据TypeHandler自动推断\n• resultType：返回值类型。 – 别名或者全类名，如果返回的是集合，定义集合中元素的类型。不能和resultMap同时使用\n1、List集合返回值的查询方法：\npublic List&lt;Goods> getGoodsByTitleLike(String title);\n\n&lt;select id=\"getEmpsByTitleLike\" resultType=\"com.imooc.POJO.Goods\">\n        select * from t_goods where title like #&#123;title&#125;\n    &lt;/select>\n控制台输出内容：\nDEBUG 05-14 17:50:44,942 ==>  Preparing: select * from t_goods where title like ?  (BaseJdbcLogger.java:137) \nDEBUG 05-14 17:50:44,967 ==> Parameters: %分娩%(String)  (BaseJdbcLogger.java:137) \nDEBUG 05-14 17:50:44,985 &lt;==      Total: 2  (BaseJdbcLogger.java:137) \n北京和睦家医院自然分娩+无痛套餐（宝宝树专享，限定预产期2017年9月30日前）\n北京和睦家医院自然分娩+无痛套餐（宝宝树专享，限定预产期2017年9月30日前）\n\n2、Map集合返回值的查询方法：\na.单条记录封装\n\npublic Map&lt;String,Object> getGoodsByIdReturnMap(Integer goodsId);\n\n&lt;select id=\"getGoodsByIdReturnMap\" resultType=\"map\">\n        select * from t_goods where goods_id=#&#123;goodsId&#125;\n    &lt;/select>\nDEBUG 05-14 17:52:51,885 ==>  Preparing: select * from t_goods where goods_id=?  (BaseJdbcLogger.java:137) \nDEBUG 05-14 17:52:51,909 ==> Parameters: 800(Integer)  (BaseJdbcLogger.java:137) \nDEBUG 05-14 17:52:51,926 &lt;==      Total: 1  (BaseJdbcLogger.java:137) \n&#123;original_cost=279.0, sub_title=德国原产 欧洲直邮 德国 Hipp喜宝 益生菌 奶粉, is_free_delivery=1, category_id=46, goods_id=800, discount=0.892473, current_price=249.0, title=喜宝HiPP 【欧洲直邮】德国Hipp喜宝益生菌奶粉2段 600g*2&#125;\nb.多条记录封装，map的键为记录的主键，map的值为记录的值\n@MapKey(\"goodsId\") //告诉mybatis封装这个Map用哪个属性作为key\n  public Map&lt;Integer,Goods> getGoodsByTitleLikeReturnMap(String title);\n\n&lt;select id=\"getGoodsByTitleLikeReturnMap\" resultType=\"com.imooc.POJO.Goods\">\n      select * from t_goods where title like #&#123;title&#125;\n  &lt;/select>\n控制台输出内容：\nDEBUG 05-14 18:07:17,480 ==>  Preparing: select * from t_goods where title like ?  (BaseJdbcLogger.java:137) \nDEBUG 05-14 18:07:17,508 ==> Parameters: %分娩%(String)  (BaseJdbcLogger.java:137) \nDEBUG 05-14 18:07:17,525 &lt;==      Total: 2  (BaseJdbcLogger.java:137) \n&#123;\n752=Goods&#123;goodsId=752, title='北京和睦家医院自然分娩+无痛套餐（宝宝树专享，限定预产期2017年9月30日前）', subTitle='24小时售前咨询电话：400-891-9191', originalCost=76000.0, currentPrice=47880.0, discount=0.63, isFreeDelivery=1, categoryId=56&#125;, \n1264=Goods&#123;goodsId=1264, title='北京和睦家医院自然分娩+无痛套餐（宝宝树专享，限定预产期2017年9月30日前）', subTitle='24小时售前咨询电话：400-891-9191', originalCost=76000.0, currentPrice=47880.0, discount=0.63, isFreeDelivery=1, categoryId=46&#125;\n&#125;\n\nresultType属性1、全局setting设置\n– autoMappingBehavior默认是PARTIAL，开启自动映射的功能。唯一的要求是列名和javaBean属性名一致\n– 如果autoMappingBehavior设置为null则会取消自动映射\n– 数据库字段命名规范，POJO属性符合驼峰命名法，如A_COLUMNaColumn，我们可以开启自动驼峰命名规则映射功能，mapUnderscoreToCamelCase=true。\n2.自定义resultMap，实现高级结果集映射\n等效于resultType的实例如下：\n//接口方法\npublic Goods selectGoods(Integer id);\n\n&lt;!--自定义某个javaBean的封装规则\n     type：自定义规则-->\n    &lt;resultMap id=\"myGoods\" type=\"com.imooc.POJO.Goods\">\n        &lt;!--column字段名，property属性名-->\n        &lt;id column=\"goods_id\" property=\"goodsId\"/>\n        &lt;result column=\"title\" property=\"title\"/>\n        &lt;result column=\"sub_title\" property=\"subTitle\"/>\n        &lt;result column=\"original_cost\" property=\"originalCost\"/>\n        &lt;result column=\"current_price\" property=\"currentPrice\"/>\n        &lt;result column=\"discount\" property=\"discount\"/>\n        &lt;result column=\"is_free_delivery\" property=\"isFreeDelivery\"/>\n        &lt;result column=\"category_id\" property=\"categoryId\"/>\n    &lt;/resultMap>\n    &lt;select id=\"selectGoods\" resultMap=\"myGoods\">\n         select * from t_goods where goods_id=#&#123;goodsId&#125;\n    &lt;/select>\n\n控制台输出如下：（实现效果跟自动resultType=Goods自动封装一样，但支持高级自定）\nDEBUG 05-14 18:33:51,774 ==>  Preparing: select * from t_goods where goods_id=?  (BaseJdbcLogger.java:137) \nDEBUG 05-14 18:33:51,807 ==> Parameters: 800(Integer)  (BaseJdbcLogger.java:137) \nDEBUG 05-14 18:33:51,826 &lt;==      Total: 1  (BaseJdbcLogger.java:137) \nGoods&#123;goodsId=800, title='喜宝HiPP 【欧洲直邮】德国Hipp喜宝益生菌奶粉2段 600g*2', subTitle='德国原产 欧洲直邮 德国 Hipp喜宝 益生菌 奶粉', originalCost=279.0, currentPrice=249.0, discount=0.892473, isFreeDelivery=1, categoryId=46&#125;\n\nassociation的三种使用方法1.result\n2.分步查询\n3.延迟加载属性\n每次查询Goods对象时，总是把对应id的detail信息查询出来。使用lazyLoadingEnable属性我们想要在需要时在查询出来\nlazyLoadingenabled：true，开启延迟加载，按需查询\naggressiveLazyLoading：false，开启按需查询，true，关闭按需查询，全部查询出来\n&lt;setting name=\"lazyLoadingEnabled\" value=\"true\"/>\n&lt;setting name=\"aggressiveLazyLoading\" value=\"false\"/>\n\n4.多对一查询\n用N的一方GoodsDetail查询Goods的信息\n代码实例如下\n//GoodsMapper.xml\n&lt;select id=\"selectGoodsById\" resultType=\"com.imooc.POJO.Goods\">\n        select *\n        from t_goods\n        where goods_id = #&#123;goodsId&#125;\n    &lt;/select>\n\n//GoodsDetailMapper.xml\n&lt;resultMap id=\"manyToOne\" type=\"com.imooc.POJO.GoodsDetail\">\n     &lt;id column=\"gd_id\" property=\"gdId\"/>\n    &lt;association property=\"goods\" column=\"goods_id\" select=\"com.imooc.DAO.GoodsMapper.selectGoodsById\"/>\n&lt;/resultMap>\n&lt;select id=\"selectGoodsByAsscoiation\" resultMap=\"manyToOne\">\n    select * from t_goods_detail where goods_id=#&#123;goodsId&#125;\n&lt;/select>\n\n一对多查询（collection）\n1的一方为Goods，n的一方为GoodsDetail，查询Goods的同时查询GoodsDetail对应id信息\n代码实例如下：\n//1：在Goods实体类里增加goodsDet\npublic class Goods &#123;\n...\nprivate List&lt;GoodsDetail> goodsDetails;\n...\n&#125;\n\n//N\npublic class GoodsDetail &#123;\n    private Integer gdId;\n    private Integer godsId;\n    private String gdPicUrl;\n    private Integer gdOrder;\n &#125;\n\n//GoodsMapper接口\npublic interface GoodsMapper &#123;\npublic List&lt;Goods> getGoodsDetailByOneToMany(Integer goodsId);\n&#125;\n\n//GoodsDetailMapper接口\npublic interface GoodsDetailMapper &#123;\n    public List&lt;GoodsDetail> selectDetailById(Integer gdId);\n&#125;\n\n&lt;resultMap id=\"MyGoodsByOneToMany\" type=\"com.imooc.POJO.Goods\">\n        &lt;id column=\"goods_id\" property=\"goodsId\"/>\n        &lt;!--可以省略其他result设定，前提是javabean属性名与字段名一一对应-->\n        &lt;!--association定义关联对象的封装规则\n           select：表名当前属性是调用select指定的方法查出的结果\n           column=\"指定将那一列的值传给这个方法\"\n           使用select指定的方法传入column指定的参数值，并封装给property封装的值\n        -->\n   &lt;collection property=\"goodsDetails\" select=\"com.imooc.DAO.GoodsDetailMapper.selectDetailById\" column=\"goods_id\"/>\n    &lt;/resultMap>\n    &lt;select id=\"getGoodsDetailByOneToMany\" resultMap=\"MyGoodsByOneToMany\">\n        select * from t_goods where goods_id=#&#123;goodsId&#125;\n    &lt;/select>\n\n&lt;!--GoodsDetail的SQL查询方法-->\n&lt;select id=\"selectDetailById\" resultType=\"com.imooc.POJO.GoodsDetail\">\n    select * from t_goods_detail where goods_id = #&#123;gdId&#125;\n&lt;/select>\n\n五、动态SQL\nMybatis框架的动态SQL技术是一种根据特定条件动态拼装SQL语句的功能，它存在的意义是为了解决拼接SQL语句字符串时的痛点问题\n\nif\nif标签可通过test属性（即传递过来的数据）的表达式进行判断，若表达式的结果为true，则标签中的内容会执行；反之标签中的内容不会执行\n在where后面添加一个恒成立条件1=1\n这个恒成立条件并不会影响查询的结果\n这个1=1可以用来拼接and语句，例如：当empName为null时\n如果不加上恒成立条件，则SQL语句为select * from t_emp where and age = ? and sex = ? and email = ?，此时where会与and连用，SQL语句会报错\n如果加上一个恒成立条件，则SQL语句为select * from t_emp where 1= 1 and age = ? and sex = ? and email = ?，此时不报错\n\n\n\n\n\n&lt;!--List&lt;Emp> getEmpByCondition(Emp emp);-->\n&lt;select id=\"getEmpByCondition\" resultType=\"Emp\">\n\tselect * from t_emp where 1=1\n\t&lt;if test=\"empName != null and empName !=''\">\n\t\tand emp_name = #&#123;empName&#125;\n\t&lt;/if>\n\t&lt;if test=\"age != null and age !=''\">\n\t\tand age = #&#123;age&#125;\n\t&lt;/if>\n\t&lt;if test=\"sex != null and sex !=''\">\n\t\tand sex = #&#123;sex&#125;\n\t&lt;/if>\n\t&lt;if test=\"email != null and email !=''\">\n\t\tand email = #&#123;email&#125;\n\t&lt;/if>\n&lt;/select>\n\nwhere\nwhere和if一般结合使用：\n若where标签中的if条件都不满足，则where标签没有任何功能，即不会添加where关键字  \n若where标签中的if条件满足，则where标签会自动添加where关键字，并将条件最前方多余的and/or去掉  \n\n\n\n&lt;!--List&lt;Emp> getEmpByCondition(Emp emp);-->\n&lt;select id=\"getEmpByCondition\" resultType=\"Emp\">\n\tselect * from t_emp\n\t&lt;where>\n\t\t&lt;if test=\"empName != null and empName !=''\">\n\t\t\temp_name = #&#123;empName&#125;\n\t\t&lt;/if>\n\t\t&lt;if test=\"age != null and age !=''\">\n\t\t\tand age = #&#123;age&#125;\n\t\t&lt;/if>\n\t\t&lt;if test=\"sex != null and sex !=''\">\n\t\t\tand sex = #&#123;sex&#125;\n\t\t&lt;/if>\n\t\t&lt;if test=\"email != null and email !=''\">\n\t\t\tand email = #&#123;email&#125;\n\t\t&lt;/if>\n\t&lt;/where>\n&lt;/select>\n\n\n注意：where标签不能去掉条件后多余的and/or\n  &lt;!--这种用法是错误的，只能去掉条件前面的and/or，条件后面的不行-->\n&lt;if test=\"empName != null and empName !=''\">\nemp_name = #&#123;empName&#125; and\n&lt;/if>\n&lt;if test=\"age != null and age !=''\">\n\tage = #&#123;age&#125;\n&lt;/if>\n\ntrim\ntrim用于去掉或添加标签中的内容  \n常用属性\nprefix：在trim标签中的内容的前面添加某些内容  \nsuffix：在trim标签中的内容的后面添加某些内容 \nprefixOverrides：在trim标签中的内容的前面去掉某些内容  \nsuffixOverrides：在trim标签中的内容的后面去掉某些内容\n\n\n若trim中的标签都不满足条件，则trim标签没有任何效果，也就是只剩下select * from t_emp\n\n&lt;!--List&lt;Emp> getEmpByCondition(Emp emp);-->\n&lt;select id=\"getEmpByCondition\" resultType=\"Emp\">\n\tselect * from t_emp\n\t&lt;trim prefix=\"where\" suffixOverrides=\"and|or\">\n\t\t&lt;if test=\"empName != null and empName !=''\">\n\t\t\temp_name = #&#123;empName&#125; and\n\t\t&lt;/if>\n\t\t&lt;if test=\"age != null and age !=''\">\n\t\t\tage = #&#123;age&#125; and\n\t\t&lt;/if>\n\t\t&lt;if test=\"sex != null and sex !=''\">\n\t\t\tsex = #&#123;sex&#125; or\n\t\t&lt;/if>\n\t\t&lt;if test=\"email != null and email !=''\">\n\t\t\temail = #&#123;email&#125;\n\t\t&lt;/if>\n\t&lt;/trim>\n&lt;/select>\n\n//测试类\n@Test\npublic void getEmpByCondition() &#123;\n\tSqlSession sqlSession = SqlSessionUtils.getSqlSession();\n\tDynamicSQLMapper mapper = sqlSession.getMapper(DynamicSQLMapper.class);\n\tList&lt;Emp> emps= mapper.getEmpByCondition(new Emp(null, \"张三\", null, null, null, null));\n\tSystem.out.println(emps);\n&#125;\n\n\nchoose、when、otherwise\nchoose、when、otherwise相当于if...else if..else\nwhen至少要有一个，otherwise至多只有一个\n\n&lt;select id=\"getEmpByChoose\" resultType=\"Emp\">\n\tselect * from t_emp\n\t&lt;where>\n\t\t&lt;choose>\n\t\t\t&lt;when test=\"empName != null and empName != ''\">\n\t\t\t\temp_name = #&#123;empName&#125;\n\t\t\t&lt;/when>\n\t\t\t&lt;when test=\"age != null and age != ''\">\n\t\t\t\tage = #&#123;age&#125;\n\t\t\t&lt;/when>\n\t\t\t&lt;when test=\"sex != null and sex != ''\">\n\t\t\t\tsex = #&#123;sex&#125;\n\t\t\t&lt;/when>\n\t\t\t&lt;when test=\"email != null and email != ''\">\n\t\t\t\temail = #&#123;email&#125;\n\t\t\t&lt;/when>\n\t\t\t&lt;otherwise>\n\t\t\t\tdid = 1\n\t\t\t&lt;/otherwise>\n\t\t&lt;/choose>\n\t&lt;/where>\n&lt;/select>\n\n@Test\npublic void getEmpByChoose() &#123;\n\tSqlSession sqlSession = SqlSessionUtils.getSqlSession();\n\tDynamicSQLMapper mapper = sqlSession.getMapper(DynamicSQLMapper.class);\n\tList&lt;Emp> emps = mapper.getEmpByChoose(new Emp(null, \"张三\", 23, \"男\", \"123@qq.com\", null));\n\tSystem.out.println(emps);\n&#125;\n\n\n\n相当于if a else if b else if c else d，只会执行其中一个\n\nforeach\n属性：  \n\ncollection：设置要循环的数组或集合  \n\nitem：表示集合或数组中的每一个数据  \nseparator：设置循环体之间的分隔符，分隔符前后默认有一个空格，如,\nopen：设置foreach标签中的内容的开始符  \nclose：设置foreach标签中的内容的结束符\n\n\n批量删除\n  &lt;!--int deleteMoreByArray(Integer[] eids);-->\n&lt;delete id=\"deleteMoreByArray\">\n\tdelete from t_emp where eid in\n\t&lt;foreach collection=\"eids\" item=\"eid\" separator=\",\" open=\"(\" close=\")\">\n\t\t#&#123;eid&#125;\n\t&lt;/foreach>\n&lt;/delete>\n  @Test\npublic void deleteMoreByArray() &#123;\n\tSqlSession sqlSession = SqlSessionUtils.getSqlSession();\n\tDynamicSQLMapper mapper = sqlSession.getMapper(DynamicSQLMapper.class);\n\tint result = mapper.deleteMoreByArray(new Integer[]&#123;6, 7, 8, 9&#125;);\n\tSystem.out.println(result);\n&#125;\n批量添加\n  &lt;!--int insertMoreByList(@Param(\"emps\") List&lt;Emp> emps);-->\n&lt;insert id=\"insertMoreByList\">\n\tinsert into t_emp values\n\t&lt;foreach collection=\"emps\" item=\"emp\" separator=\",\">\n\t\t(null,#&#123;emp.empName&#125;,#&#123;emp.age&#125;,#&#123;emp.sex&#125;,#&#123;emp.email&#125;,null)\n\t&lt;/foreach>\n&lt;/insert>\n  @Test\npublic void insertMoreByList() &#123;\n\tSqlSession sqlSession = SqlSessionUtils.getSqlSession();\n\tDynamicSQLMapper mapper = sqlSession.getMapper(DynamicSQLMapper.class);\n\tEmp emp1 = new Emp(null,\"a\",1,\"男\",\"123@321.com\",null);\n\tEmp emp2 = new Emp(null,\"b\",1,\"男\",\"123@321.com\",null);\n\tEmp emp3 = new Emp(null,\"c\",1,\"男\",\"123@321.com\",null);\n\tList&lt;Emp> emps = Arrays.asList(emp1, emp2, emp3);\n\tint result = mapper.insertMoreByList(emps);\n\tSystem.out.println(result);\n&#125;\n\n","slug":"Java/Mybatis","date":"2022-11-17T09:00:00.000Z","categories_index":"Java","tags_index":"Java","author_index":"YimooRua"}]